diff -Nr -c25 ac_am/src/libipsec/pfkey.c ac_am_fixed/src/libipsec/pfkey.c
*** ac_am/src/libipsec/pfkey.c	2003-03-04 00:56:54.000000000 +0100
--- ac_am_fixed/src/libipsec/pfkey.c	2003-12-11 18:19:59.109062176 +0100
***************
*** 314,364 ****
   * get current rate for SOFT lifetime against HARD one.
   * ATTENTION: ~0 is returned if invalid type was passed.
   */
  u_int
  pfkey_get_softrate(type)
  	u_int type;
  {
  	switch (type) {
  	case SADB_X_LIFETIME_ALLOCATIONS:
  		return soft_lifetime_allocations_rate;
  	case SADB_X_LIFETIME_BYTES:
  		return soft_lifetime_bytes_rate;
  	case SADB_X_LIFETIME_ADDTIME:
  		return soft_lifetime_addtime_rate;
  	case SADB_X_LIFETIME_USETIME:
  		return soft_lifetime_usetime_rate;
  	}
  
  	return ~0;
  }
  
  /*
   * sending SADB_GETSPI message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occurred, and set errno.
   */
  int
  pfkey_send_getspi(so, satype, mode, src, dst, min, max, reqid, seq)
  	int so;
  	u_int satype, mode;
  	struct sockaddr *src, *dst;
  	u_int32_t min, max, reqid, seq;
  {
  	struct sadb_msg *newmsg;
  	caddr_t ep;
  	int len;
  	int need_spirange = 0;
  	caddr_t p;
  	int plen;
  
  	/* validity check */
  	if (src == NULL || dst == NULL) {
  		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
  		return -1;
  	}
  	if (src->sa_family != dst->sa_family) {
  		__ipsec_errcode = EIPSEC_FAMILY_MISMATCH;
  		return -1;
  	}
  	if (min > max || (min > 0 && min <= 255)) {
--- 314,364 ----
   * get current rate for SOFT lifetime against HARD one.
   * ATTENTION: ~0 is returned if invalid type was passed.
   */
  u_int
  pfkey_get_softrate(type)
  	u_int type;
  {
  	switch (type) {
  	case SADB_X_LIFETIME_ALLOCATIONS:
  		return soft_lifetime_allocations_rate;
  	case SADB_X_LIFETIME_BYTES:
  		return soft_lifetime_bytes_rate;
  	case SADB_X_LIFETIME_ADDTIME:
  		return soft_lifetime_addtime_rate;
  	case SADB_X_LIFETIME_USETIME:
  		return soft_lifetime_usetime_rate;
  	}
  
  	return ~0;
  }
  
  /*
   * sending SADB_GETSPI message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occured, and set errno.
   */
  int
  pfkey_send_getspi(so, satype, mode, src, dst, min, max, reqid, seq)
  	int so;
  	u_int satype, mode;
  	struct sockaddr *src, *dst;
  	u_int32_t min, max, reqid, seq;
  {
  	struct sadb_msg *newmsg;
  	caddr_t ep;
  	int len;
  	int need_spirange = 0;
  	caddr_t p;
  	int plen;
  
  	/* validity check */
  	if (src == NULL || dst == NULL) {
  		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
  		return -1;
  	}
  	if (src->sa_family != dst->sa_family) {
  		__ipsec_errcode = EIPSEC_FAMILY_MISMATCH;
  		return -1;
  	}
  	if (min > max || (min > 0 && min <= 255)) {
***************
*** 443,493 ****
  		memcpy(p, &spirange, sizeof(spirange));
  
  		p += sizeof(spirange);
  	}
  	if (p != ep) {
  		free(newmsg);
  		return -1;
  	}
  
  	/* send message */
  	len = pfkey_send(so, newmsg, len);
  	free(newmsg);
  
  	if (len < 0)
  		return -1;
  
  	__ipsec_errcode = EIPSEC_NO_ERROR;
  	return len;
  }
  
  /*
   * sending SADB_UPDATE message to the kernel.
   * The length of key material is a_keylen + e_keylen.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occurred, and set errno.
   */
  int
  pfkey_send_update(so, satype, mode, src, dst, spi, reqid, wsize,
  		keymat, e_type, e_keylen, a_type, a_keylen, flags,
  		l_alloc, l_bytes, l_addtime, l_usetime, seq)
  	int so;
  	u_int satype, mode, wsize;
  	struct sockaddr *src, *dst;
  	u_int32_t spi, reqid;
  	caddr_t keymat;
  	u_int e_type, e_keylen, a_type, a_keylen, flags;
  	u_int32_t l_alloc;
  	u_int64_t l_bytes, l_addtime, l_usetime;
  	u_int32_t seq;
  {
  	int len;
  	if ((len = pfkey_send_x1(so, SADB_UPDATE, satype, mode, src, dst, spi,
  			reqid, wsize,
  			keymat, e_type, e_keylen, a_type, a_keylen, flags,
  			l_alloc, l_bytes, l_addtime, l_usetime, seq)) < 0)
  		return -1;
  
  	return len;
  }
  
--- 443,493 ----
  		memcpy(p, &spirange, sizeof(spirange));
  
  		p += sizeof(spirange);
  	}
  	if (p != ep) {
  		free(newmsg);
  		return -1;
  	}
  
  	/* send message */
  	len = pfkey_send(so, newmsg, len);
  	free(newmsg);
  
  	if (len < 0)
  		return -1;
  
  	__ipsec_errcode = EIPSEC_NO_ERROR;
  	return len;
  }
  
  /*
   * sending SADB_UPDATE message to the kernel.
   * The length of key material is a_keylen + e_keylen.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occured, and set errno.
   */
  int
  pfkey_send_update(so, satype, mode, src, dst, spi, reqid, wsize,
  		keymat, e_type, e_keylen, a_type, a_keylen, flags,
  		l_alloc, l_bytes, l_addtime, l_usetime, seq)
  	int so;
  	u_int satype, mode, wsize;
  	struct sockaddr *src, *dst;
  	u_int32_t spi, reqid;
  	caddr_t keymat;
  	u_int e_type, e_keylen, a_type, a_keylen, flags;
  	u_int32_t l_alloc;
  	u_int64_t l_bytes, l_addtime, l_usetime;
  	u_int32_t seq;
  {
  	int len;
  	if ((len = pfkey_send_x1(so, SADB_UPDATE, satype, mode, src, dst, spi,
  			reqid, wsize,
  			keymat, e_type, e_keylen, a_type, a_keylen, flags,
  			l_alloc, l_bytes, l_addtime, l_usetime, seq)) < 0)
  		return -1;
  
  	return len;
  }
  
***************
*** 504,577 ****
  		l_alloc, l_bytes, l_addtime, l_usetime, seq)
  	int so;
  	u_int satype, mode, wsize;
  	struct sockaddr *src, *dst;
  	u_int32_t spi, reqid;
  	caddr_t keymat;
  	u_int e_type, e_keylen, a_type, a_keylen, flags;
  	u_int32_t l_alloc;
  	u_int64_t l_bytes, l_addtime, l_usetime;
  	u_int32_t seq;
  {
  	int len;
  	if ((len = pfkey_send_x1(so, SADB_ADD, satype, mode, src, dst, spi,
  			reqid, wsize,
  			keymat, e_type, e_keylen, a_type, a_keylen, flags,
  			l_alloc, l_bytes, l_addtime, l_usetime, seq)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_DELETE message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occurred, and set errno.
   */
  int
  pfkey_send_delete(so, satype, mode, src, dst, spi)
  	int so;
  	u_int satype, mode;
  	struct sockaddr *src, *dst;
  	u_int32_t spi;
  {
  	int len;
  	if ((len = pfkey_send_x2(so, SADB_DELETE, satype, mode, src, dst, spi)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_DELETE without spi to the kernel.  This is
   * the "delete all" request (an extension also present in
   * Solaris).
   *
   * OUT:
   *	positive: success and return length sent
!  *	-1	: error occurred, and set errno
   */
  int
  pfkey_send_delete_all(so, satype, mode, src, dst)
  	int so;
  	u_int satype, mode;
  	struct sockaddr *src, *dst;
  {
  	struct sadb_msg *newmsg;
  	int len;
  	caddr_t p;
  	int plen;
  	caddr_t ep;
  
  	/* validity check */
  	if (src == NULL || dst == NULL) {
  		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
  		return -1;
  	}
  	if (src->sa_family != dst->sa_family) {
  		__ipsec_errcode = EIPSEC_FAMILY_MISMATCH;
  		return -1;
  	}
  	switch (src->sa_family) {
  	case AF_INET:
  		plen = sizeof(struct in_addr) << 3;
--- 504,577 ----
  		l_alloc, l_bytes, l_addtime, l_usetime, seq)
  	int so;
  	u_int satype, mode, wsize;
  	struct sockaddr *src, *dst;
  	u_int32_t spi, reqid;
  	caddr_t keymat;
  	u_int e_type, e_keylen, a_type, a_keylen, flags;
  	u_int32_t l_alloc;
  	u_int64_t l_bytes, l_addtime, l_usetime;
  	u_int32_t seq;
  {
  	int len;
  	if ((len = pfkey_send_x1(so, SADB_ADD, satype, mode, src, dst, spi,
  			reqid, wsize,
  			keymat, e_type, e_keylen, a_type, a_keylen, flags,
  			l_alloc, l_bytes, l_addtime, l_usetime, seq)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_DELETE message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occured, and set errno.
   */
  int
  pfkey_send_delete(so, satype, mode, src, dst, spi)
  	int so;
  	u_int satype, mode;
  	struct sockaddr *src, *dst;
  	u_int32_t spi;
  {
  	int len;
  	if ((len = pfkey_send_x2(so, SADB_DELETE, satype, mode, src, dst, spi)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_DELETE without spi to the kernel.  This is
   * the "delete all" request (an extension also present in
   * Solaris).
   *
   * OUT:
   *	positive: success and return length sent
!  *	-1	: error occured, and set errno
   */
  int
  pfkey_send_delete_all(so, satype, mode, src, dst)
  	int so;
  	u_int satype, mode;
  	struct sockaddr *src, *dst;
  {
  	struct sadb_msg *newmsg;
  	int len;
  	caddr_t p;
  	int plen;
  	caddr_t ep;
  
  	/* validity check */
  	if (src == NULL || dst == NULL) {
  		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
  		return -1;
  	}
  	if (src->sa_family != dst->sa_family) {
  		__ipsec_errcode = EIPSEC_FAMILY_MISMATCH;
  		return -1;
  	}
  	switch (src->sa_family) {
  	case AF_INET:
  		plen = sizeof(struct in_addr) << 3;
***************
*** 609,758 ****
  		free(newmsg);
  		return -1;
  	}
  	p = pfkey_setsadbaddr(p, ep, SADB_EXT_ADDRESS_DST, dst, plen,
  	    IPSEC_ULPROTO_ANY);
  	if (!p || p != ep) {
  		free(newmsg);
  		return -1;
  	}
  
  	/* send message */
  	len = pfkey_send(so, newmsg, len);
  	free(newmsg);
  
  	if (len < 0)
  		return -1;
  
  	__ipsec_errcode = EIPSEC_NO_ERROR;
  	return len;
  }
  
  /*
   * sending SADB_GET message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occurred, and set errno.
   */
  int
  pfkey_send_get(so, satype, mode, src, dst, spi)
  	int so;
  	u_int satype, mode;
  	struct sockaddr *src, *dst;
  	u_int32_t spi;
  {
  	int len;
  	if ((len = pfkey_send_x2(so, SADB_GET, satype, mode, src, dst, spi)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_REGISTER message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occurred, and set errno.
   */
  int
  pfkey_send_register(so, satype)
  	int so;
  	u_int satype;
  {
  	int len, algno;
  
  	if (satype == PF_UNSPEC) {
  		for (algno = 0;
  		     algno < sizeof(supported_map)/sizeof(supported_map[0]);
  		     algno++) {
  			if (ipsec_supported[algno]) {
  				free(ipsec_supported[algno]);
  				ipsec_supported[algno] = NULL;
  			}
  		}
  	} else {
  		algno = findsupportedmap(satype);
  		if (algno == -1) {
  			__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
  			return -1;
  		}
  
  		if (ipsec_supported[algno]) {
  			free(ipsec_supported[algno]);
  			ipsec_supported[algno] = NULL;
  		}
  	}
  
  	if ((len = pfkey_send_x3(so, SADB_REGISTER, satype)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * receiving SADB_REGISTER message from the kernel, and copy buffer for
   * sadb_supported returned into ipsec_supported.
   * OUT:
   *	 0: success and return length sent.
!  *	-1: error occurred, and set errno.
   */
  int
  pfkey_recv_register(so)
  	int so;
  {
  	pid_t pid = getpid();
  	struct sadb_msg *newmsg;
  	int error = -1;
  
  	/* receive message */
! 	do {
  		if ((newmsg = pfkey_recv(so)) == NULL)
  			return -1;
! 	} while (newmsg->sadb_msg_type != SADB_REGISTER
! 	    || newmsg->sadb_msg_pid != pid);
  
  	/* check and fix */
  	newmsg->sadb_msg_len = PFKEY_UNUNIT64(newmsg->sadb_msg_len);
  
  	error = pfkey_set_supported(newmsg, newmsg->sadb_msg_len);
  	free(newmsg);
  
  	if (error == 0)
  		__ipsec_errcode = EIPSEC_NO_ERROR;
  
  	return error;
  }
  
  /*
   * receiving SADB_REGISTER message from the kernel, and copy buffer for
   * sadb_supported returned into ipsec_supported.
   * NOTE: sadb_msg_len must be host order.
   * IN:
   *	tlen: msg length, it's to makeing sure.
   * OUT:
   *	 0: success and return length sent.
!  *	-1: error occurred, and set errno.
   */
  int
  pfkey_set_supported(msg, tlen)
  	struct sadb_msg *msg;
  	int tlen;
  {
  	struct sadb_supported *sup;
  	caddr_t p;
  	caddr_t ep;
  
  	/* validity */
  	if (msg->sadb_msg_len != tlen) {
  		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
  		return -1;
  	}
  
  	p = (caddr_t)msg;
  	ep = p + tlen;
  
  	p += sizeof(struct sadb_msg);
  
  	while (p < ep) {
  		sup = (struct sadb_supported *)p;
  		if (ep < p + sizeof(*sup) ||
  		    PFKEY_EXTLEN(sup) < sizeof(*sup) ||
--- 609,761 ----
  		free(newmsg);
  		return -1;
  	}
  	p = pfkey_setsadbaddr(p, ep, SADB_EXT_ADDRESS_DST, dst, plen,
  	    IPSEC_ULPROTO_ANY);
  	if (!p || p != ep) {
  		free(newmsg);
  		return -1;
  	}
  
  	/* send message */
  	len = pfkey_send(so, newmsg, len);
  	free(newmsg);
  
  	if (len < 0)
  		return -1;
  
  	__ipsec_errcode = EIPSEC_NO_ERROR;
  	return len;
  }
  
  /*
   * sending SADB_GET message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occured, and set errno.
   */
  int
  pfkey_send_get(so, satype, mode, src, dst, spi)
  	int so;
  	u_int satype, mode;
  	struct sockaddr *src, *dst;
  	u_int32_t spi;
  {
  	int len;
  	if ((len = pfkey_send_x2(so, SADB_GET, satype, mode, src, dst, spi)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_REGISTER message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occured, and set errno.
   */
  int
  pfkey_send_register(so, satype)
  	int so;
  	u_int satype;
  {
  	int len, algno;
  
  	if (satype == PF_UNSPEC) {
  		for (algno = 0;
  		     algno < sizeof(supported_map)/sizeof(supported_map[0]);
  		     algno++) {
  			if (ipsec_supported[algno]) {
  				free(ipsec_supported[algno]);
  				ipsec_supported[algno] = NULL;
  			}
  		}
  	} else {
  		algno = findsupportedmap(satype);
  		if (algno == -1) {
  			__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
  			return -1;
  		}
  
  		if (ipsec_supported[algno]) {
  			free(ipsec_supported[algno]);
  			ipsec_supported[algno] = NULL;
  		}
  	}
  
  	if ((len = pfkey_send_x3(so, SADB_REGISTER, satype)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * receiving SADB_REGISTER message from the kernel, and copy buffer for
   * sadb_supported returned into ipsec_supported.
   * OUT:
   *	 0: success and return length sent.
!  *	-1: error occured, and set errno.
   */
  int
  pfkey_recv_register(so)
  	int so;
  {
  	pid_t pid = getpid();
  	struct sadb_msg *newmsg;
  	int error = -1;
  
  	/* receive message */
! 	for (;;) {
  		if ((newmsg = pfkey_recv(so)) == NULL)
  			return -1;
! 		if (newmsg->sadb_msg_type == SADB_REGISTER &&
! 		    newmsg->sadb_msg_pid == pid)
! 			break;
! 		free(newmsg);
! 	}
  
  	/* check and fix */
  	newmsg->sadb_msg_len = PFKEY_UNUNIT64(newmsg->sadb_msg_len);
  
  	error = pfkey_set_supported(newmsg, newmsg->sadb_msg_len);
  	free(newmsg);
  
  	if (error == 0)
  		__ipsec_errcode = EIPSEC_NO_ERROR;
  
  	return error;
  }
  
  /*
   * receiving SADB_REGISTER message from the kernel, and copy buffer for
   * sadb_supported returned into ipsec_supported.
   * NOTE: sadb_msg_len must be host order.
   * IN:
   *	tlen: msg length, it's to makeing sure.
   * OUT:
   *	 0: success and return length sent.
!  *	-1: error occured, and set errno.
   */
  int
  pfkey_set_supported(msg, tlen)
  	struct sadb_msg *msg;
  	int tlen;
  {
  	struct sadb_supported *sup;
  	caddr_t p;
  	caddr_t ep;
  
  	/* validity */
  	if (msg->sadb_msg_len != tlen) {
  		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
  		return -1;
  	}
  
  	p = (caddr_t)msg;
  	ep = p + tlen;
  
  	p += sizeof(struct sadb_msg);
  
  	while (p < ep) {
  		sup = (struct sadb_supported *)p;
  		if (ep < p + sizeof(*sup) ||
  		    PFKEY_EXTLEN(sup) < sizeof(*sup) ||
***************
*** 772,1111 ****
  
  		/* fixed length */
  		sup->sadb_supported_len = PFKEY_EXTLEN(sup);
  
  		/* set supported map */
  		if (setsupportedmap(sup) != 0)
  			return -1;
  
  		p += sup->sadb_supported_len;
  	}
  
  	if (p != ep) {
  		__ipsec_errcode = EIPSEC_INVAL_SATYPE;
  		return -1;
  	}
  
  	__ipsec_errcode = EIPSEC_NO_ERROR;
  
  	return 0;
  }
  
  /*
   * sending SADB_FLUSH message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occurred, and set errno.
   */
  int
  pfkey_send_flush(so, satype)
  	int so;
  	u_int satype;
  {
  	int len;
  
  	if ((len = pfkey_send_x3(so, SADB_FLUSH, satype)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_DUMP message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occurred, and set errno.
   */
  int
  pfkey_send_dump(so, satype)
  	int so;
  	u_int satype;
  {
  	int len;
  
  	if ((len = pfkey_send_x3(so, SADB_DUMP, satype)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_X_PROMISC message to the kernel.
   * NOTE that this function handles promisc mode toggle only.
   * IN:
   *	flag:	set promisc off if zero, set promisc on if non-zero.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occurred, and set errno.
!  *	0     : error occurred, and set errno.
   *	others: a pointer to new allocated buffer in which supported
   *	        algorithms is.
   */
  int
  pfkey_send_promisc_toggle(so, flag)
  	int so;
  	int flag;
  {
  	int len;
  
  	if ((len = pfkey_send_x3(so, SADB_X_PROMISC, (flag ? 1 : 0))) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_X_SPDADD message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occurred, and set errno.
   */
  int
  pfkey_send_spdadd(so, src, prefs, dst, prefd, proto, policy, policylen, seq)
  	int so;
  	struct sockaddr *src, *dst;
  	u_int prefs, prefd, proto;
  	caddr_t policy;
  	int policylen;
  	u_int32_t seq;
  {
  	int len;
  
  	if ((len = pfkey_send_x4(so, SADB_X_SPDADD,
  				src, prefs, dst, prefd, proto,
  				0, 0,
  				policy, policylen, seq)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_X_SPDADD message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occurred, and set errno.
   */
  int
  pfkey_send_spdadd2(so, src, prefs, dst, prefd, proto, ltime, vtime,
  		policy, policylen, seq)
  	int so;
  	struct sockaddr *src, *dst;
  	u_int prefs, prefd, proto;
  	u_int64_t ltime, vtime;
  	caddr_t policy;
  	int policylen;
  	u_int32_t seq;
  {
  	int len;
  
  	if ((len = pfkey_send_x4(so, SADB_X_SPDADD,
  				src, prefs, dst, prefd, proto,
  				ltime, vtime,
  				policy, policylen, seq)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_X_SPDUPDATE message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occurred, and set errno.
   */
  int
  pfkey_send_spdupdate(so, src, prefs, dst, prefd, proto, policy, policylen, seq)
  	int so;
  	struct sockaddr *src, *dst;
  	u_int prefs, prefd, proto;
  	caddr_t policy;
  	int policylen;
  	u_int32_t seq;
  {
  	int len;
  
  	if ((len = pfkey_send_x4(so, SADB_X_SPDUPDATE,
  				src, prefs, dst, prefd, proto,
  				0, 0,
  				policy, policylen, seq)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_X_SPDUPDATE message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occurred, and set errno.
   */
  int
  pfkey_send_spdupdate2(so, src, prefs, dst, prefd, proto, ltime, vtime,
  		policy, policylen, seq)
  	int so;
  	struct sockaddr *src, *dst;
  	u_int prefs, prefd, proto;
  	u_int64_t ltime, vtime;
  	caddr_t policy;
  	int policylen;
  	u_int32_t seq;
  {
  	int len;
  
  	if ((len = pfkey_send_x4(so, SADB_X_SPDUPDATE,
  				src, prefs, dst, prefd, proto,
  				ltime, vtime,
  				policy, policylen, seq)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_X_SPDDELETE message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occurred, and set errno.
   */
  int
  pfkey_send_spddelete(so, src, prefs, dst, prefd, proto, policy, policylen, seq)
  	int so;
  	struct sockaddr *src, *dst;
  	u_int prefs, prefd, proto;
  	caddr_t policy;
  	int policylen;
  	u_int32_t seq;
  {
  	int len;
  
  	if (policylen != sizeof(struct sadb_x_policy)) {
  		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
  		return -1;
  	}
  
  	if ((len = pfkey_send_x4(so, SADB_X_SPDDELETE,
  				src, prefs, dst, prefd, proto,
  				0, 0,
  				policy, policylen, seq)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_X_SPDDELETE message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occurred, and set errno.
   */
  int
  pfkey_send_spddelete2(so, spid)
  	int so;
  	u_int32_t spid;
  {
  	int len;
  
  	if ((len = pfkey_send_x5(so, SADB_X_SPDDELETE2, spid)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_X_SPDGET message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occurred, and set errno.
   */
  int
  pfkey_send_spdget(so, spid)
  	int so;
  	u_int32_t spid;
  {
  	int len;
  
  	if ((len = pfkey_send_x5(so, SADB_X_SPDGET, spid)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_X_SPDSETIDX message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occurred, and set errno.
   */
  int
  pfkey_send_spdsetidx(so, src, prefs, dst, prefd, proto, policy, policylen, seq)
  	int so;
  	struct sockaddr *src, *dst;
  	u_int prefs, prefd, proto;
  	caddr_t policy;
  	int policylen;
  	u_int32_t seq;
  {
  	int len;
  
  	if (policylen != sizeof(struct sadb_x_policy)) {
  		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
  		return -1;
  	}
  
  	if ((len = pfkey_send_x4(so, SADB_X_SPDSETIDX,
  				src, prefs, dst, prefd, proto,
  				0, 0,
  				policy, policylen, seq)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_SPDFLUSH message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occurred, and set errno.
   */
  int
  pfkey_send_spdflush(so)
  	int so;
  {
  	int len;
  
  	if ((len = pfkey_send_x3(so, SADB_X_SPDFLUSH, SADB_SATYPE_UNSPEC)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_SPDDUMP message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occurred, and set errno.
   */
  int
  pfkey_send_spddump(so)
  	int so;
  {
  	int len;
  
  	if ((len = pfkey_send_x3(so, SADB_X_SPDDUMP, SADB_SATYPE_UNSPEC)) < 0)
  		return -1;
  
  	return len;
  }
  
  /* sending SADB_ADD or SADB_UPDATE message to the kernel */
  static int
  pfkey_send_x1(so, type, satype, mode, src, dst, spi, reqid, wsize,
  		keymat, e_type, e_keylen, a_type, a_keylen, flags,
  		l_alloc, l_bytes, l_addtime, l_usetime, seq)
  	int so;
  	u_int type, satype, mode;
  	struct sockaddr *src, *dst;
  	u_int32_t spi, reqid;
  	u_int wsize;
  	caddr_t keymat;
  	u_int e_type, e_keylen, a_type, a_keylen, flags;
--- 775,1114 ----
  
  		/* fixed length */
  		sup->sadb_supported_len = PFKEY_EXTLEN(sup);
  
  		/* set supported map */
  		if (setsupportedmap(sup) != 0)
  			return -1;
  
  		p += sup->sadb_supported_len;
  	}
  
  	if (p != ep) {
  		__ipsec_errcode = EIPSEC_INVAL_SATYPE;
  		return -1;
  	}
  
  	__ipsec_errcode = EIPSEC_NO_ERROR;
  
  	return 0;
  }
  
  /*
   * sending SADB_FLUSH message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occured, and set errno.
   */
  int
  pfkey_send_flush(so, satype)
  	int so;
  	u_int satype;
  {
  	int len;
  
  	if ((len = pfkey_send_x3(so, SADB_FLUSH, satype)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_DUMP message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occured, and set errno.
   */
  int
  pfkey_send_dump(so, satype)
  	int so;
  	u_int satype;
  {
  	int len;
  
  	if ((len = pfkey_send_x3(so, SADB_DUMP, satype)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_X_PROMISC message to the kernel.
   * NOTE that this function handles promisc mode toggle only.
   * IN:
   *	flag:	set promisc off if zero, set promisc on if non-zero.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occured, and set errno.
!  *	0     : error occured, and set errno.
   *	others: a pointer to new allocated buffer in which supported
   *	        algorithms is.
   */
  int
  pfkey_send_promisc_toggle(so, flag)
  	int so;
  	int flag;
  {
  	int len;
  
  	if ((len = pfkey_send_x3(so, SADB_X_PROMISC, (flag ? 1 : 0))) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_X_SPDADD message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occured, and set errno.
   */
  int
  pfkey_send_spdadd(so, src, prefs, dst, prefd, proto, policy, policylen, seq)
  	int so;
  	struct sockaddr *src, *dst;
  	u_int prefs, prefd, proto;
  	caddr_t policy;
  	int policylen;
  	u_int32_t seq;
  {
  	int len;
  
  	if ((len = pfkey_send_x4(so, SADB_X_SPDADD,
  				src, prefs, dst, prefd, proto,
  				0, 0,
  				policy, policylen, seq)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_X_SPDADD message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occured, and set errno.
   */
  int
  pfkey_send_spdadd2(so, src, prefs, dst, prefd, proto, ltime, vtime,
  		policy, policylen, seq)
  	int so;
  	struct sockaddr *src, *dst;
  	u_int prefs, prefd, proto;
  	u_int64_t ltime, vtime;
  	caddr_t policy;
  	int policylen;
  	u_int32_t seq;
  {
  	int len;
  
  	if ((len = pfkey_send_x4(so, SADB_X_SPDADD,
  				src, prefs, dst, prefd, proto,
  				ltime, vtime,
  				policy, policylen, seq)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_X_SPDUPDATE message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occured, and set errno.
   */
  int
  pfkey_send_spdupdate(so, src, prefs, dst, prefd, proto, policy, policylen, seq)
  	int so;
  	struct sockaddr *src, *dst;
  	u_int prefs, prefd, proto;
  	caddr_t policy;
  	int policylen;
  	u_int32_t seq;
  {
  	int len;
  
  	if ((len = pfkey_send_x4(so, SADB_X_SPDUPDATE,
  				src, prefs, dst, prefd, proto,
  				0, 0,
  				policy, policylen, seq)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_X_SPDUPDATE message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occured, and set errno.
   */
  int
  pfkey_send_spdupdate2(so, src, prefs, dst, prefd, proto, ltime, vtime,
  		policy, policylen, seq)
  	int so;
  	struct sockaddr *src, *dst;
  	u_int prefs, prefd, proto;
  	u_int64_t ltime, vtime;
  	caddr_t policy;
  	int policylen;
  	u_int32_t seq;
  {
  	int len;
  
  	if ((len = pfkey_send_x4(so, SADB_X_SPDUPDATE,
  				src, prefs, dst, prefd, proto,
  				ltime, vtime,
  				policy, policylen, seq)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_X_SPDDELETE message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occured, and set errno.
   */
  int
  pfkey_send_spddelete(so, src, prefs, dst, prefd, proto, policy, policylen, seq)
  	int so;
  	struct sockaddr *src, *dst;
  	u_int prefs, prefd, proto;
  	caddr_t policy;
  	int policylen;
  	u_int32_t seq;
  {
  	int len;
  
  	if (policylen != sizeof(struct sadb_x_policy)) {
  		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
  		return -1;
  	}
  
  	if ((len = pfkey_send_x4(so, SADB_X_SPDDELETE,
  				src, prefs, dst, prefd, proto,
  				0, 0,
  				policy, policylen, seq)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_X_SPDDELETE message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occured, and set errno.
   */
  int
  pfkey_send_spddelete2(so, spid)
  	int so;
  	u_int32_t spid;
  {
  	int len;
  
  	if ((len = pfkey_send_x5(so, SADB_X_SPDDELETE2, spid)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_X_SPDGET message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occured, and set errno.
   */
  int
  pfkey_send_spdget(so, spid)
  	int so;
  	u_int32_t spid;
  {
  	int len;
  
  	if ((len = pfkey_send_x5(so, SADB_X_SPDGET, spid)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_X_SPDSETIDX message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occured, and set errno.
   */
  int
  pfkey_send_spdsetidx(so, src, prefs, dst, prefd, proto, policy, policylen, seq)
  	int so;
  	struct sockaddr *src, *dst;
  	u_int prefs, prefd, proto;
  	caddr_t policy;
  	int policylen;
  	u_int32_t seq;
  {
  	int len;
  
  	if (policylen != sizeof(struct sadb_x_policy)) {
  		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
  		return -1;
  	}
  
  	if ((len = pfkey_send_x4(so, SADB_X_SPDSETIDX,
  				src, prefs, dst, prefd, proto,
  				0, 0,
  				policy, policylen, seq)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_SPDFLUSH message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occured, and set errno.
   */
  int
  pfkey_send_spdflush(so)
  	int so;
  {
  	int len;
  
  	if ((len = pfkey_send_x3(so, SADB_X_SPDFLUSH, SADB_SATYPE_UNSPEC)) < 0)
  		return -1;
  
  	return len;
  }
  
  /*
   * sending SADB_SPDDUMP message to the kernel.
   * OUT:
   *	positive: success and return length sent.
!  *	-1	: error occured, and set errno.
   */
  int
  pfkey_send_spddump(so)
  	int so;
  {
  	int len;
  
  	if ((len = pfkey_send_x3(so, SADB_X_SPDDUMP, SADB_SATYPE_UNSPEC)) < 0)
  		return -1;
  
  	return len;
  }
  
  /* sending SADB_ADD or SADB_UPDATE message to the kernel */
  static int
  pfkey_send_x1(so, type, satype, mode, src, dst, spi, reqid, wsize,
  		keymat, e_type, e_keylen, a_type, a_keylen, flags,
  		l_alloc, l_bytes, l_addtime, l_usetime, seq)
  	int so;
  	u_int type, satype, mode;
  	struct sockaddr *src, *dst;
  	u_int32_t spi, reqid;
  	u_int wsize;
  	caddr_t keymat;
  	u_int e_type, e_keylen, a_type, a_keylen, flags;
***************
*** 1580,1630 ****
  
  	__ipsec_errcode = EIPSEC_NO_ERROR;
  	return so;
  }
  
  /*
   * close a socket.
   * OUT:
   *	 0: success.
   *	-1: fail.
   */
  void
  pfkey_close(so)
  	int so;
  {
  	(void)close(so);
  
  	__ipsec_errcode = EIPSEC_NO_ERROR;
  	return;
  }
  
  /*
   * receive sadb_msg data, and return pointer to new buffer allocated.
   * Must free this buffer later.
   * OUT:
!  *	NULL	: error occurred.
   *	others	: a pointer to sadb_msg structure.
   *
   * XXX should be rewritten to pass length explicitly
   */
  struct sadb_msg *
  pfkey_recv(so)
  	int so;
  {
  	struct sadb_msg buf, *newmsg;
  	int len, reallen;
  
  	while ((len = recv(so, (caddr_t)&buf, sizeof(buf), MSG_PEEK)) < 0) {
  		if (errno == EINTR)
  			continue;
  		__ipsec_set_strerror(strerror(errno));
  		return NULL;
  	}
  
  	if (len < sizeof(buf)) {
  		recv(so, (caddr_t)&buf, sizeof(buf), 0);
  		__ipsec_errcode = EIPSEC_MAX;
  		return NULL;
  	}
  
  	/* read real message */
--- 1583,1633 ----
  
  	__ipsec_errcode = EIPSEC_NO_ERROR;
  	return so;
  }
  
  /*
   * close a socket.
   * OUT:
   *	 0: success.
   *	-1: fail.
   */
  void
  pfkey_close(so)
  	int so;
  {
  	(void)close(so);
  
  	__ipsec_errcode = EIPSEC_NO_ERROR;
  	return;
  }
  
  /*
   * receive sadb_msg data, and return pointer to new buffer allocated.
   * Must free this buffer later.
   * OUT:
!  *	NULL	: error occured.
   *	others	: a pointer to sadb_msg structure.
   *
   * XXX should be rewritten to pass length explicitly
   */
  struct sadb_msg *
  pfkey_recv(so)
  	int so;
  {
  	struct sadb_msg buf, *newmsg;
  	int len, reallen;
  
  	while ((len = recv(so, (caddr_t)&buf, sizeof(buf), MSG_PEEK)) < 0) {
  		if (errno == EINTR)
  			continue;
  		__ipsec_set_strerror(strerror(errno));
  		return NULL;
  	}
  
  	if (len < sizeof(buf)) {
  		recv(so, (caddr_t)&buf, sizeof(buf), 0);
  		__ipsec_errcode = EIPSEC_MAX;
  		return NULL;
  	}
  
  	/* read real message */
diff -Nr -c25 ac_am/src/libipsec/pfkey.c.orig ac_am_fixed/src/libipsec/pfkey.c.orig
*** ac_am/src/libipsec/pfkey.c.orig	1970-01-01 01:00:00.000000000 +0100
--- ac_am_fixed/src/libipsec/pfkey.c.orig	2003-12-11 18:19:59.123060048 +0100
***************
*** 0 ****
--- 1,2108 ----
+ /*	$KAME: pfkey.c,v 1.41 2002/05/14 10:59:09 itojun Exp $	*/
+ 
+ /*
+  * Copyright (C) 1995, 1996, 1997, 1998, and 1999 WIDE Project.
+  * All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions
+  * are met:
+  * 1. Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  * 2. Redistributions in binary form must reproduce the above copyright
+  *    notice, this list of conditions and the following disclaimer in the
+  *    documentation and/or other materials provided with the distribution.
+  * 3. Neither the name of the project nor the names of its contributors
+  *    may be used to endorse or promote products derived from this software
+  *    without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+  * SUCH DAMAGE.
+  */
+ 
+ #include <sys/types.h>
+ #include <sys/param.h>
+ #include <sys/socket.h>
+ #include <net/pfkeyv2.h>
+ #include <netinet/in.h>
+ #include <netinet/ipsec.h>
+ 
+ #include <stdlib.h>
+ #include <unistd.h>
+ #include <string.h>
+ #include <errno.h>
+ #include <stdio.h>
+ 
+ #include "ipsec_strerror.h"
+ #include "libpfkey.h"
+ 
+ #define CALLOC(size, cast) (cast)calloc(1, (size))
+ 
+ static int findsupportedmap __P((int));
+ static int setsupportedmap __P((struct sadb_supported *));
+ static struct sadb_alg *findsupportedalg __P((u_int, u_int));
+ static int pfkey_send_x1 __P((int, u_int, u_int, u_int, struct sockaddr *,
+ 	struct sockaddr *, u_int32_t, u_int32_t, u_int, caddr_t,
+ 	u_int, u_int, u_int, u_int, u_int, u_int32_t, u_int32_t,
+ 	u_int32_t, u_int32_t, u_int32_t));
+ static int pfkey_send_x2 __P((int, u_int, u_int, u_int,
+ 	struct sockaddr *, struct sockaddr *, u_int32_t));
+ static int pfkey_send_x3 __P((int, u_int, u_int));
+ static int pfkey_send_x4 __P((int, u_int, struct sockaddr *, u_int,
+ 	struct sockaddr *, u_int, u_int, u_int64_t, u_int64_t,
+ 	char *, int, u_int32_t));
+ static int pfkey_send_x5 __P((int, u_int, u_int32_t));
+ 
+ static caddr_t pfkey_setsadbmsg __P((caddr_t, caddr_t, u_int, u_int,
+ 	u_int, u_int32_t, pid_t));
+ static caddr_t pfkey_setsadbsa __P((caddr_t, caddr_t, u_int32_t, u_int,
+ 	u_int, u_int, u_int32_t));
+ static caddr_t pfkey_setsadbaddr __P((caddr_t, caddr_t, u_int,
+ 	struct sockaddr *, u_int, u_int));
+ static caddr_t pfkey_setsadbkey __P((caddr_t, caddr_t, u_int, caddr_t, u_int));
+ static caddr_t pfkey_setsadblifetime __P((caddr_t, caddr_t, u_int, u_int32_t,
+ 	u_int32_t, u_int32_t, u_int32_t));
+ static caddr_t pfkey_setsadbxsa2 __P((caddr_t, caddr_t, u_int32_t, u_int32_t));
+ 
+ /*
+  * make and search supported algorithm structure.
+  */
+ static struct sadb_supported *ipsec_supported[] = { NULL, NULL, NULL, };
+ 
+ static int supported_map[] = {
+ 	SADB_SATYPE_AH,
+ 	SADB_SATYPE_ESP,
+ 	SADB_X_SATYPE_IPCOMP,
+ };
+ 
+ static int
+ findsupportedmap(satype)
+ 	int satype;
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < sizeof(supported_map)/sizeof(supported_map[0]); i++)
+ 		if (supported_map[i] == satype)
+ 			return i;
+ 	return -1;
+ }
+ 
+ static struct sadb_alg *
+ findsupportedalg(satype, alg_id)
+ 	u_int satype, alg_id;
+ {
+ 	int algno;
+ 	int tlen;
+ 	caddr_t p;
+ 
+ 	/* validity check */
+ 	algno = findsupportedmap(satype);
+ 	if (algno == -1) {
+ 		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
+ 		return NULL;
+ 	}
+ 	if (ipsec_supported[algno] == NULL) {
+ 		__ipsec_errcode = EIPSEC_DO_GET_SUPP_LIST;
+ 		return NULL;
+ 	}
+ 
+ 	tlen = ipsec_supported[algno]->sadb_supported_len
+ 		- sizeof(struct sadb_supported);
+ 	p = (caddr_t)(ipsec_supported[algno] + 1);
+ 	while (tlen > 0) {
+ 		if (tlen < sizeof(struct sadb_alg)) {
+ 			/* invalid format */
+ 			break;
+ 		}
+ 		if (((struct sadb_alg *)p)->sadb_alg_id == alg_id)
+ 			return (struct sadb_alg *)p;
+ 
+ 		tlen -= sizeof(struct sadb_alg);
+ 		p += sizeof(struct sadb_alg);
+ 	}
+ 
+ 	__ipsec_errcode = EIPSEC_NOT_SUPPORTED;
+ 	return NULL;
+ }
+ 
+ static int
+ setsupportedmap(sup)
+ 	struct sadb_supported *sup;
+ {
+ 	struct sadb_supported **ipsup;
+ 
+ 	switch (sup->sadb_supported_exttype) {
+ 	case SADB_EXT_SUPPORTED_AUTH:
+ 		ipsup = &ipsec_supported[findsupportedmap(SADB_SATYPE_AH)];
+ 		break;
+ 	case SADB_EXT_SUPPORTED_ENCRYPT:
+ 		ipsup = &ipsec_supported[findsupportedmap(SADB_SATYPE_ESP)];
+ 		break;
+ 	default:
+ 		__ipsec_errcode = EIPSEC_INVAL_SATYPE;
+ 		return -1;
+ 	}
+ 
+ 	if (*ipsup)
+ 		free(*ipsup);
+ 
+ 	*ipsup = malloc(sup->sadb_supported_len);
+ 	if (!*ipsup) {
+ 		__ipsec_set_strerror(strerror(errno));
+ 		return -1;
+ 	}
+ 	memcpy(*ipsup, sup, sup->sadb_supported_len);
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * check key length against algorithm specified.
+  * This function is called with SADB_EXT_SUPPORTED_{AUTH,ENCRYPT} as the
+  * augument, and only calls to ipsec_check_keylen2();
+  * keylen is the unit of bit.
+  * OUT:
+  *	-1: invalid.
+  *	 0: valid.
+  */
+ int
+ ipsec_check_keylen(supported, alg_id, keylen)
+ 	u_int supported;
+ 	u_int alg_id;
+ 	u_int keylen;
+ {
+ 	int satype;
+ 
+ 	/* validity check */
+ 	switch (supported) {
+ 	case SADB_EXT_SUPPORTED_AUTH:
+ 		satype = SADB_SATYPE_AH;
+ 		break;
+ 	case SADB_EXT_SUPPORTED_ENCRYPT:
+ 		satype = SADB_SATYPE_ESP;
+ 		break;
+ 	default:
+ 		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
+ 		return -1;
+ 	}
+ 
+ 	return ipsec_check_keylen2(satype, alg_id, keylen);
+ }
+ 
+ /*
+  * check key length against algorithm specified.
+  * satype is one of satype defined at pfkeyv2.h.
+  * keylen is the unit of bit.
+  * OUT:
+  *	-1: invalid.
+  *	 0: valid.
+  */
+ int
+ ipsec_check_keylen2(satype, alg_id, keylen)
+ 	u_int satype;
+ 	u_int alg_id;
+ 	u_int keylen;
+ {
+ 	struct sadb_alg *alg;
+ 
+ 	alg = findsupportedalg(satype, alg_id);
+ 	if (!alg)
+ 		return -1;
+ 
+ 	if (keylen < alg->sadb_alg_minbits || keylen > alg->sadb_alg_maxbits) {
+ 		fprintf(stderr, "%d %d %d\n", keylen, alg->sadb_alg_minbits,
+ 			alg->sadb_alg_maxbits);
+ 		__ipsec_errcode = EIPSEC_INVAL_KEYLEN;
+ 		return -1;
+ 	}
+ 
+ 	__ipsec_errcode = EIPSEC_NO_ERROR;
+ 	return 0;
+ }
+ 
+ /*
+  * get max/min key length against algorithm specified.
+  * satype is one of satype defined at pfkeyv2.h.
+  * keylen is the unit of bit.
+  * OUT:
+  *	-1: invalid.
+  *	 0: valid.
+  */
+ int
+ ipsec_get_keylen(supported, alg_id, alg0)
+ 	u_int supported, alg_id;
+ 	struct sadb_alg *alg0;
+ {
+ 	struct sadb_alg *alg;
+ 	u_int satype;
+ 
+ 	/* validity check */
+ 	if (!alg0) {
+ 		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
+ 		return -1;
+ 	}
+ 
+ 	switch (supported) {
+ 	case SADB_EXT_SUPPORTED_AUTH:
+ 		satype = SADB_SATYPE_AH;
+ 		break;
+ 	case SADB_EXT_SUPPORTED_ENCRYPT:
+ 		satype = SADB_SATYPE_ESP;
+ 		break;
+ 	default:
+ 		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
+ 		return -1;
+ 	}
+ 
+ 	alg = findsupportedalg(satype, alg_id);
+ 	if (!alg)
+ 		return -1;
+ 
+ 	memcpy(alg0, alg, sizeof(*alg0));
+ 
+ 	__ipsec_errcode = EIPSEC_NO_ERROR;
+ 	return 0;
+ }
+ 
+ /*
+  * set the rate for SOFT lifetime against HARD one.
+  * If rate is more than 100 or equal to zero, then set to 100.
+  */
+ static u_int soft_lifetime_allocations_rate = PFKEY_SOFT_LIFETIME_RATE;
+ static u_int soft_lifetime_bytes_rate = PFKEY_SOFT_LIFETIME_RATE;
+ static u_int soft_lifetime_addtime_rate = PFKEY_SOFT_LIFETIME_RATE;
+ static u_int soft_lifetime_usetime_rate = PFKEY_SOFT_LIFETIME_RATE;
+ 
+ u_int
+ pfkey_set_softrate(type, rate)
+ 	u_int type, rate;
+ {
+ 	__ipsec_errcode = EIPSEC_NO_ERROR;
+ 
+ 	if (rate > 100 || rate == 0)
+ 		rate = 100;
+ 
+ 	switch (type) {
+ 	case SADB_X_LIFETIME_ALLOCATIONS:
+ 		soft_lifetime_allocations_rate = rate;
+ 		return 0;
+ 	case SADB_X_LIFETIME_BYTES:
+ 		soft_lifetime_bytes_rate = rate;
+ 		return 0;
+ 	case SADB_X_LIFETIME_ADDTIME:
+ 		soft_lifetime_addtime_rate = rate;
+ 		return 0;
+ 	case SADB_X_LIFETIME_USETIME:
+ 		soft_lifetime_usetime_rate = rate;
+ 		return 0;
+ 	}
+ 
+ 	__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
+ 	return 1;
+ }
+ 
+ /*
+  * get current rate for SOFT lifetime against HARD one.
+  * ATTENTION: ~0 is returned if invalid type was passed.
+  */
+ u_int
+ pfkey_get_softrate(type)
+ 	u_int type;
+ {
+ 	switch (type) {
+ 	case SADB_X_LIFETIME_ALLOCATIONS:
+ 		return soft_lifetime_allocations_rate;
+ 	case SADB_X_LIFETIME_BYTES:
+ 		return soft_lifetime_bytes_rate;
+ 	case SADB_X_LIFETIME_ADDTIME:
+ 		return soft_lifetime_addtime_rate;
+ 	case SADB_X_LIFETIME_USETIME:
+ 		return soft_lifetime_usetime_rate;
+ 	}
+ 
+ 	return ~0;
+ }
+ 
+ /*
+  * sending SADB_GETSPI message to the kernel.
+  * OUT:
+  *	positive: success and return length sent.
+  *	-1	: error occurred, and set errno.
+  */
+ int
+ pfkey_send_getspi(so, satype, mode, src, dst, min, max, reqid, seq)
+ 	int so;
+ 	u_int satype, mode;
+ 	struct sockaddr *src, *dst;
+ 	u_int32_t min, max, reqid, seq;
+ {
+ 	struct sadb_msg *newmsg;
+ 	caddr_t ep;
+ 	int len;
+ 	int need_spirange = 0;
+ 	caddr_t p;
+ 	int plen;
+ 
+ 	/* validity check */
+ 	if (src == NULL || dst == NULL) {
+ 		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
+ 		return -1;
+ 	}
+ 	if (src->sa_family != dst->sa_family) {
+ 		__ipsec_errcode = EIPSEC_FAMILY_MISMATCH;
+ 		return -1;
+ 	}
+ 	if (min > max || (min > 0 && min <= 255)) {
+ 		__ipsec_errcode = EIPSEC_INVAL_SPI;
+ 		return -1;
+ 	}
+ 	switch (src->sa_family) {
+ 	case AF_INET:
+ 		plen = sizeof(struct in_addr) << 3;
+ 		break;
+ 	case AF_INET6:
+ 		plen = sizeof(struct in6_addr) << 3;
+ 		break;
+ 	default:
+ 		__ipsec_errcode = EIPSEC_INVAL_FAMILY;
+ 		return -1;
+ 	}
+ 
+ 	/* create new sadb_msg to send. */
+ 	len = sizeof(struct sadb_msg)
+ 		+ sizeof(struct sadb_x_sa2)
+ 		+ sizeof(struct sadb_address)
+ 		+ PFKEY_ALIGN8(sysdep_sa_len(src))
+ 		+ sizeof(struct sadb_address)
+ 		+ PFKEY_ALIGN8(sysdep_sa_len(dst));
+ 
+ 	if (min > 255 && max < ~0) {
+ 		need_spirange++;
+ 		len += sizeof(struct sadb_spirange);
+ 	}
+ 
+ 	if ((newmsg = CALLOC(len, struct sadb_msg *)) == NULL) {
+ 		__ipsec_set_strerror(strerror(errno));
+ 		return -1;
+ 	}
+ 	ep = ((caddr_t)newmsg) + len;
+ 
+ 	p = pfkey_setsadbmsg((caddr_t)newmsg, ep, SADB_GETSPI,
+ 	    len, satype, seq, getpid());
+ 	if (!p) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 
+ 	p = pfkey_setsadbxsa2(p, ep, mode, reqid);
+ 	if (!p) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 
+ 	/* set sadb_address for source */
+ 	p = pfkey_setsadbaddr(p, ep, SADB_EXT_ADDRESS_SRC, src, plen,
+ 	    IPSEC_ULPROTO_ANY);
+ 	if (!p) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 
+ 	/* set sadb_address for destination */
+ 	p = pfkey_setsadbaddr(p, ep, SADB_EXT_ADDRESS_DST, dst, plen,
+ 	    IPSEC_ULPROTO_ANY);
+ 	if (!p) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 
+ 	/* proccessing spi range */
+ 	if (need_spirange) {
+ 		struct sadb_spirange spirange;
+ 
+ 		if (p + sizeof(spirange) > ep) {
+ 			free(newmsg);
+ 			return -1;
+ 		}
+ 
+ 		memset(&spirange, 0, sizeof(spirange));
+ 		spirange.sadb_spirange_len = PFKEY_UNIT64(sizeof(spirange));
+ 		spirange.sadb_spirange_exttype = SADB_EXT_SPIRANGE;
+ 		spirange.sadb_spirange_min = min;
+ 		spirange.sadb_spirange_max = max;
+ 
+ 		memcpy(p, &spirange, sizeof(spirange));
+ 
+ 		p += sizeof(spirange);
+ 	}
+ 	if (p != ep) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 
+ 	/* send message */
+ 	len = pfkey_send(so, newmsg, len);
+ 	free(newmsg);
+ 
+ 	if (len < 0)
+ 		return -1;
+ 
+ 	__ipsec_errcode = EIPSEC_NO_ERROR;
+ 	return len;
+ }
+ 
+ /*
+  * sending SADB_UPDATE message to the kernel.
+  * The length of key material is a_keylen + e_keylen.
+  * OUT:
+  *	positive: success and return length sent.
+  *	-1	: error occurred, and set errno.
+  */
+ int
+ pfkey_send_update(so, satype, mode, src, dst, spi, reqid, wsize,
+ 		keymat, e_type, e_keylen, a_type, a_keylen, flags,
+ 		l_alloc, l_bytes, l_addtime, l_usetime, seq)
+ 	int so;
+ 	u_int satype, mode, wsize;
+ 	struct sockaddr *src, *dst;
+ 	u_int32_t spi, reqid;
+ 	caddr_t keymat;
+ 	u_int e_type, e_keylen, a_type, a_keylen, flags;
+ 	u_int32_t l_alloc;
+ 	u_int64_t l_bytes, l_addtime, l_usetime;
+ 	u_int32_t seq;
+ {
+ 	int len;
+ 	if ((len = pfkey_send_x1(so, SADB_UPDATE, satype, mode, src, dst, spi,
+ 			reqid, wsize,
+ 			keymat, e_type, e_keylen, a_type, a_keylen, flags,
+ 			l_alloc, l_bytes, l_addtime, l_usetime, seq)) < 0)
+ 		return -1;
+ 
+ 	return len;
+ }
+ 
+ /*
+  * sending SADB_ADD message to the kernel.
+  * The length of key material is a_keylen + e_keylen.
+  * OUT:
+  *	positive: success and return length sent.
+  *	-1	: error occurred, and set errno.
+  */
+ int
+ pfkey_send_add(so, satype, mode, src, dst, spi, reqid, wsize,
+ 		keymat, e_type, e_keylen, a_type, a_keylen, flags,
+ 		l_alloc, l_bytes, l_addtime, l_usetime, seq)
+ 	int so;
+ 	u_int satype, mode, wsize;
+ 	struct sockaddr *src, *dst;
+ 	u_int32_t spi, reqid;
+ 	caddr_t keymat;
+ 	u_int e_type, e_keylen, a_type, a_keylen, flags;
+ 	u_int32_t l_alloc;
+ 	u_int64_t l_bytes, l_addtime, l_usetime;
+ 	u_int32_t seq;
+ {
+ 	int len;
+ 	if ((len = pfkey_send_x1(so, SADB_ADD, satype, mode, src, dst, spi,
+ 			reqid, wsize,
+ 			keymat, e_type, e_keylen, a_type, a_keylen, flags,
+ 			l_alloc, l_bytes, l_addtime, l_usetime, seq)) < 0)
+ 		return -1;
+ 
+ 	return len;
+ }
+ 
+ /*
+  * sending SADB_DELETE message to the kernel.
+  * OUT:
+  *	positive: success and return length sent.
+  *	-1	: error occurred, and set errno.
+  */
+ int
+ pfkey_send_delete(so, satype, mode, src, dst, spi)
+ 	int so;
+ 	u_int satype, mode;
+ 	struct sockaddr *src, *dst;
+ 	u_int32_t spi;
+ {
+ 	int len;
+ 	if ((len = pfkey_send_x2(so, SADB_DELETE, satype, mode, src, dst, spi)) < 0)
+ 		return -1;
+ 
+ 	return len;
+ }
+ 
+ /*
+  * sending SADB_DELETE without spi to the kernel.  This is
+  * the "delete all" request (an extension also present in
+  * Solaris).
+  *
+  * OUT:
+  *	positive: success and return length sent
+  *	-1	: error occurred, and set errno
+  */
+ int
+ pfkey_send_delete_all(so, satype, mode, src, dst)
+ 	int so;
+ 	u_int satype, mode;
+ 	struct sockaddr *src, *dst;
+ {
+ 	struct sadb_msg *newmsg;
+ 	int len;
+ 	caddr_t p;
+ 	int plen;
+ 	caddr_t ep;
+ 
+ 	/* validity check */
+ 	if (src == NULL || dst == NULL) {
+ 		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
+ 		return -1;
+ 	}
+ 	if (src->sa_family != dst->sa_family) {
+ 		__ipsec_errcode = EIPSEC_FAMILY_MISMATCH;
+ 		return -1;
+ 	}
+ 	switch (src->sa_family) {
+ 	case AF_INET:
+ 		plen = sizeof(struct in_addr) << 3;
+ 		break;
+ 	case AF_INET6:
+ 		plen = sizeof(struct in6_addr) << 3;
+ 		break;
+ 	default:
+ 		__ipsec_errcode = EIPSEC_INVAL_FAMILY;
+ 		return -1;
+ 	}
+ 
+ 	/* create new sadb_msg to reply. */
+ 	len = sizeof(struct sadb_msg)
+ 		+ sizeof(struct sadb_address)
+ 		+ PFKEY_ALIGN8(sysdep_sa_len(src))
+ 		+ sizeof(struct sadb_address)
+ 		+ PFKEY_ALIGN8(sysdep_sa_len(dst));
+ 
+ 	if ((newmsg = CALLOC(len, struct sadb_msg *)) == NULL) {
+ 		__ipsec_set_strerror(strerror(errno));
+ 		return -1;
+ 	}
+ 	ep = ((caddr_t)newmsg) + len;
+ 
+ 	p = pfkey_setsadbmsg((caddr_t)newmsg, ep, SADB_DELETE, len, satype, 0,
+ 	    getpid());
+ 	if (!p) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 	p = pfkey_setsadbaddr(p, ep, SADB_EXT_ADDRESS_SRC, src, plen,
+ 	    IPSEC_ULPROTO_ANY);
+ 	if (!p) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 	p = pfkey_setsadbaddr(p, ep, SADB_EXT_ADDRESS_DST, dst, plen,
+ 	    IPSEC_ULPROTO_ANY);
+ 	if (!p || p != ep) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 
+ 	/* send message */
+ 	len = pfkey_send(so, newmsg, len);
+ 	free(newmsg);
+ 
+ 	if (len < 0)
+ 		return -1;
+ 
+ 	__ipsec_errcode = EIPSEC_NO_ERROR;
+ 	return len;
+ }
+ 
+ /*
+  * sending SADB_GET message to the kernel.
+  * OUT:
+  *	positive: success and return length sent.
+  *	-1	: error occurred, and set errno.
+  */
+ int
+ pfkey_send_get(so, satype, mode, src, dst, spi)
+ 	int so;
+ 	u_int satype, mode;
+ 	struct sockaddr *src, *dst;
+ 	u_int32_t spi;
+ {
+ 	int len;
+ 	if ((len = pfkey_send_x2(so, SADB_GET, satype, mode, src, dst, spi)) < 0)
+ 		return -1;
+ 
+ 	return len;
+ }
+ 
+ /*
+  * sending SADB_REGISTER message to the kernel.
+  * OUT:
+  *	positive: success and return length sent.
+  *	-1	: error occurred, and set errno.
+  */
+ int
+ pfkey_send_register(so, satype)
+ 	int so;
+ 	u_int satype;
+ {
+ 	int len, algno;
+ 
+ 	if (satype == PF_UNSPEC) {
+ 		for (algno = 0;
+ 		     algno < sizeof(supported_map)/sizeof(supported_map[0]);
+ 		     algno++) {
+ 			if (ipsec_supported[algno]) {
+ 				free(ipsec_supported[algno]);
+ 				ipsec_supported[algno] = NULL;
+ 			}
+ 		}
+ 	} else {
+ 		algno = findsupportedmap(satype);
+ 		if (algno == -1) {
+ 			__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
+ 			return -1;
+ 		}
+ 
+ 		if (ipsec_supported[algno]) {
+ 			free(ipsec_supported[algno]);
+ 			ipsec_supported[algno] = NULL;
+ 		}
+ 	}
+ 
+ 	if ((len = pfkey_send_x3(so, SADB_REGISTER, satype)) < 0)
+ 		return -1;
+ 
+ 	return len;
+ }
+ 
+ /*
+  * receiving SADB_REGISTER message from the kernel, and copy buffer for
+  * sadb_supported returned into ipsec_supported.
+  * OUT:
+  *	 0: success and return length sent.
+  *	-1: error occurred, and set errno.
+  */
+ int
+ pfkey_recv_register(so)
+ 	int so;
+ {
+ 	pid_t pid = getpid();
+ 	struct sadb_msg *newmsg;
+ 	int error = -1;
+ 
+ 	/* receive message */
+ 	do {
+ 		if ((newmsg = pfkey_recv(so)) == NULL)
+ 			return -1;
+ 	} while (newmsg->sadb_msg_type != SADB_REGISTER
+ 	    || newmsg->sadb_msg_pid != pid);
+ 
+ 	/* check and fix */
+ 	newmsg->sadb_msg_len = PFKEY_UNUNIT64(newmsg->sadb_msg_len);
+ 
+ 	error = pfkey_set_supported(newmsg, newmsg->sadb_msg_len);
+ 	free(newmsg);
+ 
+ 	if (error == 0)
+ 		__ipsec_errcode = EIPSEC_NO_ERROR;
+ 
+ 	return error;
+ }
+ 
+ /*
+  * receiving SADB_REGISTER message from the kernel, and copy buffer for
+  * sadb_supported returned into ipsec_supported.
+  * NOTE: sadb_msg_len must be host order.
+  * IN:
+  *	tlen: msg length, it's to makeing sure.
+  * OUT:
+  *	 0: success and return length sent.
+  *	-1: error occurred, and set errno.
+  */
+ int
+ pfkey_set_supported(msg, tlen)
+ 	struct sadb_msg *msg;
+ 	int tlen;
+ {
+ 	struct sadb_supported *sup;
+ 	caddr_t p;
+ 	caddr_t ep;
+ 
+ 	/* validity */
+ 	if (msg->sadb_msg_len != tlen) {
+ 		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
+ 		return -1;
+ 	}
+ 
+ 	p = (caddr_t)msg;
+ 	ep = p + tlen;
+ 
+ 	p += sizeof(struct sadb_msg);
+ 
+ 	while (p < ep) {
+ 		sup = (struct sadb_supported *)p;
+ 		if (ep < p + sizeof(*sup) ||
+ 		    PFKEY_EXTLEN(sup) < sizeof(*sup) ||
+ 		    ep < p + sup->sadb_supported_len) {
+ 			/* invalid format */
+ 			break;
+ 		}
+ 
+ 		switch (sup->sadb_supported_exttype) {
+ 		case SADB_EXT_SUPPORTED_AUTH:
+ 		case SADB_EXT_SUPPORTED_ENCRYPT:
+ 			break;
+ 		default:
+ 			__ipsec_errcode = EIPSEC_INVAL_SATYPE;
+ 			return -1;
+ 		}
+ 
+ 		/* fixed length */
+ 		sup->sadb_supported_len = PFKEY_EXTLEN(sup);
+ 
+ 		/* set supported map */
+ 		if (setsupportedmap(sup) != 0)
+ 			return -1;
+ 
+ 		p += sup->sadb_supported_len;
+ 	}
+ 
+ 	if (p != ep) {
+ 		__ipsec_errcode = EIPSEC_INVAL_SATYPE;
+ 		return -1;
+ 	}
+ 
+ 	__ipsec_errcode = EIPSEC_NO_ERROR;
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * sending SADB_FLUSH message to the kernel.
+  * OUT:
+  *	positive: success and return length sent.
+  *	-1	: error occurred, and set errno.
+  */
+ int
+ pfkey_send_flush(so, satype)
+ 	int so;
+ 	u_int satype;
+ {
+ 	int len;
+ 
+ 	if ((len = pfkey_send_x3(so, SADB_FLUSH, satype)) < 0)
+ 		return -1;
+ 
+ 	return len;
+ }
+ 
+ /*
+  * sending SADB_DUMP message to the kernel.
+  * OUT:
+  *	positive: success and return length sent.
+  *	-1	: error occurred, and set errno.
+  */
+ int
+ pfkey_send_dump(so, satype)
+ 	int so;
+ 	u_int satype;
+ {
+ 	int len;
+ 
+ 	if ((len = pfkey_send_x3(so, SADB_DUMP, satype)) < 0)
+ 		return -1;
+ 
+ 	return len;
+ }
+ 
+ /*
+  * sending SADB_X_PROMISC message to the kernel.
+  * NOTE that this function handles promisc mode toggle only.
+  * IN:
+  *	flag:	set promisc off if zero, set promisc on if non-zero.
+  * OUT:
+  *	positive: success and return length sent.
+  *	-1	: error occurred, and set errno.
+  *	0     : error occurred, and set errno.
+  *	others: a pointer to new allocated buffer in which supported
+  *	        algorithms is.
+  */
+ int
+ pfkey_send_promisc_toggle(so, flag)
+ 	int so;
+ 	int flag;
+ {
+ 	int len;
+ 
+ 	if ((len = pfkey_send_x3(so, SADB_X_PROMISC, (flag ? 1 : 0))) < 0)
+ 		return -1;
+ 
+ 	return len;
+ }
+ 
+ /*
+  * sending SADB_X_SPDADD message to the kernel.
+  * OUT:
+  *	positive: success and return length sent.
+  *	-1	: error occurred, and set errno.
+  */
+ int
+ pfkey_send_spdadd(so, src, prefs, dst, prefd, proto, policy, policylen, seq)
+ 	int so;
+ 	struct sockaddr *src, *dst;
+ 	u_int prefs, prefd, proto;
+ 	caddr_t policy;
+ 	int policylen;
+ 	u_int32_t seq;
+ {
+ 	int len;
+ 
+ 	if ((len = pfkey_send_x4(so, SADB_X_SPDADD,
+ 				src, prefs, dst, prefd, proto,
+ 				0, 0,
+ 				policy, policylen, seq)) < 0)
+ 		return -1;
+ 
+ 	return len;
+ }
+ 
+ /*
+  * sending SADB_X_SPDADD message to the kernel.
+  * OUT:
+  *	positive: success and return length sent.
+  *	-1	: error occurred, and set errno.
+  */
+ int
+ pfkey_send_spdadd2(so, src, prefs, dst, prefd, proto, ltime, vtime,
+ 		policy, policylen, seq)
+ 	int so;
+ 	struct sockaddr *src, *dst;
+ 	u_int prefs, prefd, proto;
+ 	u_int64_t ltime, vtime;
+ 	caddr_t policy;
+ 	int policylen;
+ 	u_int32_t seq;
+ {
+ 	int len;
+ 
+ 	if ((len = pfkey_send_x4(so, SADB_X_SPDADD,
+ 				src, prefs, dst, prefd, proto,
+ 				ltime, vtime,
+ 				policy, policylen, seq)) < 0)
+ 		return -1;
+ 
+ 	return len;
+ }
+ 
+ /*
+  * sending SADB_X_SPDUPDATE message to the kernel.
+  * OUT:
+  *	positive: success and return length sent.
+  *	-1	: error occurred, and set errno.
+  */
+ int
+ pfkey_send_spdupdate(so, src, prefs, dst, prefd, proto, policy, policylen, seq)
+ 	int so;
+ 	struct sockaddr *src, *dst;
+ 	u_int prefs, prefd, proto;
+ 	caddr_t policy;
+ 	int policylen;
+ 	u_int32_t seq;
+ {
+ 	int len;
+ 
+ 	if ((len = pfkey_send_x4(so, SADB_X_SPDUPDATE,
+ 				src, prefs, dst, prefd, proto,
+ 				0, 0,
+ 				policy, policylen, seq)) < 0)
+ 		return -1;
+ 
+ 	return len;
+ }
+ 
+ /*
+  * sending SADB_X_SPDUPDATE message to the kernel.
+  * OUT:
+  *	positive: success and return length sent.
+  *	-1	: error occurred, and set errno.
+  */
+ int
+ pfkey_send_spdupdate2(so, src, prefs, dst, prefd, proto, ltime, vtime,
+ 		policy, policylen, seq)
+ 	int so;
+ 	struct sockaddr *src, *dst;
+ 	u_int prefs, prefd, proto;
+ 	u_int64_t ltime, vtime;
+ 	caddr_t policy;
+ 	int policylen;
+ 	u_int32_t seq;
+ {
+ 	int len;
+ 
+ 	if ((len = pfkey_send_x4(so, SADB_X_SPDUPDATE,
+ 				src, prefs, dst, prefd, proto,
+ 				ltime, vtime,
+ 				policy, policylen, seq)) < 0)
+ 		return -1;
+ 
+ 	return len;
+ }
+ 
+ /*
+  * sending SADB_X_SPDDELETE message to the kernel.
+  * OUT:
+  *	positive: success and return length sent.
+  *	-1	: error occurred, and set errno.
+  */
+ int
+ pfkey_send_spddelete(so, src, prefs, dst, prefd, proto, policy, policylen, seq)
+ 	int so;
+ 	struct sockaddr *src, *dst;
+ 	u_int prefs, prefd, proto;
+ 	caddr_t policy;
+ 	int policylen;
+ 	u_int32_t seq;
+ {
+ 	int len;
+ 
+ 	if (policylen != sizeof(struct sadb_x_policy)) {
+ 		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
+ 		return -1;
+ 	}
+ 
+ 	if ((len = pfkey_send_x4(so, SADB_X_SPDDELETE,
+ 				src, prefs, dst, prefd, proto,
+ 				0, 0,
+ 				policy, policylen, seq)) < 0)
+ 		return -1;
+ 
+ 	return len;
+ }
+ 
+ /*
+  * sending SADB_X_SPDDELETE message to the kernel.
+  * OUT:
+  *	positive: success and return length sent.
+  *	-1	: error occurred, and set errno.
+  */
+ int
+ pfkey_send_spddelete2(so, spid)
+ 	int so;
+ 	u_int32_t spid;
+ {
+ 	int len;
+ 
+ 	if ((len = pfkey_send_x5(so, SADB_X_SPDDELETE2, spid)) < 0)
+ 		return -1;
+ 
+ 	return len;
+ }
+ 
+ /*
+  * sending SADB_X_SPDGET message to the kernel.
+  * OUT:
+  *	positive: success and return length sent.
+  *	-1	: error occurred, and set errno.
+  */
+ int
+ pfkey_send_spdget(so, spid)
+ 	int so;
+ 	u_int32_t spid;
+ {
+ 	int len;
+ 
+ 	if ((len = pfkey_send_x5(so, SADB_X_SPDGET, spid)) < 0)
+ 		return -1;
+ 
+ 	return len;
+ }
+ 
+ /*
+  * sending SADB_X_SPDSETIDX message to the kernel.
+  * OUT:
+  *	positive: success and return length sent.
+  *	-1	: error occurred, and set errno.
+  */
+ int
+ pfkey_send_spdsetidx(so, src, prefs, dst, prefd, proto, policy, policylen, seq)
+ 	int so;
+ 	struct sockaddr *src, *dst;
+ 	u_int prefs, prefd, proto;
+ 	caddr_t policy;
+ 	int policylen;
+ 	u_int32_t seq;
+ {
+ 	int len;
+ 
+ 	if (policylen != sizeof(struct sadb_x_policy)) {
+ 		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
+ 		return -1;
+ 	}
+ 
+ 	if ((len = pfkey_send_x4(so, SADB_X_SPDSETIDX,
+ 				src, prefs, dst, prefd, proto,
+ 				0, 0,
+ 				policy, policylen, seq)) < 0)
+ 		return -1;
+ 
+ 	return len;
+ }
+ 
+ /*
+  * sending SADB_SPDFLUSH message to the kernel.
+  * OUT:
+  *	positive: success and return length sent.
+  *	-1	: error occurred, and set errno.
+  */
+ int
+ pfkey_send_spdflush(so)
+ 	int so;
+ {
+ 	int len;
+ 
+ 	if ((len = pfkey_send_x3(so, SADB_X_SPDFLUSH, SADB_SATYPE_UNSPEC)) < 0)
+ 		return -1;
+ 
+ 	return len;
+ }
+ 
+ /*
+  * sending SADB_SPDDUMP message to the kernel.
+  * OUT:
+  *	positive: success and return length sent.
+  *	-1	: error occurred, and set errno.
+  */
+ int
+ pfkey_send_spddump(so)
+ 	int so;
+ {
+ 	int len;
+ 
+ 	if ((len = pfkey_send_x3(so, SADB_X_SPDDUMP, SADB_SATYPE_UNSPEC)) < 0)
+ 		return -1;
+ 
+ 	return len;
+ }
+ 
+ /* sending SADB_ADD or SADB_UPDATE message to the kernel */
+ static int
+ pfkey_send_x1(so, type, satype, mode, src, dst, spi, reqid, wsize,
+ 		keymat, e_type, e_keylen, a_type, a_keylen, flags,
+ 		l_alloc, l_bytes, l_addtime, l_usetime, seq)
+ 	int so;
+ 	u_int type, satype, mode;
+ 	struct sockaddr *src, *dst;
+ 	u_int32_t spi, reqid;
+ 	u_int wsize;
+ 	caddr_t keymat;
+ 	u_int e_type, e_keylen, a_type, a_keylen, flags;
+ 	u_int32_t l_alloc, l_bytes, l_addtime, l_usetime, seq;
+ {
+ 	struct sadb_msg *newmsg;
+ 	int len;
+ 	caddr_t p;
+ 	int plen;
+ 	caddr_t ep;
+ 
+ 	/* validity check */
+ 	if (src == NULL || dst == NULL) {
+ 		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
+ 		return -1;
+ 	}
+ 	if (src->sa_family != dst->sa_family) {
+ 		__ipsec_errcode = EIPSEC_FAMILY_MISMATCH;
+ 		return -1;
+ 	}
+ 	switch (src->sa_family) {
+ 	case AF_INET:
+ 		plen = sizeof(struct in_addr) << 3;
+ 		break;
+ 	case AF_INET6:
+ 		plen = sizeof(struct in6_addr) << 3;
+ 		break;
+ 	default:
+ 		__ipsec_errcode = EIPSEC_INVAL_FAMILY;
+ 		return -1;
+ 	}
+ 
+ 	switch (satype) {
+ 	case SADB_SATYPE_ESP:
+ 		if (e_type == SADB_EALG_NONE) {
+ 			__ipsec_errcode = EIPSEC_NO_ALGS;
+ 			return -1;
+ 		}
+ 		break;
+ 	case SADB_SATYPE_AH:
+ 		if (e_type != SADB_EALG_NONE) {
+ 			__ipsec_errcode = EIPSEC_INVAL_ALGS;
+ 			return -1;
+ 		}
+ 		if (a_type == SADB_AALG_NONE) {
+ 			__ipsec_errcode = EIPSEC_NO_ALGS;
+ 			return -1;
+ 		}
+ 		break;
+ 	case SADB_X_SATYPE_IPCOMP:
+ 		if (e_type == SADB_X_CALG_NONE) {
+ 			__ipsec_errcode = EIPSEC_INVAL_ALGS;
+ 			return -1;
+ 		}
+ 		if (a_type != SADB_AALG_NONE) {
+ 			__ipsec_errcode = EIPSEC_NO_ALGS;
+ 			return -1;
+ 		}
+ 		break;
+ 	default:
+ 		__ipsec_errcode = EIPSEC_INVAL_SATYPE;
+ 		return -1;
+ 	}
+ 
+ 	/* create new sadb_msg to reply. */
+ 	len = sizeof(struct sadb_msg)
+ 		+ sizeof(struct sadb_sa)
+ 		+ sizeof(struct sadb_x_sa2)
+ 		+ sizeof(struct sadb_address)
+ 		+ PFKEY_ALIGN8(sysdep_sa_len(src))
+ 		+ sizeof(struct sadb_address)
+ 		+ PFKEY_ALIGN8(sysdep_sa_len(dst))
+ 		+ sizeof(struct sadb_lifetime)
+ 		+ sizeof(struct sadb_lifetime);
+ 
+ 	if (e_type != SADB_EALG_NONE)
+ 		len += (sizeof(struct sadb_key) + PFKEY_ALIGN8(e_keylen));
+ 	if (a_type != SADB_AALG_NONE)
+ 		len += (sizeof(struct sadb_key) + PFKEY_ALIGN8(a_keylen));
+ 
+ 	if ((newmsg = CALLOC(len, struct sadb_msg *)) == NULL) {
+ 		__ipsec_set_strerror(strerror(errno));
+ 		return -1;
+ 	}
+ 	ep = ((caddr_t)newmsg) + len;
+ 
+ 	p = pfkey_setsadbmsg((caddr_t)newmsg, ep, type, len,
+ 	                     satype, seq, getpid());
+ 	if (!p) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 	p = pfkey_setsadbsa(p, ep, spi, wsize, a_type, e_type, flags);
+ 	if (!p) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 	p = pfkey_setsadbxsa2(p, ep, mode, reqid);
+ 	if (!p) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 	p = pfkey_setsadbaddr(p, ep, SADB_EXT_ADDRESS_SRC, src, plen,
+ 	    IPSEC_ULPROTO_ANY);
+ 	if (!p) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 	p = pfkey_setsadbaddr(p, ep, SADB_EXT_ADDRESS_DST, dst, plen,
+ 	    IPSEC_ULPROTO_ANY);
+ 	if (!p) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 
+ 	if (e_type != SADB_EALG_NONE) {
+ 		p = pfkey_setsadbkey(p, ep, SADB_EXT_KEY_ENCRYPT,
+ 		                   keymat, e_keylen);
+ 		if (!p) {
+ 			free(newmsg);
+ 			return -1;
+ 		}
+ 	}
+ 	if (a_type != SADB_AALG_NONE) {
+ 		p = pfkey_setsadbkey(p, ep, SADB_EXT_KEY_AUTH,
+ 		                   keymat + e_keylen, a_keylen);
+ 		if (!p) {
+ 			free(newmsg);
+ 			return -1;
+ 		}
+ 	}
+ 
+ 	/* set sadb_lifetime for destination */
+ 	p = pfkey_setsadblifetime(p, ep, SADB_EXT_LIFETIME_HARD,
+ 			l_alloc, l_bytes, l_addtime, l_usetime);
+ 	if (!p) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 	p = pfkey_setsadblifetime(p, ep, SADB_EXT_LIFETIME_SOFT,
+ 			l_alloc, l_bytes, l_addtime, l_usetime);
+ 	if (!p || p != ep) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 
+ 	/* send message */
+ 	len = pfkey_send(so, newmsg, len);
+ 	free(newmsg);
+ 
+ 	if (len < 0)
+ 		return -1;
+ 
+ 	__ipsec_errcode = EIPSEC_NO_ERROR;
+ 	return len;
+ }
+ 
+ /* sending SADB_DELETE or SADB_GET message to the kernel */
+ static int
+ pfkey_send_x2(so, type, satype, mode, src, dst, spi)
+ 	int so;
+ 	u_int type, satype, mode;
+ 	struct sockaddr *src, *dst;
+ 	u_int32_t spi;
+ {
+ 	struct sadb_msg *newmsg;
+ 	int len;
+ 	caddr_t p;
+ 	int plen;
+ 	caddr_t ep;
+ 
+ 	/* validity check */
+ 	if (src == NULL || dst == NULL) {
+ 		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
+ 		return -1;
+ 	}
+ 	if (src->sa_family != dst->sa_family) {
+ 		__ipsec_errcode = EIPSEC_FAMILY_MISMATCH;
+ 		return -1;
+ 	}
+ 	switch (src->sa_family) {
+ 	case AF_INET:
+ 		plen = sizeof(struct in_addr) << 3;
+ 		break;
+ 	case AF_INET6:
+ 		plen = sizeof(struct in6_addr) << 3;
+ 		break;
+ 	default:
+ 		__ipsec_errcode = EIPSEC_INVAL_FAMILY;
+ 		return -1;
+ 	}
+ 
+ 	/* create new sadb_msg to reply. */
+ 	len = sizeof(struct sadb_msg)
+ 		+ sizeof(struct sadb_sa)
+ 		+ sizeof(struct sadb_address)
+ 		+ PFKEY_ALIGN8(sysdep_sa_len(src))
+ 		+ sizeof(struct sadb_address)
+ 		+ PFKEY_ALIGN8(sysdep_sa_len(dst));
+ 
+ 	if ((newmsg = CALLOC(len, struct sadb_msg *)) == NULL) {
+ 		__ipsec_set_strerror(strerror(errno));
+ 		return -1;
+ 	}
+ 	ep = ((caddr_t)newmsg) + len;
+ 
+ 	p = pfkey_setsadbmsg((caddr_t)newmsg, ep, type, len, satype, 0,
+ 	    getpid());
+ 	if (!p) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 	p = pfkey_setsadbsa(p, ep, spi, 0, 0, 0, 0);
+ 	if (!p) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 	p = pfkey_setsadbaddr(p, ep, SADB_EXT_ADDRESS_SRC, src, plen,
+ 	    IPSEC_ULPROTO_ANY);
+ 	if (!p) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 	p = pfkey_setsadbaddr(p, ep, SADB_EXT_ADDRESS_DST, dst, plen,
+ 	    IPSEC_ULPROTO_ANY);
+ 	if (!p || p != ep) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 
+ 	/* send message */
+ 	len = pfkey_send(so, newmsg, len);
+ 	free(newmsg);
+ 
+ 	if (len < 0)
+ 		return -1;
+ 
+ 	__ipsec_errcode = EIPSEC_NO_ERROR;
+ 	return len;
+ }
+ 
+ /*
+  * sending SADB_REGISTER, SADB_FLUSH, SADB_DUMP or SADB_X_PROMISC message
+  * to the kernel
+  */
+ static int
+ pfkey_send_x3(so, type, satype)
+ 	int so;
+ 	u_int type, satype;
+ {
+ 	struct sadb_msg *newmsg;
+ 	int len;
+ 	caddr_t p;
+ 	caddr_t ep;
+ 
+ 	/* validity check */
+ 	switch (type) {
+ 	case SADB_X_PROMISC:
+ 		if (satype != 0 && satype != 1) {
+ 			__ipsec_errcode = EIPSEC_INVAL_SATYPE;
+ 			return -1;
+ 		}
+ 		break;
+ 	default:
+ 		switch (satype) {
+ 		case SADB_SATYPE_UNSPEC:
+ 		case SADB_SATYPE_AH:
+ 		case SADB_SATYPE_ESP:
+ 		case SADB_X_SATYPE_IPCOMP:
+ 			break;
+ 		default:
+ 			__ipsec_errcode = EIPSEC_INVAL_SATYPE;
+ 			return -1;
+ 		}
+ 	}
+ 
+ 	/* create new sadb_msg to send. */
+ 	len = sizeof(struct sadb_msg);
+ 
+ 	if ((newmsg = CALLOC(len, struct sadb_msg *)) == NULL) {
+ 		__ipsec_set_strerror(strerror(errno));
+ 		return -1;
+ 	}
+ 	ep = ((caddr_t)newmsg) + len;
+ 
+ 	p = pfkey_setsadbmsg((caddr_t)newmsg, ep, type, len, satype, 0,
+ 	    getpid());
+ 	if (!p || p != ep) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 
+ 	/* send message */
+ 	len = pfkey_send(so, newmsg, len);
+ 	free(newmsg);
+ 
+ 	if (len < 0)
+ 		return -1;
+ 
+ 	__ipsec_errcode = EIPSEC_NO_ERROR;
+ 	return len;
+ }
+ 
+ /* sending SADB_X_SPDADD message to the kernel */
+ static int
+ pfkey_send_x4(so, type, src, prefs, dst, prefd, proto,
+ 		ltime, vtime, policy, policylen, seq)
+ 	int so;
+ 	struct sockaddr *src, *dst;
+ 	u_int type, prefs, prefd, proto;
+ 	u_int64_t ltime, vtime;
+ 	char *policy;
+ 	int policylen;
+ 	u_int32_t seq;
+ {
+ 	struct sadb_msg *newmsg;
+ 	int len;
+ 	caddr_t p;
+ 	int plen;
+ 	caddr_t ep;
+ 
+ 	/* validity check */
+ 	if (src == NULL || dst == NULL) {
+ 		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
+ 		return -1;
+ 	}
+ 	if (src->sa_family != dst->sa_family) {
+ 		__ipsec_errcode = EIPSEC_FAMILY_MISMATCH;
+ 		return -1;
+ 	}
+ 
+ 	switch (src->sa_family) {
+ 	case AF_INET:
+ 		plen = sizeof(struct in_addr) << 3;
+ 		break;
+ 	case AF_INET6:
+ 		plen = sizeof(struct in6_addr) << 3;
+ 		break;
+ 	default:
+ 		__ipsec_errcode = EIPSEC_INVAL_FAMILY;
+ 		return -1;
+ 	}
+ 	if (prefs > plen || prefd > plen) {
+ 		__ipsec_errcode = EIPSEC_INVAL_PREFIXLEN;
+ 		return -1;
+ 	}
+ 
+ 	/* create new sadb_msg to reply. */
+ 	len = sizeof(struct sadb_msg)
+ 		+ sizeof(struct sadb_address)
+ 		+ PFKEY_ALIGN8(sysdep_sa_len(src))
+ 		+ sizeof(struct sadb_address)
+ 		+ PFKEY_ALIGN8(sysdep_sa_len(src))
+ 		+ sizeof(struct sadb_lifetime)
+ 		+ policylen;
+ 
+ 	if ((newmsg = CALLOC(len, struct sadb_msg *)) == NULL) {
+ 		__ipsec_set_strerror(strerror(errno));
+ 		return -1;
+ 	}
+ 	ep = ((caddr_t)newmsg) + len;
+ 
+ 	p = pfkey_setsadbmsg((caddr_t)newmsg, ep, type, len,
+ 	    SADB_SATYPE_UNSPEC, seq, getpid());
+ 	if (!p) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 	p = pfkey_setsadbaddr(p, ep, SADB_EXT_ADDRESS_SRC, src, prefs, proto);
+ 	if (!p) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 	p = pfkey_setsadbaddr(p, ep, SADB_EXT_ADDRESS_DST, dst, prefd, proto);
+ 	if (!p) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 	p = pfkey_setsadblifetime(p, ep, SADB_EXT_LIFETIME_HARD,
+ 			0, 0, ltime, vtime);
+ 	if (!p || p + policylen != ep) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 	memcpy(p, policy, policylen);
+ 
+ 	/* send message */
+ 	len = pfkey_send(so, newmsg, len);
+ 	free(newmsg);
+ 
+ 	if (len < 0)
+ 		return -1;
+ 
+ 	__ipsec_errcode = EIPSEC_NO_ERROR;
+ 	return len;
+ }
+ 
+ /* sending SADB_X_SPDGET or SADB_X_SPDDELETE message to the kernel */
+ static int
+ pfkey_send_x5(so, type, spid)
+ 	int so;
+ 	u_int type;
+ 	u_int32_t spid;
+ {
+ 	struct sadb_msg *newmsg;
+ 	struct sadb_x_policy xpl;
+ 	int len;
+ 	caddr_t p;
+ 	caddr_t ep;
+ 
+ 	/* create new sadb_msg to reply. */
+ 	len = sizeof(struct sadb_msg)
+ 		+ sizeof(xpl);
+ 
+ 	if ((newmsg = CALLOC(len, struct sadb_msg *)) == NULL) {
+ 		__ipsec_set_strerror(strerror(errno));
+ 		return -1;
+ 	}
+ 	ep = ((caddr_t)newmsg) + len;
+ 
+ 	p = pfkey_setsadbmsg((caddr_t)newmsg, ep, type, len,
+ 	    SADB_SATYPE_UNSPEC, 0, getpid());
+ 	if (!p) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 
+ 	if (p + sizeof(xpl) != ep) {
+ 		free(newmsg);
+ 		return -1;
+ 	}
+ 	memset(&xpl, 0, sizeof(xpl));
+ 	xpl.sadb_x_policy_len = PFKEY_UNIT64(sizeof(xpl));
+ 	xpl.sadb_x_policy_exttype = SADB_X_EXT_POLICY;
+ 	xpl.sadb_x_policy_id = spid;
+ 	memcpy(p, &xpl, sizeof(xpl));
+ 
+ 	/* send message */
+ 	len = pfkey_send(so, newmsg, len);
+ 	free(newmsg);
+ 
+ 	if (len < 0)
+ 		return -1;
+ 
+ 	__ipsec_errcode = EIPSEC_NO_ERROR;
+ 	return len;
+ }
+ 
+ /*
+  * open a socket.
+  * OUT:
+  *	-1: fail.
+  *	others : success and return value of socket.
+  */
+ int
+ pfkey_open()
+ {
+ 	int so;
+ 	const int bufsiz = 128 * 1024;	/*is 128K enough?*/
+ 
+ 	if ((so = socket(PF_KEY, SOCK_RAW, PF_KEY_V2)) < 0) {
+ 		__ipsec_set_strerror(strerror(errno));
+ 		return -1;
+ 	}
+ 
+ 	/*
+ 	 * This is a temporary workaround for KAME PR 154.
+ 	 * Don't really care even if it fails.
+ 	 */
+ 	(void)setsockopt(so, SOL_SOCKET, SO_SNDBUF, &bufsiz, sizeof(bufsiz));
+ 	(void)setsockopt(so, SOL_SOCKET, SO_RCVBUF, &bufsiz, sizeof(bufsiz));
+ 
+ 	__ipsec_errcode = EIPSEC_NO_ERROR;
+ 	return so;
+ }
+ 
+ /*
+  * close a socket.
+  * OUT:
+  *	 0: success.
+  *	-1: fail.
+  */
+ void
+ pfkey_close(so)
+ 	int so;
+ {
+ 	(void)close(so);
+ 
+ 	__ipsec_errcode = EIPSEC_NO_ERROR;
+ 	return;
+ }
+ 
+ /*
+  * receive sadb_msg data, and return pointer to new buffer allocated.
+  * Must free this buffer later.
+  * OUT:
+  *	NULL	: error occurred.
+  *	others	: a pointer to sadb_msg structure.
+  *
+  * XXX should be rewritten to pass length explicitly
+  */
+ struct sadb_msg *
+ pfkey_recv(so)
+ 	int so;
+ {
+ 	struct sadb_msg buf, *newmsg;
+ 	int len, reallen;
+ 
+ 	while ((len = recv(so, (caddr_t)&buf, sizeof(buf), MSG_PEEK)) < 0) {
+ 		if (errno == EINTR)
+ 			continue;
+ 		__ipsec_set_strerror(strerror(errno));
+ 		return NULL;
+ 	}
+ 
+ 	if (len < sizeof(buf)) {
+ 		recv(so, (caddr_t)&buf, sizeof(buf), 0);
+ 		__ipsec_errcode = EIPSEC_MAX;
+ 		return NULL;
+ 	}
+ 
+ 	/* read real message */
+ 	reallen = PFKEY_UNUNIT64(buf.sadb_msg_len);
+ 	if ((newmsg = CALLOC(reallen, struct sadb_msg *)) == 0) {
+ 		__ipsec_set_strerror(strerror(errno));
+ 		return NULL;
+ 	}
+ 
+ 	while ((len = recv(so, (caddr_t)newmsg, reallen, 0)) < 0) {
+ 		if (errno == EINTR)
+ 			continue;
+ 		__ipsec_set_strerror(strerror(errno));
+ 		free(newmsg);
+ 		return NULL;
+ 	}
+ 
+ 	if (len != reallen) {
+ 		__ipsec_errcode = EIPSEC_SYSTEM_ERROR;
+ 		free(newmsg);
+ 		return NULL;
+ 	}
+ 
+ 	/* don't trust what the kernel says, validate! */
+ 	if (PFKEY_UNUNIT64(newmsg->sadb_msg_len) != len) {
+ 		__ipsec_errcode = EIPSEC_SYSTEM_ERROR;
+ 		free(newmsg);
+ 		return NULL;
+ 	}
+ 
+ 	__ipsec_errcode = EIPSEC_NO_ERROR;
+ 	return newmsg;
+ }
+ 
+ /*
+  * send message to a socket.
+  * OUT:
+  *	 others: success and return length sent.
+  *	-1     : fail.
+  */
+ int
+ pfkey_send(so, msg, len)
+ 	int so;
+ 	struct sadb_msg *msg;
+ 	int len;
+ {
+ 	if ((len = send(so, (caddr_t)msg, len, 0)) < 0) {
+ 		__ipsec_set_strerror(strerror(errno));
+ 		return -1;
+ 	}
+ 
+ 	__ipsec_errcode = EIPSEC_NO_ERROR;
+ 	return len;
+ }
+ 
+ /*
+  * %%% Utilities
+  * NOTE: These functions are derived from netkey/key.c in KAME.
+  */
+ /*
+  * set the pointer to each header in this message buffer.
+  * IN:	msg: pointer to message buffer.
+  *	mhp: pointer to the buffer initialized like below:
+  *		caddr_t mhp[SADB_EXT_MAX + 1];
+  * OUT:	-1: invalid.
+  *	 0: valid.
+  *
+  * XXX should be rewritten to obtain length explicitly
+  */
+ int
+ pfkey_align(msg, mhp)
+ 	struct sadb_msg *msg;
+ 	caddr_t *mhp;
+ {
+ 	struct sadb_ext *ext;
+ 	int i;
+ 	caddr_t p;
+ 	caddr_t ep;	/* XXX should be passed from upper layer */
+ 
+ 	/* validity check */
+ 	if (msg == NULL || mhp == NULL) {
+ 		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
+ 		return -1;
+ 	}
+ 
+ 	/* initialize */
+ 	for (i = 0; i < SADB_EXT_MAX + 1; i++)
+ 		mhp[i] = NULL;
+ 
+ 	mhp[0] = (caddr_t)msg;
+ 
+ 	/* initialize */
+ 	p = (caddr_t) msg;
+ 	ep = p + PFKEY_UNUNIT64(msg->sadb_msg_len);
+ 
+ 	/* skip base header */
+ 	p += sizeof(struct sadb_msg);
+ 
+ 	while (p < ep) {
+ 		ext = (struct sadb_ext *)p;
+ 		if (ep < p + sizeof(*ext) || PFKEY_EXTLEN(ext) < sizeof(*ext) ||
+ 		    ep < p + PFKEY_EXTLEN(ext)) {
+ 			/* invalid format */
+ 			break;
+ 		}
+ 
+ 		/* duplicate check */
+ 		/* XXX Are there duplication either KEY_AUTH or KEY_ENCRYPT ?*/
+ 		if (mhp[ext->sadb_ext_type] != NULL) {
+ 			__ipsec_errcode = EIPSEC_INVAL_EXTTYPE;
+ 			return -1;
+ 		}
+ 
+ 		/* set pointer */
+ 		switch (ext->sadb_ext_type) {
+ 		case SADB_EXT_SA:
+ 		case SADB_EXT_LIFETIME_CURRENT:
+ 		case SADB_EXT_LIFETIME_HARD:
+ 		case SADB_EXT_LIFETIME_SOFT:
+ 		case SADB_EXT_ADDRESS_SRC:
+ 		case SADB_EXT_ADDRESS_DST:
+ 		case SADB_EXT_ADDRESS_PROXY:
+ 		case SADB_EXT_KEY_AUTH:
+ 			/* XXX should to be check weak keys. */
+ 		case SADB_EXT_KEY_ENCRYPT:
+ 			/* XXX should to be check weak keys. */
+ 		case SADB_EXT_IDENTITY_SRC:
+ 		case SADB_EXT_IDENTITY_DST:
+ 		case SADB_EXT_SENSITIVITY:
+ 		case SADB_EXT_PROPOSAL:
+ 		case SADB_EXT_SUPPORTED_AUTH:
+ 		case SADB_EXT_SUPPORTED_ENCRYPT:
+ 		case SADB_EXT_SPIRANGE:
+ 		case SADB_X_EXT_POLICY:
+ 		case SADB_X_EXT_SA2:
+ 			mhp[ext->sadb_ext_type] = (caddr_t)ext;
+ 			break;
+ 		default:
+ 			__ipsec_errcode = EIPSEC_INVAL_EXTTYPE;
+ 			return -1;
+ 		}
+ 
+ 		p += PFKEY_EXTLEN(ext);
+ 	}
+ 
+ 	if (p != ep) {
+ 		__ipsec_errcode = EIPSEC_INVAL_SADBMSG;
+ 		return -1;
+ 	}
+ 
+ 	__ipsec_errcode = EIPSEC_NO_ERROR;
+ 	return 0;
+ }
+ 
+ /*
+  * check basic usage for sadb_msg,
+  * NOTE: This routine is derived from netkey/key.c in KAME.
+  * IN:	msg: pointer to message buffer.
+  *	mhp: pointer to the buffer initialized like below:
+  *
+  *		caddr_t mhp[SADB_EXT_MAX + 1];
+  *
+  * OUT:	-1: invalid.
+  *	 0: valid.
+  */
+ int
+ pfkey_check(mhp)
+ 	caddr_t *mhp;
+ {
+ 	struct sadb_msg *msg;
+ 
+ 	/* validity check */
+ 	if (mhp == NULL || mhp[0] == NULL) {
+ 		__ipsec_errcode = EIPSEC_INVAL_ARGUMENT;
+ 		return -1;
+ 	}
+ 
+ 	msg = (struct sadb_msg *)mhp[0];
+ 
+ 	/* check version */
+ 	if (msg->sadb_msg_version != PF_KEY_V2) {
+ 		__ipsec_errcode = EIPSEC_INVAL_VERSION;
+ 		return -1;
+ 	}
+ 
+ 	/* check type */
+ 	if (msg->sadb_msg_type > SADB_MAX) {
+ 		__ipsec_errcode = EIPSEC_INVAL_MSGTYPE;
+ 		return -1;
+ 	}
+ 
+ 	/* check SA type */
+ 	switch (msg->sadb_msg_satype) {
+ 	case SADB_SATYPE_UNSPEC:
+ 		switch (msg->sadb_msg_type) {
+ 		case SADB_GETSPI:
+ 		case SADB_UPDATE:
+ 		case SADB_ADD:
+ 		case SADB_DELETE:
+ 		case SADB_GET:
+ 		case SADB_ACQUIRE:
+ 		case SADB_EXPIRE:
+ 			__ipsec_errcode = EIPSEC_INVAL_SATYPE;
+ 			return -1;
+ 		}
+ 		break;
+ 	case SADB_SATYPE_ESP:
+ 	case SADB_SATYPE_AH:
+ 	case SADB_X_SATYPE_IPCOMP:
+ 		switch (msg->sadb_msg_type) {
+ 		case SADB_X_SPDADD:
+ 		case SADB_X_SPDDELETE:
+ 		case SADB_X_SPDGET:
+ 		case SADB_X_SPDDUMP:
+ 		case SADB_X_SPDFLUSH:
+ 			__ipsec_errcode = EIPSEC_INVAL_SATYPE;
+ 			return -1;
+ 		}
+ 		break;
+ 	case SADB_SATYPE_RSVP:
+ 	case SADB_SATYPE_OSPFV2:
+ 	case SADB_SATYPE_RIPV2:
+ 	case SADB_SATYPE_MIP:
+ 		__ipsec_errcode = EIPSEC_NOT_SUPPORTED;
+ 		return -1;
+ 	case 1:	/* XXX: What does it do ? */
+ 		if (msg->sadb_msg_type == SADB_X_PROMISC)
+ 			break;
+ 		/*FALLTHROUGH*/
+ 	default:
+ 		__ipsec_errcode = EIPSEC_INVAL_SATYPE;
+ 		return -1;
+ 	}
+ 
+ 	/* check field of upper layer protocol and address family */
+ 	if (mhp[SADB_EXT_ADDRESS_SRC] != NULL
+ 	 && mhp[SADB_EXT_ADDRESS_DST] != NULL) {
+ 		struct sadb_address *src0, *dst0;
+ 
+ 		src0 = (struct sadb_address *)(mhp[SADB_EXT_ADDRESS_SRC]);
+ 		dst0 = (struct sadb_address *)(mhp[SADB_EXT_ADDRESS_DST]);
+ 
+ 		if (src0->sadb_address_proto != dst0->sadb_address_proto) {
+ 			__ipsec_errcode = EIPSEC_PROTO_MISMATCH;
+ 			return -1;
+ 		}
+ 
+ 		if (PFKEY_ADDR_SADDR(src0)->sa_family
+ 		 != PFKEY_ADDR_SADDR(dst0)->sa_family) {
+ 			__ipsec_errcode = EIPSEC_FAMILY_MISMATCH;
+ 			return -1;
+ 		}
+ 
+ 		switch (PFKEY_ADDR_SADDR(src0)->sa_family) {
+ 		case AF_INET:
+ 		case AF_INET6:
+ 			break;
+ 		default:
+ 			__ipsec_errcode = EIPSEC_INVAL_FAMILY;
+ 			return -1;
+ 		}
+ 
+ 		/*
+ 		 * prefixlen == 0 is valid because there must be the case
+ 		 * all addresses are matched.
+ 		 */
+ 	}
+ 
+ 	__ipsec_errcode = EIPSEC_NO_ERROR;
+ 	return 0;
+ }
+ 
+ /*
+  * set data into sadb_msg.
+  * `buf' must has been allocated sufficiently.
+  */
+ static caddr_t
+ pfkey_setsadbmsg(buf, lim, type, tlen, satype, seq, pid)
+ 	caddr_t buf;
+ 	caddr_t lim;
+ 	u_int type, satype;
+ 	u_int tlen;
+ 	u_int32_t seq;
+ 	pid_t pid;
+ {
+ 	struct sadb_msg *p;
+ 	u_int len;
+ 
+ 	p = (struct sadb_msg *)buf;
+ 	len = sizeof(struct sadb_msg);
+ 
+ 	if (buf + len > lim)
+ 		return NULL;
+ 
+ 	memset(p, 0, len);
+ 	p->sadb_msg_version = PF_KEY_V2;
+ 	p->sadb_msg_type = type;
+ 	p->sadb_msg_errno = 0;
+ 	p->sadb_msg_satype = satype;
+ 	p->sadb_msg_len = PFKEY_UNIT64(tlen);
+ 	p->sadb_msg_reserved = 0;
+ 	p->sadb_msg_seq = seq;
+ 	p->sadb_msg_pid = (u_int32_t)pid;
+ 
+ 	return(buf + len);
+ }
+ 
+ /*
+  * copy secasvar data into sadb_address.
+  * `buf' must has been allocated sufficiently.
+  */
+ static caddr_t
+ pfkey_setsadbsa(buf, lim, spi, wsize, auth, enc, flags)
+ 	caddr_t buf;
+ 	caddr_t lim;
+ 	u_int32_t spi, flags;
+ 	u_int wsize, auth, enc;
+ {
+ 	struct sadb_sa *p;
+ 	u_int len;
+ 
+ 	p = (struct sadb_sa *)buf;
+ 	len = sizeof(struct sadb_sa);
+ 
+ 	if (buf + len > lim)
+ 		return NULL;
+ 
+ 	memset(p, 0, len);
+ 	p->sadb_sa_len = PFKEY_UNIT64(len);
+ 	p->sadb_sa_exttype = SADB_EXT_SA;
+ 	p->sadb_sa_spi = spi;
+ 	p->sadb_sa_replay = wsize;
+ 	p->sadb_sa_state = SADB_SASTATE_LARVAL;
+ 	p->sadb_sa_auth = auth;
+ 	p->sadb_sa_encrypt = enc;
+ 	p->sadb_sa_flags = flags;
+ 
+ 	return(buf + len);
+ }
+ 
+ /*
+  * set data into sadb_address.
+  * `buf' must has been allocated sufficiently.
+  * prefixlen is in bits.
+  */
+ static caddr_t
+ pfkey_setsadbaddr(buf, lim, exttype, saddr, prefixlen, ul_proto)
+ 	caddr_t buf;
+ 	caddr_t lim;
+ 	u_int exttype;
+ 	struct sockaddr *saddr;
+ 	u_int prefixlen;
+ 	u_int ul_proto;
+ {
+ 	struct sadb_address *p;
+ 	u_int len;
+ 
+ 	p = (struct sadb_address *)buf;
+ 	len = sizeof(struct sadb_address) + PFKEY_ALIGN8(sysdep_sa_len(saddr));
+ 
+ 	if (buf + len > lim)
+ 		return NULL;
+ 
+ 	memset(p, 0, len);
+ 	p->sadb_address_len = PFKEY_UNIT64(len);
+ 	p->sadb_address_exttype = exttype & 0xffff;
+ 	p->sadb_address_proto = ul_proto & 0xff;
+ 	p->sadb_address_prefixlen = prefixlen;
+ 	p->sadb_address_reserved = 0;
+ 
+ 	memcpy(p + 1, saddr, sysdep_sa_len(saddr));
+ 
+ 	return(buf + len);
+ }
+ 
+ /*
+  * set sadb_key structure after clearing buffer with zero.
+  * OUT: the pointer of buf + len.
+  */
+ static caddr_t
+ pfkey_setsadbkey(buf, lim, type, key, keylen)
+ 	caddr_t buf;
+ 	caddr_t lim;
+ 	caddr_t key;
+ 	u_int type, keylen;
+ {
+ 	struct sadb_key *p;
+ 	u_int len;
+ 
+ 	p = (struct sadb_key *)buf;
+ 	len = sizeof(struct sadb_key) + PFKEY_ALIGN8(keylen);
+ 
+ 	if (buf + len > lim)
+ 		return NULL;
+ 
+ 	memset(p, 0, len);
+ 	p->sadb_key_len = PFKEY_UNIT64(len);
+ 	p->sadb_key_exttype = type;
+ 	p->sadb_key_bits = keylen << 3;
+ 	p->sadb_key_reserved = 0;
+ 
+ 	memcpy(p + 1, key, keylen);
+ 
+ 	return buf + len;
+ }
+ 
+ /*
+  * set sadb_lifetime structure after clearing buffer with zero.
+  * OUT: the pointer of buf + len.
+  */
+ static caddr_t
+ pfkey_setsadblifetime(buf, lim, type, l_alloc, l_bytes, l_addtime, l_usetime)
+ 	caddr_t buf;
+ 	caddr_t lim;
+ 	u_int type;
+ 	u_int32_t l_alloc, l_bytes, l_addtime, l_usetime;
+ {
+ 	struct sadb_lifetime *p;
+ 	u_int len;
+ 
+ 	p = (struct sadb_lifetime *)buf;
+ 	len = sizeof(struct sadb_lifetime);
+ 
+ 	if (buf + len > lim)
+ 		return NULL;
+ 
+ 	memset(p, 0, len);
+ 	p->sadb_lifetime_len = PFKEY_UNIT64(len);
+ 	p->sadb_lifetime_exttype = type;
+ 
+ 	switch (type) {
+ 	case SADB_EXT_LIFETIME_SOFT:
+ 		p->sadb_lifetime_allocations
+ 			= (l_alloc * soft_lifetime_allocations_rate) /100;
+ 		p->sadb_lifetime_bytes
+ 			= (l_bytes * soft_lifetime_bytes_rate) /100;
+ 		p->sadb_lifetime_addtime
+ 			= (l_addtime * soft_lifetime_addtime_rate) /100;
+ 		p->sadb_lifetime_usetime
+ 			= (l_usetime * soft_lifetime_usetime_rate) /100;
+ 		break;
+ 	case SADB_EXT_LIFETIME_HARD:
+ 		p->sadb_lifetime_allocations = l_alloc;
+ 		p->sadb_lifetime_bytes = l_bytes;
+ 		p->sadb_lifetime_addtime = l_addtime;
+ 		p->sadb_lifetime_usetime = l_usetime;
+ 		break;
+ 	}
+ 
+ 	return buf + len;
+ }
+ 
+ /*
+  * copy secasvar data into sadb_address.
+  * `buf' must has been allocated sufficiently.
+  */
+ static caddr_t
+ pfkey_setsadbxsa2(buf, lim, mode0, reqid)
+ 	caddr_t buf;
+ 	caddr_t lim;
+ 	u_int32_t mode0;
+ 	u_int32_t reqid;
+ {
+ 	struct sadb_x_sa2 *p;
+ 	u_int8_t mode = mode0 & 0xff;
+ 	u_int len;
+ 
+ 	p = (struct sadb_x_sa2 *)buf;
+ 	len = sizeof(struct sadb_x_sa2);
+ 
+ 	if (buf + len > lim)
+ 		return NULL;
+ 
+ 	memset(p, 0, len);
+ 	p->sadb_x_sa2_len = PFKEY_UNIT64(len);
+ 	p->sadb_x_sa2_exttype = SADB_X_EXT_SA2;
+ 	p->sadb_x_sa2_mode = mode;
+ 	p->sadb_x_sa2_reqid = reqid;
+ 
+ 	return(buf + len);
+ }
diff -Nr -c25 ac_am/src/libipsec/pfkey.c.rej ac_am_fixed/src/libipsec/pfkey.c.rej
*** ac_am/src/libipsec/pfkey.c.rej	1970-01-01 01:00:00.000000000 +0100
--- ac_am_fixed/src/libipsec/pfkey.c.rej	2003-12-11 18:19:59.124059896 +0100
***************
*** 0 ****
--- 1,18 ----
+ ***************
+ *** 1765,1770 ****
+   		case SADB_X_EXT_NAT_T_SPORT:
+   		case SADB_X_EXT_NAT_T_DPORT:
+   		case SADB_X_EXT_NAT_T_OA:
+   #endif
+   			mhp[ext->sadb_ext_type] = (caddr_t)ext;
+   			break;
+ --- 1768,1776 ----
+   		case SADB_X_EXT_NAT_T_SPORT:
+   		case SADB_X_EXT_NAT_T_DPORT:
+   		case SADB_X_EXT_NAT_T_OA:
+ + #endif
+ + #ifdef SADB_X_EXT_TAG
+ + 		case SADB_X_EXT_TAG:
+   #endif
+   			mhp[ext->sadb_ext_type] = (caddr_t)ext;
+   			break;
diff -Nr -c25 ac_am/src/libipsec/pfkey_dump.c ac_am_fixed/src/libipsec/pfkey_dump.c
*** ac_am/src/libipsec/pfkey_dump.c	2003-03-04 00:56:55.000000000 +0100
--- ac_am_fixed/src/libipsec/pfkey_dump.c	2003-12-11 18:19:59.128059288 +0100
***************
*** 129,197 ****
--- 129,206 ----
  };
  
  static char *str_state[] = {
  	"larval",
  	"mature",
  	"dying",
  	"dead",
  };
  
  static struct val2str str_alg_auth[] = {
  	{ SADB_AALG_NONE, "none", },
  	{ SADB_AALG_MD5HMAC, "hmac-md5", },
  	{ SADB_AALG_SHA1HMAC, "hmac-sha1", },
  	{ SADB_X_AALG_MD5, "md5", },
  	{ SADB_X_AALG_SHA, "sha", },
  	{ SADB_X_AALG_NULL, "null", },
  #ifdef SADB_X_AALG_SHA2_256
  	{ SADB_X_AALG_SHA2_256, "hmac-sha2-256", },
  #endif
  #ifdef SADB_X_AALG_SHA2_384
  	{ SADB_X_AALG_SHA2_384, "hmac-sha2-384", },
  #endif
  #ifdef SADB_X_AALG_SHA2_512
  	{ SADB_X_AALG_SHA2_512, "hmac-sha2-512", },
  #endif
+ #ifdef SADB_X_AALG_RIPEMD160HMAC
+ 	{ SADB_X_AALG_RIPEMD160HMAC, "hmac-ripemd160", },
+ #endif
+ #ifdef SADB_X_AALG_AES_XCBC_MAC
+ 	{ SADB_X_AALG_AES_XCBC_MAC, "aes-xcbc-mac", },
+ #endif
  	{ -1, NULL, },
  };
  
  static struct val2str str_alg_enc[] = {
  	{ SADB_EALG_NONE, "none", },
  	{ SADB_EALG_DESCBC, "des-cbc", },
  	{ SADB_EALG_3DESCBC, "3des-cbc", },
  	{ SADB_EALG_NULL, "null", },
  #ifdef SADB_X_EALG_RC5CBC
  	{ SADB_X_EALG_RC5CBC, "rc5-cbc", },
  #endif
  	{ SADB_X_EALG_CAST128CBC, "cast128-cbc", },
  	{ SADB_X_EALG_BLOWFISHCBC, "blowfish-cbc", },
  #ifdef SADB_X_EALG_RIJNDAELCBC
  	{ SADB_X_EALG_RIJNDAELCBC, "rijndael-cbc", },
  #endif
  #ifdef SADB_X_EALG_TWOFISHCBC
  	{ SADB_X_EALG_TWOFISHCBC, "twofish-cbc", },
  #endif
+ #ifdef SADB_X_EALG_AESCTR
+ 	{ SADB_X_EALG_AESCTR, "aes-ctr", },
+ #endif
  	{ -1, NULL, },
  };
  
  static struct val2str str_alg_comp[] = {
  	{ SADB_X_CALG_NONE, "none", },
  	{ SADB_X_CALG_OUI, "oui", },
  	{ SADB_X_CALG_DEFLATE, "deflate", },
  	{ SADB_X_CALG_LZS, "lzs", },
  	{ -1, NULL, },
  };
  
  /*
   * dump SADB_MSG formated.  For debugging, you should use kdebug_sadb().
   */
  void
  pfkey_sadump(m)
  	struct sadb_msg *m;
  {
  	caddr_t mhp[SADB_EXT_MAX + 1];
  	struct sadb_sa *m_sa;
  	struct sadb_x_sa2 *m_sa2;
  	struct sadb_lifetime *m_lftc, *m_lfth, *m_lfts;
  	struct sadb_address *m_saddr, *m_daddr, *m_paddr;
  	struct sadb_key *m_auth, *m_enc;
  	struct sadb_ident *m_sid, *m_did;
***************
*** 328,453 ****
  		printf("\thard: %lu",
  			(u_long)(m_lfth == NULL ?
  			0 : m_lfth->sadb_lifetime_allocations));
  		printf("\tsoft: %lu\n",
  			(u_long)(m_lfts == NULL ?
  			0 : m_lfts->sadb_lifetime_allocations));
  	}
  
  	printf("\tsadb_seq=%lu pid=%lu ",
  		(u_long)m->sadb_msg_seq,
  		(u_long)m->sadb_msg_pid);
  
  	/* XXX DEBUG */
  	printf("refcnt=%u\n", m->sadb_msg_reserved);
  
  	return;
  }
  
  void
  pfkey_spdump(m)
  	struct sadb_msg *m;
  {
  	char pbuf[NI_MAXSERV];
  	caddr_t mhp[SADB_EXT_MAX + 1];
  	struct sadb_address *m_saddr, *m_daddr;
  	struct sadb_x_policy *m_xpl;
  	struct sadb_lifetime *m_lftc = NULL, *m_lfth = NULL;
  	struct sockaddr *sa;
  	u_int16_t sport = 0, dport = 0;
  
  	/* check pfkey message. */
  	if (pfkey_align(m, mhp)) {
  		printf("%s\n", ipsec_strerror());
  		return;
  	}
  	if (pfkey_check(mhp)) {
  		printf("%s\n", ipsec_strerror());
  		return;
  	}
  
  	m_saddr = (struct sadb_address *)mhp[SADB_EXT_ADDRESS_SRC];
  	m_daddr = (struct sadb_address *)mhp[SADB_EXT_ADDRESS_DST];
  	m_xpl = (struct sadb_x_policy *)mhp[SADB_X_EXT_POLICY];
  	m_lftc = (struct sadb_lifetime *)mhp[SADB_EXT_LIFETIME_CURRENT];
  	m_lfth = (struct sadb_lifetime *)mhp[SADB_EXT_LIFETIME_HARD];
  
! 	/* source address */
! 	if (m_saddr == NULL) {
! 		printf("no ADDRESS_SRC extension.\n");
! 		return;
! 	}
! 	sa = (struct sockaddr *)(m_saddr + 1);
! 	switch (sa->sa_family) {
! 	case AF_INET:
! 	case AF_INET6:
! 		if (getnameinfo(sa, sysdep_sa_len(sa), NULL, 0, pbuf, sizeof(pbuf),
! 		    NI_NUMERICSERV) != 0)
! 			sport = 0;	/*XXX*/
! 		else
! 			sport = atoi(pbuf);
! 		printf("%s%s ", str_ipaddr(sa),
! 			str_prefport(sa->sa_family,
! 			    m_saddr->sadb_address_prefixlen, sport,
! 			    m_saddr->sadb_address_proto));
! 		break;
! 	default:
! 		printf("unknown-af ");
! 		break;
! 	}
  
! 	/* destination address */
! 	if (m_daddr == NULL) {
! 		printf("no ADDRESS_DST extension.\n");
! 		return;
! 	}
! 	sa = (struct sockaddr *)(m_daddr + 1);
! 	switch (sa->sa_family) {
! 	case AF_INET:
! 	case AF_INET6:
! 		if (getnameinfo(sa, sysdep_sa_len(sa), NULL, 0, pbuf, sizeof(pbuf),
! 		    NI_NUMERICSERV) != 0)
! 			dport = 0;	/*XXX*/
! 		else
! 			dport = atoi(pbuf);
! 		printf("%s%s ", str_ipaddr(sa),
! 			str_prefport(sa->sa_family,
! 			    m_daddr->sadb_address_prefixlen, dport,
! 			    m_saddr->sadb_address_proto));
! 		break;
! 	default:
! 		printf("unknown-af ");
! 		break;
! 	}
  
! 	/* upper layer protocol */
! 	if (m_saddr->sadb_address_proto != m_daddr->sadb_address_proto) {
! 		printf("upper layer protocol mismatched.\n");
! 		return;
! 	}
! 	str_upperspec(m_saddr->sadb_address_proto, sport, dport);
  
  	/* policy */
      {
  	char *d_xpl;
  
  	if (m_xpl == NULL) {
  		printf("no X_POLICY extension.\n");
  		return;
  	}
  	d_xpl = ipsec_dump_policy((char *)m_xpl, "\n\t");
  	if (!d_xpl)
  		printf("\n\tPolicy:[%s]\n", ipsec_strerror());
  	else {
  		/* dump SPD */
  		printf("\n\t%s\n", d_xpl);
  		free(d_xpl);
  	}
      }
  
  	/* lifetime */
  	if (m_lftc) {
  		printf("\tcreated: %s  ",
  			str_time(m_lftc->sadb_lifetime_addtime));
  		printf("lastused: %s\n",
  			str_time(m_lftc->sadb_lifetime_usetime));
  	}
--- 337,468 ----
  		printf("\thard: %lu",
  			(u_long)(m_lfth == NULL ?
  			0 : m_lfth->sadb_lifetime_allocations));
  		printf("\tsoft: %lu\n",
  			(u_long)(m_lfts == NULL ?
  			0 : m_lfts->sadb_lifetime_allocations));
  	}
  
  	printf("\tsadb_seq=%lu pid=%lu ",
  		(u_long)m->sadb_msg_seq,
  		(u_long)m->sadb_msg_pid);
  
  	/* XXX DEBUG */
  	printf("refcnt=%u\n", m->sadb_msg_reserved);
  
  	return;
  }
  
  void
  pfkey_spdump(m)
  	struct sadb_msg *m;
  {
  	char pbuf[NI_MAXSERV];
  	caddr_t mhp[SADB_EXT_MAX + 1];
  	struct sadb_address *m_saddr, *m_daddr;
+ #ifdef SADB_X_EXT_TAG
+ 	struct sadb_x_tag *m_tag;
+ #endif
  	struct sadb_x_policy *m_xpl;
  	struct sadb_lifetime *m_lftc = NULL, *m_lfth = NULL;
  	struct sockaddr *sa;
  	u_int16_t sport = 0, dport = 0;
  
  	/* check pfkey message. */
  	if (pfkey_align(m, mhp)) {
  		printf("%s\n", ipsec_strerror());
  		return;
  	}
  	if (pfkey_check(mhp)) {
  		printf("%s\n", ipsec_strerror());
  		return;
  	}
  
  	m_saddr = (struct sadb_address *)mhp[SADB_EXT_ADDRESS_SRC];
  	m_daddr = (struct sadb_address *)mhp[SADB_EXT_ADDRESS_DST];
+ #ifdef SADB_X_EXT_TAG
+ 	m_tag = (struct sadb_x_tag *)mhp[SADB_X_EXT_TAG];
+ #endif
  	m_xpl = (struct sadb_x_policy *)mhp[SADB_X_EXT_POLICY];
  	m_lftc = (struct sadb_lifetime *)mhp[SADB_EXT_LIFETIME_CURRENT];
  	m_lfth = (struct sadb_lifetime *)mhp[SADB_EXT_LIFETIME_HARD];
  
! 	if (m_saddr && m_daddr) {
! 		/* source address */
! 		sa = (struct sockaddr *)(m_saddr + 1);
! 		switch (sa->sa_family) {
! 		case AF_INET:
! 		case AF_INET6:
! 			if (getnameinfo(sa, sysdep_sa_len(sa), NULL, 0, pbuf, sizeof(pbuf),
! 			    NI_NUMERICSERV) != 0)
! 				sport = 0;	/*XXX*/
! 			else
! 				sport = atoi(pbuf);
! 			printf("%s%s ", str_ipaddr(sa),
! 				str_prefport(sa->sa_family,
! 				    m_saddr->sadb_address_prefixlen, sport,
! 				    m_saddr->sadb_address_proto));
! 			break;
! 		default:
! 			printf("unknown-af ");
! 			break;
! 		}
  
! 		/* destination address */
! 		sa = (struct sockaddr *)(m_daddr + 1);
! 		switch (sa->sa_family) {
! 		case AF_INET:
! 		case AF_INET6:
! 			if (getnameinfo(sa, sysdep_sa_len(sa), NULL, 0, pbuf, sizeof(pbuf),
! 			    NI_NUMERICSERV) != 0)
! 				dport = 0;	/*XXX*/
! 			else
! 				dport = atoi(pbuf);
! 			printf("%s%s ", str_ipaddr(sa),
! 				str_prefport(sa->sa_family,
! 				    m_daddr->sadb_address_prefixlen, dport,
! 				    m_saddr->sadb_address_proto));
! 			break;
! 		default:
! 			printf("unknown-af ");
! 			break;
! 		}
  
! 		/* upper layer protocol */
! 		if (m_saddr->sadb_address_proto != m_daddr->sadb_address_proto) {
! 			printf("upper layer protocol mismatched.\n");
! 			return;
! 		}
! 		str_upperspec(m_saddr->sadb_address_proto, sport, dport);
  
+ 	}
+ #ifdef SADB_X_EXT_TAG
+ 	else if (m_tag)
+ 		printf("tagged \"%s\" ", m_tag->sadb_x_tag_name);
+ #endif
+ 	else
+ 		printf("(no selector, probably per-socket policy) ");
  	/* policy */
      {
  	char *d_xpl;
  
  	if (m_xpl == NULL) {
  		printf("no X_POLICY extension.\n");
  		return;
  	}
  	d_xpl = ipsec_dump_policy((char *)m_xpl, "\n\t");
  	if (!d_xpl)
  		printf("\n\tPolicy:[%s]\n", ipsec_strerror());
  	else {
  		/* dump SPD */
  		printf("\n\t%s\n", d_xpl);
  		free(d_xpl);
  	}
      }
  
  	/* lifetime */
  	if (m_lftc) {
  		printf("\tcreated: %s  ",
  			str_time(m_lftc->sadb_lifetime_addtime));
  		printf("lastused: %s\n",
  			str_time(m_lftc->sadb_lifetime_usetime));
  	}
***************
*** 474,525 ****
   * set "ipaddress" to buffer.
   */
  static char *
  str_ipaddr(sa)
  	struct sockaddr *sa;
  {
  	static char buf[NI_MAXHOST];
  	const int niflag = NI_NUMERICHOST;
  
  	if (sa == NULL)
  		return "";
  
  	if (getnameinfo(sa, sysdep_sa_len(sa), buf, sizeof(buf), NULL, 0, niflag) == 0)
  		return buf;
  	return NULL;
  }
  
  /*
   * set "/prefix[port number]" to buffer.
   */
  static char *
  str_prefport(family, pref, port, ulp)
  	u_int family, pref, port, ulp;
  {
  	static char buf[128];
! 	char prefbuf[10];
! 	char portbuf[10];
  	int plen;
  
  	switch (family) {
  	case AF_INET:
  		plen = sizeof(struct in_addr) << 3;
  		break;
  	case AF_INET6:
  		plen = sizeof(struct in6_addr) << 3;
  		break;
  	default:
  		return "?";
  	}
  
  	if (pref == plen)
  		prefbuf[0] = '\0';
  	else
  		snprintf(prefbuf, sizeof(prefbuf), "/%u", pref);
  
  	if (ulp == IPPROTO_ICMPV6)
  		memset(portbuf, 0, sizeof(portbuf));
  	else {
  		if (port == IPSEC_PORT_ANY)
  			snprintf(portbuf, sizeof(portbuf), "[%s]", "any");
  		else
  			snprintf(portbuf, sizeof(portbuf), "[%u]", port);
--- 489,540 ----
   * set "ipaddress" to buffer.
   */
  static char *
  str_ipaddr(sa)
  	struct sockaddr *sa;
  {
  	static char buf[NI_MAXHOST];
  	const int niflag = NI_NUMERICHOST;
  
  	if (sa == NULL)
  		return "";
  
  	if (getnameinfo(sa, sysdep_sa_len(sa), buf, sizeof(buf), NULL, 0, niflag) == 0)
  		return buf;
  	return NULL;
  }
  
  /*
   * set "/prefix[port number]" to buffer.
   */
  static char *
  str_prefport(family, pref, port, ulp)
  	u_int family, pref, port, ulp;
  {
  	static char buf[128];
! 	char prefbuf[128];
! 	char portbuf[128];
  	int plen;
  
  	switch (family) {
  	case AF_INET:
  		plen = sizeof(struct in_addr) << 3;
  		break;
  	case AF_INET6:
  		plen = sizeof(struct in6_addr) << 3;
  		break;
  	default:
  		return "?";
  	}
  
  	if (pref == plen)
  		prefbuf[0] = '\0';
  	else
  		snprintf(prefbuf, sizeof(prefbuf), "/%u", pref);
  
  	if (ulp == IPPROTO_ICMPV6)
  		memset(portbuf, 0, sizeof(portbuf));
  	else {
  		if (port == IPSEC_PORT_ANY)
  			snprintf(portbuf, sizeof(portbuf), "[%s]", "any");
  		else
  			snprintf(portbuf, sizeof(portbuf), "[%u]", port);
diff -Nr -c25 ac_am/src/libipsec/pfkey_dump.c.orig ac_am_fixed/src/libipsec/pfkey_dump.c.orig
*** ac_am/src/libipsec/pfkey_dump.c.orig	1970-01-01 01:00:00.000000000 +0100
--- ac_am_fixed/src/libipsec/pfkey_dump.c.orig	2003-12-11 18:19:59.133058528 +0100
***************
*** 0 ****
--- 1,620 ----
+ /*	$KAME: pfkey_dump.c,v 1.38 2002/06/27 14:35:12 itojun Exp $	*/
+ 
+ /*
+  * Copyright (C) 1995, 1996, 1997, 1998, and 1999 WIDE Project.
+  * All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions
+  * are met:
+  * 1. Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  * 2. Redistributions in binary form must reproduce the above copyright
+  *    notice, this list of conditions and the following disclaimer in the
+  *    documentation and/or other materials provided with the distribution.
+  * 3. Neither the name of the project nor the names of its contributors
+  *    may be used to endorse or promote products derived from this software
+  *    without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+  * SUCH DAMAGE.
+  */
+ 
+ #include <sys/types.h>
+ #include <sys/param.h>
+ #include <sys/socket.h>
+ #include <netinet/ipsec.h>
+ #include <net/pfkeyv2.h>
+ 
+ #include <netinet/in.h>
+ #include <arpa/inet.h>
+ 
+ #include <stdlib.h>
+ #include <unistd.h>
+ #include <stdio.h>
+ #include <string.h>
+ #include <time.h>
+ #include <netdb.h>
+ 
+ #include "ipsec_strerror.h"
+ #include "libpfkey.h"
+ 
+ /* cope with old kame headers - ugly */
+ #ifndef SADB_X_AALG_MD5
+ #define SADB_X_AALG_MD5		SADB_AALG_MD5	
+ #endif
+ #ifndef SADB_X_AALG_SHA
+ #define SADB_X_AALG_SHA		SADB_AALG_SHA
+ #endif
+ #ifndef SADB_X_AALG_NULL
+ #define SADB_X_AALG_NULL	SADB_AALG_NULL
+ #endif
+ 
+ #ifndef SADB_X_EALG_BLOWFISHCBC
+ #define SADB_X_EALG_BLOWFISHCBC	SADB_EALG_BLOWFISHCBC
+ #endif
+ #ifndef SADB_X_EALG_CAST128CBC
+ #define SADB_X_EALG_CAST128CBC	SADB_EALG_CAST128CBC
+ #endif
+ #ifndef SADB_X_EALG_RC5CBC
+ #ifdef SADB_EALG_RC5CBC
+ #define SADB_X_EALG_RC5CBC	SADB_EALG_RC5CBC
+ #endif
+ #endif
+ 
+ #define GETMSGSTR(str, num) \
+ do { \
+ 	if (sizeof((str)[0]) == 0 \
+ 	 || num >= sizeof(str)/sizeof((str)[0])) \
+ 		printf("%u ", (num)); \
+ 	else if (strlen((str)[(num)]) == 0) \
+ 		printf("%u ", (num)); \
+ 	else \
+ 		printf("%s ", (str)[(num)]); \
+ } while (0)
+ 
+ #define GETMSGV2S(v2s, num) \
+ do { \
+ 	struct val2str *p;  \
+ 	for (p = (v2s); p && p->str; p++) { \
+ 		if (p->val == (num)) \
+ 			break; \
+ 	} \
+ 	if (p && p->str) \
+ 		printf("%s ", p->str); \
+ 	else \
+ 		printf("%u ", (num)); \
+ } while (0)
+ 
+ static char *str_ipaddr __P((struct sockaddr *));
+ static char *str_prefport __P((u_int, u_int, u_int, u_int));
+ static void str_upperspec __P((u_int, u_int, u_int));
+ static char *str_time __P((time_t));
+ static void str_lifetime_byte __P((struct sadb_lifetime *, char *));
+ 
+ struct val2str {
+ 	int val;
+ 	const char *str;
+ };
+ 
+ /*
+  * Must to be re-written about following strings.
+  */
+ static char *str_satype[] = {
+ 	"unspec",
+ 	"unknown",
+ 	"ah",
+ 	"esp",
+ 	"unknown",
+ 	"rsvp",
+ 	"ospfv2",
+ 	"ripv2",
+ 	"mip",
+ 	"ipcomp",
+ };
+ 
+ static char *str_mode[] = {
+ 	"any",
+ 	"transport",
+ 	"tunnel",
+ };
+ 
+ static char *str_state[] = {
+ 	"larval",
+ 	"mature",
+ 	"dying",
+ 	"dead",
+ };
+ 
+ static struct val2str str_alg_auth[] = {
+ 	{ SADB_AALG_NONE, "none", },
+ 	{ SADB_AALG_MD5HMAC, "hmac-md5", },
+ 	{ SADB_AALG_SHA1HMAC, "hmac-sha1", },
+ 	{ SADB_X_AALG_MD5, "md5", },
+ 	{ SADB_X_AALG_SHA, "sha", },
+ 	{ SADB_X_AALG_NULL, "null", },
+ #ifdef SADB_X_AALG_SHA2_256
+ 	{ SADB_X_AALG_SHA2_256, "hmac-sha2-256", },
+ #endif
+ #ifdef SADB_X_AALG_SHA2_384
+ 	{ SADB_X_AALG_SHA2_384, "hmac-sha2-384", },
+ #endif
+ #ifdef SADB_X_AALG_SHA2_512
+ 	{ SADB_X_AALG_SHA2_512, "hmac-sha2-512", },
+ #endif
+ 	{ -1, NULL, },
+ };
+ 
+ static struct val2str str_alg_enc[] = {
+ 	{ SADB_EALG_NONE, "none", },
+ 	{ SADB_EALG_DESCBC, "des-cbc", },
+ 	{ SADB_EALG_3DESCBC, "3des-cbc", },
+ 	{ SADB_EALG_NULL, "null", },
+ #ifdef SADB_X_EALG_RC5CBC
+ 	{ SADB_X_EALG_RC5CBC, "rc5-cbc", },
+ #endif
+ 	{ SADB_X_EALG_CAST128CBC, "cast128-cbc", },
+ 	{ SADB_X_EALG_BLOWFISHCBC, "blowfish-cbc", },
+ #ifdef SADB_X_EALG_RIJNDAELCBC
+ 	{ SADB_X_EALG_RIJNDAELCBC, "rijndael-cbc", },
+ #endif
+ #ifdef SADB_X_EALG_TWOFISHCBC
+ 	{ SADB_X_EALG_TWOFISHCBC, "twofish-cbc", },
+ #endif
+ 	{ -1, NULL, },
+ };
+ 
+ static struct val2str str_alg_comp[] = {
+ 	{ SADB_X_CALG_NONE, "none", },
+ 	{ SADB_X_CALG_OUI, "oui", },
+ 	{ SADB_X_CALG_DEFLATE, "deflate", },
+ 	{ SADB_X_CALG_LZS, "lzs", },
+ 	{ -1, NULL, },
+ };
+ 
+ /*
+  * dump SADB_MSG formated.  For debugging, you should use kdebug_sadb().
+  */
+ void
+ pfkey_sadump(m)
+ 	struct sadb_msg *m;
+ {
+ 	caddr_t mhp[SADB_EXT_MAX + 1];
+ 	struct sadb_sa *m_sa;
+ 	struct sadb_x_sa2 *m_sa2;
+ 	struct sadb_lifetime *m_lftc, *m_lfth, *m_lfts;
+ 	struct sadb_address *m_saddr, *m_daddr, *m_paddr;
+ 	struct sadb_key *m_auth, *m_enc;
+ 	struct sadb_ident *m_sid, *m_did;
+ 	struct sadb_sens *m_sens;
+ 
+ 	/* check pfkey message. */
+ 	if (pfkey_align(m, mhp)) {
+ 		printf("%s\n", ipsec_strerror());
+ 		return;
+ 	}
+ 	if (pfkey_check(mhp)) {
+ 		printf("%s\n", ipsec_strerror());
+ 		return;
+ 	}
+ 
+ 	m_sa = (struct sadb_sa *)mhp[SADB_EXT_SA];
+ 	m_sa2 = (struct sadb_x_sa2 *)mhp[SADB_X_EXT_SA2];
+ 	m_lftc = (struct sadb_lifetime *)mhp[SADB_EXT_LIFETIME_CURRENT];
+ 	m_lfth = (struct sadb_lifetime *)mhp[SADB_EXT_LIFETIME_HARD];
+ 	m_lfts = (struct sadb_lifetime *)mhp[SADB_EXT_LIFETIME_SOFT];
+ 	m_saddr = (struct sadb_address *)mhp[SADB_EXT_ADDRESS_SRC];
+ 	m_daddr = (struct sadb_address *)mhp[SADB_EXT_ADDRESS_DST];
+ 	m_paddr = (struct sadb_address *)mhp[SADB_EXT_ADDRESS_PROXY];
+ 	m_auth = (struct sadb_key *)mhp[SADB_EXT_KEY_AUTH];
+ 	m_enc = (struct sadb_key *)mhp[SADB_EXT_KEY_ENCRYPT];
+ 	m_sid = (struct sadb_ident *)mhp[SADB_EXT_IDENTITY_SRC];
+ 	m_did = (struct sadb_ident *)mhp[SADB_EXT_IDENTITY_DST];
+ 	m_sens = (struct sadb_sens *)mhp[SADB_EXT_SENSITIVITY];
+ 
+ 	/* source address */
+ 	if (m_saddr == NULL) {
+ 		printf("no ADDRESS_SRC extension.\n");
+ 		return;
+ 	}
+ 	printf("%s ", str_ipaddr((struct sockaddr *)(m_saddr + 1)));
+ 
+ 	/* destination address */
+ 	if (m_daddr == NULL) {
+ 		printf("no ADDRESS_DST extension.\n");
+ 		return;
+ 	}
+ 	printf("%s ", str_ipaddr((struct sockaddr *)(m_daddr + 1)));
+ 
+ 	/* SA type */
+ 	if (m_sa == NULL) {
+ 		printf("no SA extension.\n");
+ 		return;
+ 	}
+ 	if (m_sa2 == NULL) {
+ 		printf("no SA2 extension.\n");
+ 		return;
+ 	}
+ 	printf("\n\t");
+ 
+ 	GETMSGSTR(str_satype, m->sadb_msg_satype);
+ 
+ 	printf("mode=");
+ 	GETMSGSTR(str_mode, m_sa2->sadb_x_sa2_mode);
+ 
+ 	printf("spi=%u(0x%08x) reqid=%u(0x%08x)\n",
+ 		(u_int32_t)ntohl(m_sa->sadb_sa_spi),
+ 		(u_int32_t)ntohl(m_sa->sadb_sa_spi),
+ 		(u_int32_t)m_sa2->sadb_x_sa2_reqid,
+ 		(u_int32_t)m_sa2->sadb_x_sa2_reqid);
+ 
+ 	/* encryption key */
+ 	if (m->sadb_msg_satype == SADB_X_SATYPE_IPCOMP) {
+ 		printf("\tC: ");
+ 		GETMSGV2S(str_alg_comp, m_sa->sadb_sa_encrypt);
+ 	} else if (m->sadb_msg_satype == SADB_SATYPE_ESP) {
+ 		if (m_enc != NULL) {
+ 			printf("\tE: ");
+ 			GETMSGV2S(str_alg_enc, m_sa->sadb_sa_encrypt);
+ 			ipsec_hexdump((caddr_t)m_enc + sizeof(*m_enc),
+ 				      m_enc->sadb_key_bits / 8);
+ 			printf("\n");
+ 		}
+ 	}
+ 
+ 	/* authentication key */
+ 	if (m_auth != NULL) {
+ 		printf("\tA: ");
+ 		GETMSGV2S(str_alg_auth, m_sa->sadb_sa_auth);
+ 		ipsec_hexdump((caddr_t)m_auth + sizeof(*m_auth),
+ 		              m_auth->sadb_key_bits / 8);
+ 		printf("\n");
+ 	}
+ 
+ 	/* replay windoe size & flags */
+ 	printf("\tseq=0x%08x replay=%u flags=0x%08x ",
+ 		m_sa2->sadb_x_sa2_sequence,
+ 		m_sa->sadb_sa_replay,
+ 		m_sa->sadb_sa_flags);
+ 
+ 	/* state */
+ 	printf("state=");
+ 	GETMSGSTR(str_state, m_sa->sadb_sa_state);
+ 	printf("\n");
+ 
+ 	/* lifetime */
+ 	if (m_lftc != NULL) {
+ 		time_t tmp_time = time(0);
+ 
+ 		printf("\tcreated: %s",
+ 			str_time(m_lftc->sadb_lifetime_addtime));
+ 		printf("\tcurrent: %s\n", str_time(tmp_time));
+ 		printf("\tdiff: %lu(s)",
+ 			(u_long)(m_lftc->sadb_lifetime_addtime == 0 ?
+ 			0 : (tmp_time - m_lftc->sadb_lifetime_addtime)));
+ 
+ 		printf("\thard: %lu(s)",
+ 			(u_long)(m_lfth == NULL ?
+ 			0 : m_lfth->sadb_lifetime_addtime));
+ 		printf("\tsoft: %lu(s)\n",
+ 			(u_long)(m_lfts == NULL ?
+ 			0 : m_lfts->sadb_lifetime_addtime));
+ 
+ 		printf("\tlast: %s",
+ 			str_time(m_lftc->sadb_lifetime_usetime));
+ 		printf("\thard: %lu(s)",
+ 			(u_long)(m_lfth == NULL ?
+ 			0 : m_lfth->sadb_lifetime_usetime));
+ 		printf("\tsoft: %lu(s)\n",
+ 			(u_long)(m_lfts == NULL ?
+ 			0 : m_lfts->sadb_lifetime_usetime));
+ 
+ 		str_lifetime_byte(m_lftc, "current");
+ 		str_lifetime_byte(m_lfth, "hard");
+ 		str_lifetime_byte(m_lfts, "soft");
+ 		printf("\n");
+ 
+ 		printf("\tallocated: %lu",
+ 			(unsigned long)m_lftc->sadb_lifetime_allocations);
+ 		printf("\thard: %lu",
+ 			(u_long)(m_lfth == NULL ?
+ 			0 : m_lfth->sadb_lifetime_allocations));
+ 		printf("\tsoft: %lu\n",
+ 			(u_long)(m_lfts == NULL ?
+ 			0 : m_lfts->sadb_lifetime_allocations));
+ 	}
+ 
+ 	printf("\tsadb_seq=%lu pid=%lu ",
+ 		(u_long)m->sadb_msg_seq,
+ 		(u_long)m->sadb_msg_pid);
+ 
+ 	/* XXX DEBUG */
+ 	printf("refcnt=%u\n", m->sadb_msg_reserved);
+ 
+ 	return;
+ }
+ 
+ void
+ pfkey_spdump(m)
+ 	struct sadb_msg *m;
+ {
+ 	char pbuf[NI_MAXSERV];
+ 	caddr_t mhp[SADB_EXT_MAX + 1];
+ 	struct sadb_address *m_saddr, *m_daddr;
+ 	struct sadb_x_policy *m_xpl;
+ 	struct sadb_lifetime *m_lftc = NULL, *m_lfth = NULL;
+ 	struct sockaddr *sa;
+ 	u_int16_t sport = 0, dport = 0;
+ 
+ 	/* check pfkey message. */
+ 	if (pfkey_align(m, mhp)) {
+ 		printf("%s\n", ipsec_strerror());
+ 		return;
+ 	}
+ 	if (pfkey_check(mhp)) {
+ 		printf("%s\n", ipsec_strerror());
+ 		return;
+ 	}
+ 
+ 	m_saddr = (struct sadb_address *)mhp[SADB_EXT_ADDRESS_SRC];
+ 	m_daddr = (struct sadb_address *)mhp[SADB_EXT_ADDRESS_DST];
+ 	m_xpl = (struct sadb_x_policy *)mhp[SADB_X_EXT_POLICY];
+ 	m_lftc = (struct sadb_lifetime *)mhp[SADB_EXT_LIFETIME_CURRENT];
+ 	m_lfth = (struct sadb_lifetime *)mhp[SADB_EXT_LIFETIME_HARD];
+ 
+ 	/* source address */
+ 	if (m_saddr == NULL) {
+ 		printf("no ADDRESS_SRC extension.\n");
+ 		return;
+ 	}
+ 	sa = (struct sockaddr *)(m_saddr + 1);
+ 	switch (sa->sa_family) {
+ 	case AF_INET:
+ 	case AF_INET6:
+ 		if (getnameinfo(sa, sysdep_sa_len(sa), NULL, 0, pbuf, sizeof(pbuf),
+ 		    NI_NUMERICSERV) != 0)
+ 			sport = 0;	/*XXX*/
+ 		else
+ 			sport = atoi(pbuf);
+ 		printf("%s%s ", str_ipaddr(sa),
+ 			str_prefport(sa->sa_family,
+ 			    m_saddr->sadb_address_prefixlen, sport,
+ 			    m_saddr->sadb_address_proto));
+ 		break;
+ 	default:
+ 		printf("unknown-af ");
+ 		break;
+ 	}
+ 
+ 	/* destination address */
+ 	if (m_daddr == NULL) {
+ 		printf("no ADDRESS_DST extension.\n");
+ 		return;
+ 	}
+ 	sa = (struct sockaddr *)(m_daddr + 1);
+ 	switch (sa->sa_family) {
+ 	case AF_INET:
+ 	case AF_INET6:
+ 		if (getnameinfo(sa, sysdep_sa_len(sa), NULL, 0, pbuf, sizeof(pbuf),
+ 		    NI_NUMERICSERV) != 0)
+ 			dport = 0;	/*XXX*/
+ 		else
+ 			dport = atoi(pbuf);
+ 		printf("%s%s ", str_ipaddr(sa),
+ 			str_prefport(sa->sa_family,
+ 			    m_daddr->sadb_address_prefixlen, dport,
+ 			    m_saddr->sadb_address_proto));
+ 		break;
+ 	default:
+ 		printf("unknown-af ");
+ 		break;
+ 	}
+ 
+ 	/* upper layer protocol */
+ 	if (m_saddr->sadb_address_proto != m_daddr->sadb_address_proto) {
+ 		printf("upper layer protocol mismatched.\n");
+ 		return;
+ 	}
+ 	str_upperspec(m_saddr->sadb_address_proto, sport, dport);
+ 
+ 	/* policy */
+     {
+ 	char *d_xpl;
+ 
+ 	if (m_xpl == NULL) {
+ 		printf("no X_POLICY extension.\n");
+ 		return;
+ 	}
+ 	d_xpl = ipsec_dump_policy((char *)m_xpl, "\n\t");
+ 	if (!d_xpl)
+ 		printf("\n\tPolicy:[%s]\n", ipsec_strerror());
+ 	else {
+ 		/* dump SPD */
+ 		printf("\n\t%s\n", d_xpl);
+ 		free(d_xpl);
+ 	}
+     }
+ 
+ 	/* lifetime */
+ 	if (m_lftc) {
+ 		printf("\tcreated: %s  ",
+ 			str_time(m_lftc->sadb_lifetime_addtime));
+ 		printf("lastused: %s\n",
+ 			str_time(m_lftc->sadb_lifetime_usetime));
+ 	}
+ 	if (m_lfth) {
+ 		printf("\tlifetime: %lu(s) ",
+ 			(u_long)m_lfth->sadb_lifetime_addtime);
+ 		printf("validtime: %lu(s)\n",
+ 			(u_long)m_lfth->sadb_lifetime_usetime);
+ 	}
+ 
+ 
+ 	printf("\tspid=%ld seq=%ld pid=%ld\n",
+ 		(u_long)m_xpl->sadb_x_policy_id,
+ 		(u_long)m->sadb_msg_seq,
+ 		(u_long)m->sadb_msg_pid);
+ 
+ 	/* XXX TEST */
+ 	printf("\trefcnt=%u\n", m->sadb_msg_reserved);
+ 
+ 	return;
+ }
+ 
+ /*
+  * set "ipaddress" to buffer.
+  */
+ static char *
+ str_ipaddr(sa)
+ 	struct sockaddr *sa;
+ {
+ 	static char buf[NI_MAXHOST];
+ 	const int niflag = NI_NUMERICHOST;
+ 
+ 	if (sa == NULL)
+ 		return "";
+ 
+ 	if (getnameinfo(sa, sysdep_sa_len(sa), buf, sizeof(buf), NULL, 0, niflag) == 0)
+ 		return buf;
+ 	return NULL;
+ }
+ 
+ /*
+  * set "/prefix[port number]" to buffer.
+  */
+ static char *
+ str_prefport(family, pref, port, ulp)
+ 	u_int family, pref, port, ulp;
+ {
+ 	static char buf[128];
+ 	char prefbuf[10];
+ 	char portbuf[10];
+ 	int plen;
+ 
+ 	switch (family) {
+ 	case AF_INET:
+ 		plen = sizeof(struct in_addr) << 3;
+ 		break;
+ 	case AF_INET6:
+ 		plen = sizeof(struct in6_addr) << 3;
+ 		break;
+ 	default:
+ 		return "?";
+ 	}
+ 
+ 	if (pref == plen)
+ 		prefbuf[0] = '\0';
+ 	else
+ 		snprintf(prefbuf, sizeof(prefbuf), "/%u", pref);
+ 
+ 	if (ulp == IPPROTO_ICMPV6)
+ 		memset(portbuf, 0, sizeof(portbuf));
+ 	else {
+ 		if (port == IPSEC_PORT_ANY)
+ 			snprintf(portbuf, sizeof(portbuf), "[%s]", "any");
+ 		else
+ 			snprintf(portbuf, sizeof(portbuf), "[%u]", port);
+ 	}
+ 
+ 	snprintf(buf, sizeof(buf), "%s%s", prefbuf, portbuf);
+ 
+ 	return buf;
+ }
+ 
+ static void
+ str_upperspec(ulp, p1, p2)
+ 	u_int ulp, p1, p2;
+ {
+ 	if (ulp == IPSEC_ULPROTO_ANY)
+ 		printf("any");
+ 	else if (ulp == IPPROTO_ICMPV6) {
+ 		printf("icmp6");
+ 		if (!(p1 == IPSEC_PORT_ANY && p2 == IPSEC_PORT_ANY))
+ 			printf(" %u,%u", p1, p2);
+ 	} else {
+ 		struct protoent *ent;
+ 
+ 		switch (ulp) {
+ 		case IPPROTO_IPV4:
+ 			printf("ip4");
+ 			break;
+ 		default:
+ 			ent = getprotobynumber(ulp);
+ 			if (ent)
+ 				printf("%s", ent->p_name);
+ 			else
+ 				printf("%u", ulp);
+ 
+ 			endprotoent();
+ 			break;
+ 		}
+ 	}
+ }
+ 
+ /*
+  * set "Mon Day Time Year" to buffer
+  */
+ static char *
+ str_time(t)
+ 	time_t t;
+ {
+ 	static char buf[128];
+ 
+ 	if (t == 0) {
+ 		int i = 0;
+ 		for (;i < 20;) buf[i++] = ' ';
+ 	} else {
+ 		char *t0;
+ 		t0 = ctime(&t);
+ 		memcpy(buf, t0 + 4, 20);
+ 	}
+ 
+ 	buf[20] = '\0';
+ 
+ 	return(buf);
+ }
+ 
+ static void
+ str_lifetime_byte(x, str)
+ 	struct sadb_lifetime *x;
+ 	char *str;
+ {
+ 	double y;
+ 	char *unit;
+ 	int w;
+ 
+ 	if (x == NULL) {
+ 		printf("\t%s: 0(bytes)", str);
+ 		return;
+ 	}
+ 
+ #if 0
+ 	if ((x->sadb_lifetime_bytes) / 1024 / 1024) {
+ 		y = (x->sadb_lifetime_bytes) * 1.0 / 1024 / 1024;
+ 		unit = "M";
+ 		w = 1;
+ 	} else if ((x->sadb_lifetime_bytes) / 1024) {
+ 		y = (x->sadb_lifetime_bytes) * 1.0 / 1024;
+ 		unit = "K";
+ 		w = 1;
+ 	} else {
+ 		y = (x->sadb_lifetime_bytes) * 1.0;
+ 		unit = "";
+ 		w = 0;
+ 	}
+ #else
+ 	y = (x->sadb_lifetime_bytes) * 1.0;
+ 	unit = "";
+ 	w = 0;
+ #endif
+ 	printf("\t%s: %.*f(%sbytes)", str, w, y, unit);
+ }
diff -Nr -c25 ac_am/src/libipsec/policy_parse.y ac_am_fixed/src/libipsec/policy_parse.y
*** ac_am/src/libipsec/policy_parse.y	2003-03-04 00:56:55.000000000 +0100
--- ac_am_fixed/src/libipsec/policy_parse.y	2003-12-11 18:19:59.135058224 +0100
***************
*** 285,357 ****
  		}
  	}
  
  	__ipsec_errcode = EIPSEC_NO_ERROR;
  	return 0;
  }
  
  static int
  init_x_policy()
  {
  	struct sadb_x_policy *p;
  
  	tlen = sizeof(struct sadb_x_policy);
  
  	pbuf = malloc(tlen);
  	if (pbuf == NULL) {
  		__ipsec_errcode = EIPSEC_NO_BUFS;
  		return -1;
  	}
  	p = (struct sadb_x_policy *)pbuf;
  	p->sadb_x_policy_len = 0;	/* must update later */
  	p->sadb_x_policy_exttype = SADB_X_EXT_POLICY;
  	p->sadb_x_policy_type = p_type;
  	p->sadb_x_policy_dir = p_dir;
  	p->sadb_x_policy_reserved = 0;
  	offset = tlen;
  
  	__ipsec_errcode = EIPSEC_NO_ERROR;
  	return 0;
  }
  
  static int
  set_x_request(src, dst)
  	struct sockaddr *src, *dst;
  {
  	struct sadb_x_ipsecrequest *p;
  	int reqlen;
  
  	reqlen = sizeof(*p)
  		+ (src ? sysdep_sa_len(src) : 0)
  		+ (dst ? sysdep_sa_len(dst) : 0);
- 	tlen += reqlen;		/* increment to total length */
  
! 	pbuf = realloc(pbuf, tlen);
! 	if (pbuf == NULL) {
  		__ipsec_errcode = EIPSEC_NO_BUFS;
  		return -1;
  	}
  	p = (struct sadb_x_ipsecrequest *)&pbuf[offset];
  	p->sadb_x_ipsecrequest_len = reqlen;
  	p->sadb_x_ipsecrequest_proto = p_protocol;
  	p->sadb_x_ipsecrequest_mode = p_mode;
  	p->sadb_x_ipsecrequest_level = p_level;
  	p->sadb_x_ipsecrequest_reqid = p_reqid;
  	offset += sizeof(*p);
  
  	if (set_sockaddr(src) || set_sockaddr(dst))
  		return -1;
  
  	__ipsec_errcode = EIPSEC_NO_ERROR;
  	return 0;
  }
  
  static int
  set_sockaddr(addr)
  	struct sockaddr *addr;
  {
  	if (addr == NULL) {
  		__ipsec_errcode = EIPSEC_NO_ERROR;
  		return 0;
  	}
  
  	/* tlen has already incremented */
--- 285,361 ----
  		}
  	}
  
  	__ipsec_errcode = EIPSEC_NO_ERROR;
  	return 0;
  }
  
  static int
  init_x_policy()
  {
  	struct sadb_x_policy *p;
  
  	tlen = sizeof(struct sadb_x_policy);
  
  	pbuf = malloc(tlen);
  	if (pbuf == NULL) {
  		__ipsec_errcode = EIPSEC_NO_BUFS;
  		return -1;
  	}
  	p = (struct sadb_x_policy *)pbuf;
  	p->sadb_x_policy_len = 0;	/* must update later */
  	p->sadb_x_policy_exttype = SADB_X_EXT_POLICY;
  	p->sadb_x_policy_type = p_type;
  	p->sadb_x_policy_dir = p_dir;
  	p->sadb_x_policy_reserved = 0;
+ 	p->sadb_x_policy_id = 0;
+ 
  	offset = tlen;
  
  	__ipsec_errcode = EIPSEC_NO_ERROR;
  	return 0;
  }
  
  static int
  set_x_request(src, dst)
  	struct sockaddr *src, *dst;
  {
  	struct sadb_x_ipsecrequest *p;
  	int reqlen;
+ 	caddr_t n;
  
  	reqlen = sizeof(*p)
  		+ (src ? sysdep_sa_len(src) : 0)
  		+ (dst ? sysdep_sa_len(dst) : 0);
  
! 	n = realloc(pbuf, tlen + reqlen);
! 	if (n == NULL) {
  		__ipsec_errcode = EIPSEC_NO_BUFS;
  		return -1;
  	}
+ 	tlen += reqlen;
+ 	pbuf = n;
  	p = (struct sadb_x_ipsecrequest *)&pbuf[offset];
  	p->sadb_x_ipsecrequest_len = reqlen;
  	p->sadb_x_ipsecrequest_proto = p_protocol;
  	p->sadb_x_ipsecrequest_mode = p_mode;
  	p->sadb_x_ipsecrequest_level = p_level;
  	p->sadb_x_ipsecrequest_reqid = p_reqid;
  	offset += sizeof(*p);
  
  	if (set_sockaddr(src) || set_sockaddr(dst))
  		return -1;
  
  	__ipsec_errcode = EIPSEC_NO_ERROR;
  	return 0;
  }
  
  static int
  set_sockaddr(addr)
  	struct sockaddr *addr;
  {
  	if (addr == NULL) {
  		__ipsec_errcode = EIPSEC_NO_ERROR;
  		return 0;
  	}
  
  	/* tlen has already incremented */
diff -Nr -c25 ac_am/src/libipsec/policy_token.l ac_am_fixed/src/libipsec/policy_token.l
*** ac_am/src/libipsec/policy_token.l	2003-03-04 00:56:55.000000000 +0100
--- ac_am_fixed/src/libipsec/policy_token.l	2003-12-11 18:19:59.137057920 +0100
***************
*** 119,156 ****
--- 119,158 ----
  unique		{ yylval.num = IPSEC_LEVEL_UNIQUE; return(LEVEL); }
  {slash}		{ return(SLASH); }
  
  {ipaddress}	{
  			yylval.val.len = strlen(yytext);
  			yylval.val.buf = yytext;
  			return(IPADDRESS);
  		}
  
  {hyphen}	{ return(HYPHEN); }
  
  {ws}		{ ; }
  {nl}		{ ; }
  
  %%
  
  void __policy__strbuffer__init__ __P((char *));
  void __policy__strbuffer__free__ __P((void));
  
  static YY_BUFFER_STATE strbuffer;
  
  void
  __policy__strbuffer__init__(msg)
  	char *msg;
  {
+ 	if (YY_CURRENT_BUFFER)
+ 		yy_delete_buffer(YY_CURRENT_BUFFER);
  	strbuffer = (YY_BUFFER_STATE)yy_scan_string(msg);
  	yy_switch_to_buffer(strbuffer);
  
  	return;
  }
  
  void
  __policy__strbuffer__free__()
  {
  	yy_delete_buffer(strbuffer);
  
  	return;
  }
diff -Nr -c25 ac_am/src/libipsec/test-policy.c ac_am_fixed/src/libipsec/test-policy.c
*** ac_am/src/libipsec/test-policy.c	2003-02-28 22:31:03.000000000 +0100
--- ac_am_fixed/src/libipsec/test-policy.c	2003-12-11 18:19:59.139057616 +0100
***************
*** 89,141 ****
  int test2sub __P((int));
  
  int
  main(ac, av)
  	int ac;
  	char **av;
  {
  	test1();
  	test2();
  
  	exit(0);
  }
  
  int
  test1()
  {
  	int i;
  	int result;
  
  	printf("TEST1\n");
  	for (i = 0; i < sizeof(reqs)/sizeof(reqs[0]); i++) {
  		printf("#%d [%s]\n", i + 1, reqs[i].str);
  
  		result = test1sub1(&reqs[i]);
  		if (result == 0 && reqs[i].result == 1) {
! 			warnx("ERROR: expecting failure.\n");
  		} else if (result == 1 && reqs[i].result == 0) {
! 			warnx("ERROR: expecting success.\n");
  		}
  	}
  
  	return 0;
  }
  
  int
  test1sub1(req)
  	struct req_t *req;
  {
  	char *buf;
  
  	buf = ipsec_set_policy(req->str, strlen(req->str));
  	if (buf == NULL) {
  		printf("ipsec_set_policy: %s\n", ipsec_strerror());
  		return 1;
  	}
  
  	if (test1sub2(buf, PF_INET) != 0
  	 || test1sub2(buf, PF_INET6) != 0) {
  		free(buf);
  		return 1;
  	}
  #if 0
  	kdebug_sadb_x_policy((struct sadb_ext *)buf);
--- 89,141 ----
  int test2sub __P((int));
  
  int
  main(ac, av)
  	int ac;
  	char **av;
  {
  	test1();
  	test2();
  
  	exit(0);
  }
  
  int
  test1()
  {
  	int i;
  	int result;
  
  	printf("TEST1\n");
  	for (i = 0; i < sizeof(reqs)/sizeof(reqs[0]); i++) {
  		printf("#%d [%s]\n", i + 1, reqs[i].str);
  
  		result = test1sub1(&reqs[i]);
  		if (result == 0 && reqs[i].result == 1) {
! 			warnx("ERROR: expecting failure.");
  		} else if (result == 1 && reqs[i].result == 0) {
! 			warnx("ERROR: expecting success.");
  		}
  	}
  
  	return 0;
  }
  
  int
  test1sub1(req)
  	struct req_t *req;
  {
  	char *buf;
  
  	buf = ipsec_set_policy(req->str, strlen(req->str));
  	if (buf == NULL) {
  		printf("ipsec_set_policy: %s\n", ipsec_strerror());
  		return 1;
  	}
  
  	if (test1sub2(buf, PF_INET) != 0
  	 || test1sub2(buf, PF_INET6) != 0) {
  		free(buf);
  		return 1;
  	}
  #if 0
  	kdebug_sadb_x_policy((struct sadb_ext *)buf);
***************
*** 208,330 ****
  
  	close (so);
  	return 0;
  }
  
  char addr[] = {
  	28, 28, 0, 0,
  	0, 0, 0, 0,
  	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
  	0, 0, 0, 0,
  };
  
  int
  test2()
  {
  	int so;
  	char *pol1 = "out ipsec";
  	char *pol2 = "out ipsec ah/transport//use";
  	char *sp1, *sp2;
  	int splen1, splen2;
  	int spid;
  	struct sadb_msg *m;
  
  	printf("TEST2\n");
  	if (getuid() != 0)
! 		errx(1, "root privilege required.\n");
  
  	sp1 = ipsec_set_policy(pol1, strlen(pol1));
  	splen1 = ipsec_get_policylen(sp1);
  	sp2 = ipsec_set_policy(pol2, strlen(pol2));
  	splen2 = ipsec_get_policylen(sp2);
  
  	if ((so = pfkey_open()) < 0)
! 		errx(1, "ERROR: %s\n", ipsec_strerror());
  
  	printf("spdflush()\n");
  	if (pfkey_send_spdflush(so) < 0)
! 		errx(1, "ERROR: %s\n", ipsec_strerror());
  	m = pfkey_recv(so);
  	free(m);
  
  	printf("spdsetidx()\n");
  	if (pfkey_send_spdsetidx(so, (struct sockaddr *)addr, 128,
  				(struct sockaddr *)addr, 128,
  				255, sp1, splen1, 0) < 0)
! 		errx(1, "ERROR: %s\n", ipsec_strerror());
  	m = pfkey_recv(so);
  	free(m);
  	
  	printf("spdupdate()\n");
  	if (pfkey_send_spdupdate(so, (struct sockaddr *)addr, 128,
  				(struct sockaddr *)addr, 128,
  				255, sp2, splen2, 0) < 0)
! 		errx(1, "ERROR: %s\n", ipsec_strerror());
  	m = pfkey_recv(so);
  	free(m);
  
  	printf("sleep(4)\n");
  	sleep(4);
  
  	printf("spddelete()\n");
  	if (pfkey_send_spddelete(so, (struct sockaddr *)addr, 128,
  				(struct sockaddr *)addr, 128,
  				255, sp1, splen1, 0) < 0)
! 		errx(1, "ERROR: %s\n", ipsec_strerror());
  	m = pfkey_recv(so);
  	free(m);
  
  	printf("spdadd()\n");
  	if (pfkey_send_spdadd(so, (struct sockaddr *)addr, 128,
  				(struct sockaddr *)addr, 128,
  				255, sp2, splen2, 0) < 0)
! 		errx(1, "ERROR: %s\n", ipsec_strerror());
  	spid = test2sub(so);
  
  	printf("spdget(%u)\n", spid);
  	if (pfkey_send_spdget(so, spid) < 0)
! 		errx(1, "ERROR: %s\n", ipsec_strerror());
  	m = pfkey_recv(so);
  	free(m);
  
  	printf("sleep(4)\n");
  	sleep(4);
  
  	printf("spddelete2()\n");
  	if (pfkey_send_spddelete2(so, spid) < 0)
! 		errx(1, "ERROR: %s\n", ipsec_strerror());
  	m = pfkey_recv(so);
  	free(m);
  
  	printf("spdadd() with lifetime's 10(s)\n");
  	if (pfkey_send_spdadd2(so, (struct sockaddr *)addr, 128,
  				(struct sockaddr *)addr, 128,
  				255, 0, 10, sp2, splen2, 0) < 0)
! 		errx(1, "ERROR: %s\n", ipsec_strerror());
  	spid = test2sub(so);
  
  	/* expecting failure */
  	printf("spdupdate()\n");
  	if (pfkey_send_spdupdate(so, (struct sockaddr *)addr, 128,
  				(struct sockaddr *)addr, 128,
  				255, sp2, splen2, 0) == 0) {
! 		warnx("ERROR: expecting failure.\n");
  	}
  
  	return 0;
  }
  
  int
  test2sub(so)
  	int so;
  {
  	struct sadb_msg *msg;
  	caddr_t mhp[SADB_EXT_MAX + 1];
  
  	if ((msg = pfkey_recv(so)) == NULL)
! 		errx(1, "ERROR: pfkey_recv failure.\n");
  	if (pfkey_align(msg, mhp) < 0)
! 		errx(1, "ERROR: pfkey_align failure.\n");
  
  	return ((struct sadb_x_policy *)mhp[SADB_X_EXT_POLICY])->sadb_x_policy_id;
  }
  
--- 208,330 ----
  
  	close (so);
  	return 0;
  }
  
  char addr[] = {
  	28, 28, 0, 0,
  	0, 0, 0, 0,
  	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
  	0, 0, 0, 0,
  };
  
  int
  test2()
  {
  	int so;
  	char *pol1 = "out ipsec";
  	char *pol2 = "out ipsec ah/transport//use";
  	char *sp1, *sp2;
  	int splen1, splen2;
  	int spid;
  	struct sadb_msg *m;
  
  	printf("TEST2\n");
  	if (getuid() != 0)
! 		errx(1, "root privilege required.");
  
  	sp1 = ipsec_set_policy(pol1, strlen(pol1));
  	splen1 = ipsec_get_policylen(sp1);
  	sp2 = ipsec_set_policy(pol2, strlen(pol2));
  	splen2 = ipsec_get_policylen(sp2);
  
  	if ((so = pfkey_open()) < 0)
! 		errx(1, "ERROR: %s", ipsec_strerror());
  
  	printf("spdflush()\n");
  	if (pfkey_send_spdflush(so) < 0)
! 		errx(1, "ERROR: %s", ipsec_strerror());
  	m = pfkey_recv(so);
  	free(m);
  
  	printf("spdsetidx()\n");
  	if (pfkey_send_spdsetidx(so, (struct sockaddr *)addr, 128,
  				(struct sockaddr *)addr, 128,
  				255, sp1, splen1, 0) < 0)
! 		errx(1, "ERROR: %s", ipsec_strerror());
  	m = pfkey_recv(so);
  	free(m);
  	
  	printf("spdupdate()\n");
  	if (pfkey_send_spdupdate(so, (struct sockaddr *)addr, 128,
  				(struct sockaddr *)addr, 128,
  				255, sp2, splen2, 0) < 0)
! 		errx(1, "ERROR: %s", ipsec_strerror());
  	m = pfkey_recv(so);
  	free(m);
  
  	printf("sleep(4)\n");
  	sleep(4);
  
  	printf("spddelete()\n");
  	if (pfkey_send_spddelete(so, (struct sockaddr *)addr, 128,
  				(struct sockaddr *)addr, 128,
  				255, sp1, splen1, 0) < 0)
! 		errx(1, "ERROR: %s", ipsec_strerror());
  	m = pfkey_recv(so);
  	free(m);
  
  	printf("spdadd()\n");
  	if (pfkey_send_spdadd(so, (struct sockaddr *)addr, 128,
  				(struct sockaddr *)addr, 128,
  				255, sp2, splen2, 0) < 0)
! 		errx(1, "ERROR: %s", ipsec_strerror());
  	spid = test2sub(so);
  
  	printf("spdget(%u)\n", spid);
  	if (pfkey_send_spdget(so, spid) < 0)
! 		errx(1, "ERROR: %s", ipsec_strerror());
  	m = pfkey_recv(so);
  	free(m);
  
  	printf("sleep(4)\n");
  	sleep(4);
  
  	printf("spddelete2()\n");
  	if (pfkey_send_spddelete2(so, spid) < 0)
! 		errx(1, "ERROR: %s", ipsec_strerror());
  	m = pfkey_recv(so);
  	free(m);
  
  	printf("spdadd() with lifetime's 10(s)\n");
  	if (pfkey_send_spdadd2(so, (struct sockaddr *)addr, 128,
  				(struct sockaddr *)addr, 128,
  				255, 0, 10, sp2, splen2, 0) < 0)
! 		errx(1, "ERROR: %s", ipsec_strerror());
  	spid = test2sub(so);
  
  	/* expecting failure */
  	printf("spdupdate()\n");
  	if (pfkey_send_spdupdate(so, (struct sockaddr *)addr, 128,
  				(struct sockaddr *)addr, 128,
  				255, sp2, splen2, 0) == 0) {
! 		warnx("ERROR: expecting failure.");
  	}
  
  	return 0;
  }
  
  int
  test2sub(so)
  	int so;
  {
  	struct sadb_msg *msg;
  	caddr_t mhp[SADB_EXT_MAX + 1];
  
  	if ((msg = pfkey_recv(so)) == NULL)
! 		errx(1, "ERROR: pfkey_recv failure.");
  	if (pfkey_align(msg, mhp) < 0)
! 		errx(1, "ERROR: pfkey_align failure.");
  
  	return ((struct sadb_x_policy *)mhp[SADB_X_EXT_POLICY])->sadb_x_policy_id;
  }
  
diff -Nr -c25 ac_am/src/racoon/admin.c ac_am_fixed/src/racoon/admin.c
*** ac_am/src/racoon/admin.c	2003-02-28 05:06:40.000000000 +0100
--- ac_am_fixed/src/racoon/admin.c	2003-12-11 18:19:59.141057312 +0100
***************
*** 322,372 ****
  			switch (local->sa_family) {
  			case AF_INET:
  				((struct sockaddr_in *)local)->sin_port =
  					getmyaddrsport(local);
  				break;
  #ifdef INET6
  			case AF_INET6:
  				((struct sockaddr_in6 *)local)->sin6_port =
  					getmyaddrsport(local);
  				break;
  #endif
  			default:
  				plog(LLV_ERROR, LOCATION, NULL,
  					"invalid family: %d\n",
  					local->sa_family);
  				com->ac_errno = -1;
  				break;
  			}
  
  
  			plog(LLV_INFO, LOCATION, NULL,
  				"accept a request to establish IKE-SA: "
  				"%s\n", saddrwop2str(remote));
  
  			/* begin ident mode */
! 			if (isakmp_ph1begin_i(rmconf, remote) < 0) {
  				com->ac_errno = -1;
  				break;
  			}
  		    }
  			break;
  		case ADMIN_PROTO_AH:
  		case ADMIN_PROTO_ESP:
  			break;
  		default:
  			/* ignore */
  			com->ac_errno = -1;
  		}
  	    }
  		break;
  
  	default:
  		plog(LLV_ERROR, LOCATION, NULL,
  			"invalid command: %d\n", com->ac_cmd);
  		com->ac_errno = -1;
  	}
  
  	if (admin_reply(so2, com, buf) < 0)
  		goto bad;
  
  	if (buf != NULL)
--- 322,372 ----
  			switch (local->sa_family) {
  			case AF_INET:
  				((struct sockaddr_in *)local)->sin_port =
  					getmyaddrsport(local);
  				break;
  #ifdef INET6
  			case AF_INET6:
  				((struct sockaddr_in6 *)local)->sin6_port =
  					getmyaddrsport(local);
  				break;
  #endif
  			default:
  				plog(LLV_ERROR, LOCATION, NULL,
  					"invalid family: %d\n",
  					local->sa_family);
  				com->ac_errno = -1;
  				break;
  			}
  
  
  			plog(LLV_INFO, LOCATION, NULL,
  				"accept a request to establish IKE-SA: "
  				"%s\n", saddrwop2str(remote));
  
  			/* begin ident mode */
! 			if (isakmp_ph1begin_i(rmconf, remote, local) < 0) {
  				com->ac_errno = -1;
  				break;
  			}
  		    }
  			break;
  		case ADMIN_PROTO_AH:
  		case ADMIN_PROTO_ESP:
  			break;
  		default:
  			/* ignore */
  			com->ac_errno = -1;
  		}
  	    }
  		break;
  
  	default:
  		plog(LLV_ERROR, LOCATION, NULL,
  			"invalid command: %d\n", com->ac_cmd);
  		com->ac_errno = -1;
  	}
  
  	if (admin_reply(so2, com, buf) < 0)
  		goto bad;
  
  	if (buf != NULL)
diff -Nr -c25 ac_am/src/racoon/cfparse.y ac_am_fixed/src/racoon/cfparse.y
*** ac_am/src/racoon/cfparse.y	2003-03-04 00:56:56.000000000 +0100
--- ac_am_fixed/src/racoon/cfparse.y	2003-12-11 18:19:59.147056400 +0100
***************
*** 1,28 ****
--- 1,57 ----
  /*	$KAME: cfparse.y,v 1.114 2003/02/03 08:27:50 itojun Exp $	*/
  
  %{
+ /*
+  * Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002 and 2003 WIDE Project.
+  * All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions
+  * are met:
+  * 1. Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  * 2. Redistributions in binary form must reproduce the above copyright
+  *    notice, this list of conditions and the following disclaimer in the
+  *    documentation and/or other materials provided with the distribution.
+  * 3. Neither the name of the project nor the names of its contributors
+  *    may be used to endorse or promote products derived from this software
+  *    without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+  * SUCH DAMAGE.
+  */
+ 
  #include <sys/types.h>
  #include <sys/param.h>
  #include <sys/queue.h>
  #include <sys/socket.h>
  
  #include <netinet/in.h>
  #include <netinet/ipsec.h>
  
  #include <stdlib.h>
  #include <stdio.h>
  #include <string.h>
  #include <errno.h>
  #include <netdb.h>
  #if !defined(HAVE_GETADDRINFO) || !defined(HAVE_GETNAMEINFO)
  #include "addrinfo.h"
  #endif
  
  #include "var.h"
  #include "misc.h"
  #include "vmbuf.h"
  #include "plog.h"
  #include "sockmisc.h"
  #include "str2val.h"
  #include "debug.h"
  
***************
*** 112,171 ****
  	unsigned long num;
  	vchar_t *val;
  	struct remoteconf *rmconf;
  	struct sockaddr *saddr;
  	struct sainfoalg *alg;
  }
  
  	/* path */
  %token PATH PATHTYPE
  	/* include */
  %token INCLUDE
  	/* self information */
  %token IDENTIFIER VENDORID
  	/* logging */
  %token LOGGING LOGLEV
  	/* padding */
  %token PADDING PAD_RANDOMIZE PAD_RANDOMIZELEN PAD_MAXLEN PAD_STRICT PAD_EXCLTAIL
  	/* listen */
  %token LISTEN X_ISAKMP X_ADMIN STRICT_ADDRESS
  	/* timer */
  %token RETRY RETRY_COUNTER RETRY_INTERVAL RETRY_PERSEND
  %token RETRY_PHASE1 RETRY_PHASE2
  	/* algorithm */
  %token ALGORITHM_CLASS ALGORITHMTYPE STRENGTHTYPE
  	/* sainfo */
! %token SAINFO
  	/* remote */
  %token REMOTE ANONYMOUS
  %token EXCHANGE_MODE EXCHANGETYPE DOI DOITYPE SITUATION SITUATIONTYPE
  %token CERTIFICATE_TYPE CERTTYPE PEERS_CERTFILE VERIFY_CERT SEND_CERT SEND_CR
  %token IDENTIFIERTYPE MY_IDENTIFIER PEERS_IDENTIFIER VERIFY_IDENTIFIER
  %token DNSSEC CERT_X509
  %token NONCE_SIZE DH_GROUP KEEPALIVE PASSIVE INITIAL_CONTACT
  %token PROPOSAL_CHECK PROPOSAL_CHECK_LEVEL
! %token GENERATE_POLICY SUPPORT_MIP6
  %token PROPOSAL
  %token EXEC_PATH EXEC_COMMAND EXEC_SUCCESS EXEC_FAILURE
  %token GSSAPI_ID
  %token COMPLEX_BUNDLE
  
  %token PREFIX PORT PORTANY UL_PROTO ANY
  %token PFS_GROUP LIFETIME LIFETYPE_TIME LIFETYPE_BYTE STRENGTH
  
  %token NUMBER SWITCH BOOLEAN
  %token HEXSTRING QUOTEDSTRING ADDRSTRING
  %token UNITTYPE_BYTE UNITTYPE_KBYTES UNITTYPE_MBYTES UNITTYPE_TBYTES
  %token UNITTYPE_SEC UNITTYPE_MIN UNITTYPE_HOUR
  %token EOS BOC EOC COMMA
  
  %type <num> NUMBER BOOLEAN SWITCH keylength
  %type <num> PATHTYPE IDENTIFIERTYPE LOGLEV 
  %type <num> ALGORITHM_CLASS dh_group_num
  %type <num> ALGORITHMTYPE STRENGTHTYPE
  %type <num> PREFIX prefix PORT port ike_port
  %type <num> ul_proto UL_PROTO
  %type <num> EXCHANGETYPE DOITYPE SITUATIONTYPE
  %type <num> CERTTYPE CERT_X509 PROPOSAL_CHECK_LEVEL
  %type <num> unittype_time unittype_byte
  %type <val> QUOTEDSTRING HEXSTRING ADDRSTRING sainfo_id
  %type <val> identifierstring
--- 141,200 ----
  	unsigned long num;
  	vchar_t *val;
  	struct remoteconf *rmconf;
  	struct sockaddr *saddr;
  	struct sainfoalg *alg;
  }
  
  	/* path */
  %token PATH PATHTYPE
  	/* include */
  %token INCLUDE
  	/* self information */
  %token IDENTIFIER VENDORID
  	/* logging */
  %token LOGGING LOGLEV
  	/* padding */
  %token PADDING PAD_RANDOMIZE PAD_RANDOMIZELEN PAD_MAXLEN PAD_STRICT PAD_EXCLTAIL
  	/* listen */
  %token LISTEN X_ISAKMP X_ADMIN STRICT_ADDRESS
  	/* timer */
  %token RETRY RETRY_COUNTER RETRY_INTERVAL RETRY_PERSEND
  %token RETRY_PHASE1 RETRY_PHASE2
  	/* algorithm */
  %token ALGORITHM_CLASS ALGORITHMTYPE STRENGTHTYPE
  	/* sainfo */
! %token SAINFO FROM
  	/* remote */
  %token REMOTE ANONYMOUS
  %token EXCHANGE_MODE EXCHANGETYPE DOI DOITYPE SITUATION SITUATIONTYPE
  %token CERTIFICATE_TYPE CERTTYPE PEERS_CERTFILE VERIFY_CERT SEND_CERT SEND_CR
  %token IDENTIFIERTYPE MY_IDENTIFIER PEERS_IDENTIFIER VERIFY_IDENTIFIER
  %token DNSSEC CERT_X509
  %token NONCE_SIZE DH_GROUP KEEPALIVE PASSIVE INITIAL_CONTACT
  %token PROPOSAL_CHECK PROPOSAL_CHECK_LEVEL
! %token GENERATE_POLICY SUPPORT_PROXY
  %token PROPOSAL
  %token EXEC_PATH EXEC_COMMAND EXEC_SUCCESS EXEC_FAILURE
  %token GSSAPI_ID
  %token COMPLEX_BUNDLE
  
  %token PREFIX PORT PORTANY UL_PROTO ANY
  %token PFS_GROUP LIFETIME LIFETYPE_TIME LIFETYPE_BYTE STRENGTH
  
  %token NUMBER SWITCH BOOLEAN
  %token HEXSTRING QUOTEDSTRING ADDRSTRING
  %token UNITTYPE_BYTE UNITTYPE_KBYTES UNITTYPE_MBYTES UNITTYPE_TBYTES
  %token UNITTYPE_SEC UNITTYPE_MIN UNITTYPE_HOUR
  %token EOS BOC EOC COMMA
  
  %type <num> NUMBER BOOLEAN SWITCH keylength
  %type <num> PATHTYPE IDENTIFIERTYPE LOGLEV 
  %type <num> ALGORITHM_CLASS dh_group_num
  %type <num> ALGORITHMTYPE STRENGTHTYPE
  %type <num> PREFIX prefix PORT port ike_port
  %type <num> ul_proto UL_PROTO
  %type <num> EXCHANGETYPE DOITYPE SITUATIONTYPE
  %type <num> CERTTYPE CERT_X509 PROPOSAL_CHECK_LEVEL
  %type <num> unittype_time unittype_byte
  %type <val> QUOTEDSTRING HEXSTRING ADDRSTRING sainfo_id
  %type <val> identifierstring
***************
*** 196,256 ****
  	:	PATH PATHTYPE QUOTEDSTRING
  		{
  			if ($2 > LC_PATHTYPE_MAX) {
  				yyerror("invalid path type %d", $2);
  				return -1;
  			}
  
  			/* free old pathinfo */
  			if (lcconf->pathinfo[$2])
  				racoon_free(lcconf->pathinfo[$2]);
  
  			/* set new pathinfo */
  			lcconf->pathinfo[$2] = strdup($3->v);
  			vfree($3);
  		}
  		EOS
  	;
  
  	/* special */
  special_statement
  	:	COMPLEX_BUNDLE SWITCH { lcconf->complex_bundle = $2; } EOS
  	;
  
  	/* include */
  include_statement
! 	:	INCLUDE QUOTEDSTRING
  		{
  			char path[MAXPATHLEN];
  
  			getpathname(path, sizeof(path),
  				LC_PATHTYPE_INCLUDE, $2->v);
  			vfree($2);
  			if (yycf_switch_buffer(path) != 0)
  				return -1;
  		}
- 		EOS
  	;
  
  	/* self infomation */
  identifier_statement
  	:	IDENTIFIER identifier_stmt
  	;
  identifier_stmt
  	:	VENDORID
  		{
  			/*XXX to be deleted */
  		}
  		QUOTEDSTRING EOS
  	|	IDENTIFIERTYPE QUOTEDSTRING
  		{
  			/*XXX to be deleted */
  			$2->l--;	/* nuke '\0' */
  			lcconf->ident[$1] = $2;
  			if (lcconf->ident[$1] == NULL) {
  				yyerror("failed to set my ident: %s",
  					strerror(errno));
  				return -1;
  			}
  		}
  		EOS
  	;
--- 225,284 ----
  	:	PATH PATHTYPE QUOTEDSTRING
  		{
  			if ($2 > LC_PATHTYPE_MAX) {
  				yyerror("invalid path type %d", $2);
  				return -1;
  			}
  
  			/* free old pathinfo */
  			if (lcconf->pathinfo[$2])
  				racoon_free(lcconf->pathinfo[$2]);
  
  			/* set new pathinfo */
  			lcconf->pathinfo[$2] = strdup($3->v);
  			vfree($3);
  		}
  		EOS
  	;
  
  	/* special */
  special_statement
  	:	COMPLEX_BUNDLE SWITCH { lcconf->complex_bundle = $2; } EOS
  	;
  
  	/* include */
  include_statement
! 	:	INCLUDE QUOTEDSTRING EOS
  		{
  			char path[MAXPATHLEN];
  
  			getpathname(path, sizeof(path),
  				LC_PATHTYPE_INCLUDE, $2->v);
  			vfree($2);
  			if (yycf_switch_buffer(path) != 0)
  				return -1;
  		}
  	;
  
  	/* self infomation */
  identifier_statement
  	:	IDENTIFIER identifier_stmt
  	;
  identifier_stmt
  	:	VENDORID
  		{
  			/*XXX to be deleted */
  		}
  		QUOTEDSTRING EOS
  	|	IDENTIFIERTYPE QUOTEDSTRING
  		{
  			/*XXX to be deleted */
  			$2->l--;	/* nuke '\0' */
  			lcconf->ident[$1] = $2;
  			if (lcconf->ident[$1] == NULL) {
  				yyerror("failed to set my ident: %s",
  					strerror(errno));
  				return -1;
  			}
  		}
  		EOS
  	;
***************
*** 374,446 ****
  			lcconf->count_persend = $2;
  		}
  		EOS
  	|	RETRY_PHASE1 NUMBER unittype_time
  		{
  			lcconf->retry_checkph1 = $2 * $3;
  		}
  		EOS
  	|	RETRY_PHASE2 NUMBER unittype_time
  		{
  			lcconf->wait_ph2complete = $2 * $3;
  		}
  		EOS
  	;
  
  	/* sainfo */
  sainfo_statement
  	:	SAINFO
  		{
  			cur_sainfo = newsainfo();
  			if (cur_sainfo == NULL) {
  				yyerror("failed to allocate sainfo");
  				return -1;
  			}
  		}
! 		sainfo_name BOC sainfo_specs
  		{
  			struct sainfo *check;
  
  			/* default */
  			if (cur_sainfo->algs[algclass_ipsec_enc] == 0) {
  				yyerror("no encryption algorithm at %s",
  					sainfo2str(cur_sainfo));
  				return -1;
  			}
  			if (cur_sainfo->algs[algclass_ipsec_auth] == 0) {
  				yyerror("no authentication algorithm at %s",
  					sainfo2str(cur_sainfo));
  				return -1;
  			}
  			if (cur_sainfo->algs[algclass_ipsec_comp] == 0) {
  				yyerror("no compression algorithm at %s",
  					sainfo2str(cur_sainfo));
  				return -1;
  			}
  
  			/* duplicate check */
! 			check = getsainfo(cur_sainfo->idsrc, cur_sainfo->iddst);
  			if (check && (!check->idsrc && !cur_sainfo->idsrc)) {
  				yyerror("duplicated sainfo: %s",
  					sainfo2str(cur_sainfo));
  				return -1;
  			}
  			inssainfo(cur_sainfo);
  		}
  		EOC
  	;
  sainfo_name
  	:	ANONYMOUS
  		{
  			cur_sainfo->idsrc = NULL;
  			cur_sainfo->iddst = NULL;
  		}
  	|	sainfo_id sainfo_id
  		{
  			cur_sainfo->idsrc = $1;
  			cur_sainfo->iddst = $2;
  		}
  	;
  sainfo_id
  	:	IDENTIFIERTYPE ADDRSTRING prefix port ul_proto
  		{
  			char portbuf[10];
--- 402,476 ----
  			lcconf->count_persend = $2;
  		}
  		EOS
  	|	RETRY_PHASE1 NUMBER unittype_time
  		{
  			lcconf->retry_checkph1 = $2 * $3;
  		}
  		EOS
  	|	RETRY_PHASE2 NUMBER unittype_time
  		{
  			lcconf->wait_ph2complete = $2 * $3;
  		}
  		EOS
  	;
  
  	/* sainfo */
  sainfo_statement
  	:	SAINFO
  		{
  			cur_sainfo = newsainfo();
  			if (cur_sainfo == NULL) {
  				yyerror("failed to allocate sainfo");
  				return -1;
  			}
  		}
! 		sainfo_name sainfo_peer BOC sainfo_specs
  		{
  			struct sainfo *check;
  
  			/* default */
  			if (cur_sainfo->algs[algclass_ipsec_enc] == 0) {
  				yyerror("no encryption algorithm at %s",
  					sainfo2str(cur_sainfo));
  				return -1;
  			}
  			if (cur_sainfo->algs[algclass_ipsec_auth] == 0) {
  				yyerror("no authentication algorithm at %s",
  					sainfo2str(cur_sainfo));
  				return -1;
  			}
  			if (cur_sainfo->algs[algclass_ipsec_comp] == 0) {
  				yyerror("no compression algorithm at %s",
  					sainfo2str(cur_sainfo));
  				return -1;
  			}
  
  			/* duplicate check */
! 			check = getsainfo(cur_sainfo->idsrc,
! 					  cur_sainfo->iddst,
! 					  cur_sainfo->id_i);
  			if (check && (!check->idsrc && !cur_sainfo->idsrc)) {
  				yyerror("duplicated sainfo: %s",
  					sainfo2str(cur_sainfo));
  				return -1;
  			}
  			inssainfo(cur_sainfo);
  		}
  		EOC
  	;
  sainfo_name
  	:	ANONYMOUS
  		{
  			cur_sainfo->idsrc = NULL;
  			cur_sainfo->iddst = NULL;
  		}
  	|	sainfo_id sainfo_id
  		{
  			cur_sainfo->idsrc = $1;
  			cur_sainfo->iddst = $2;
  		}
  	;
  sainfo_id
  	:	IDENTIFIERTYPE ADDRSTRING prefix port ul_proto
  		{
  			char portbuf[10];
***************
*** 493,542 ****
--- 523,604 ----
  		{
  			struct ipsecdoi_id_b *id_b;
  
  			if ($1 == IDTYPE_ASN1DN) {
  				yyerror("id type forbidden: %d", $1);
  				return -1;
  			}
  
  			$2->l--;
  
  			$$ = vmalloc(sizeof(*id_b) + $2->l);
  			if ($$ == NULL) {
  				yyerror("failed to allocate identifier");
  				return -1;
  			}
  
  			id_b = (struct ipsecdoi_id_b *)$$->v;
  			id_b->type = idtype2doi($1);
  
  			id_b->proto_id = 0;
  			id_b->port = 0;
  
  			memcpy($$->v + sizeof(*id_b), $2->v, $2->l);
  		}
  	;
+ sainfo_peer
+ 	:	/* nothing */
+ 		{
+ 			cur_sainfo->id_i = NULL;
+ 		}
+ 
+ 	|	FROM IDENTIFIERTYPE identifierstring
+ 		{
+ 			struct ipsecdoi_id_b *id_b;
+ 			vchar_t *idv;
+ 
+ 			if (set_identifier(&idv, $2, $3) != 0) {
+ 				yyerror("failed to set identifer.\n");
+ 				return -1;
+ 			}
+ 			cur_sainfo->id_i = vmalloc(sizeof(*id_b) + idv->l);
+ 			if (cur_sainfo->id_i == NULL) {
+ 				yyerror("failed to allocate identifier");
+ 				return -1;
+ 			}
+ 
+ 			id_b = (struct ipsecdoi_id_b *)cur_sainfo->id_i->v;
+ 			id_b->type = idtype2doi($2);
+ 
+ 			id_b->proto_id = 0;
+ 			id_b->port = 0;
+ 
+ 			memcpy(cur_sainfo->id_i->v + sizeof(*id_b),
+ 			       idv->v, idv->l);
+ 			vfree(idv);
+ 		}
+ 	;
  sainfo_specs
  	:	/* nothing */
  	|	sainfo_specs sainfo_spec
  	;
  sainfo_spec
  	:	PFS_GROUP dh_group_num
  		{
  			cur_sainfo->pfs_group = $2;
  		}
  		EOS
  	|	LIFETIME LIFETYPE_TIME NUMBER unittype_time
  		{
  			cur_sainfo->lifetime = $3 * $4;
  		}
  		EOS
  	|	LIFETIME LIFETYPE_BYTE NUMBER unittype_byte
  		{
  #if 1
  			yyerror("byte lifetime support is deprecated");
  			return -1;
  #else
  			cur_sainfo->lifebyte = fix_lifebyte($3 * $4);
  			if (cur_sainfo->lifebyte == 0)
  				return -1;
  #endif
***************
*** 782,832 ****
  				return -1;
  			}
  			cur_rmconf->idvtype = $2;
  		}
  		EOS
  	|	PEERS_IDENTIFIER IDENTIFIERTYPE identifierstring
  		{
  			if (set_identifier(&cur_rmconf->idv_p, $2, $3) != 0) {
  				yyerror("failed to set identifer.\n");
  				return -1;
  			}
  			cur_rmconf->idvtype_p = $2;
  		}
  		EOS
  	|	VERIFY_IDENTIFIER SWITCH { cur_rmconf->verify_identifier = $2; } EOS
  	|	NONCE_SIZE NUMBER { cur_rmconf->nonce_size = $2; } EOS
  	|	DH_GROUP
  		{
  			yyerror("dh_group cannot be defined here.");
  			return -1;
  		}
  		dh_group_num EOS
  	|	KEEPALIVE { cur_rmconf->keepalive = TRUE; } EOS
  	|	PASSIVE SWITCH { cur_rmconf->passive = $2; } EOS
  	|	GENERATE_POLICY SWITCH { cur_rmconf->gen_policy = $2; } EOS
! 	|	SUPPORT_MIP6 SWITCH { cur_rmconf->support_mip6 = $2; } EOS
  	|	INITIAL_CONTACT SWITCH { cur_rmconf->ini_contact = $2; } EOS
  	|	PROPOSAL_CHECK PROPOSAL_CHECK_LEVEL { cur_rmconf->pcheck_level = $2; } EOS
  	|	LIFETIME LIFETYPE_TIME NUMBER unittype_time
  		{
  			prhead->lifetime = $3 * $4;
  		}
  		EOS
  	|	LIFETIME LIFETYPE_BYTE NUMBER unittype_byte
  		{
  #if 1
  			yyerror("byte lifetime support is deprecated");
  			return -1;
  #else
  			yywarn("the lifetime of bytes in phase 1 "
  				"will be ignored at the moment.");
  			prhead->lifebyte = fix_lifebyte($3 * $4);
  			if (prhead->lifebyte == 0)
  				return -1;
  #endif
  		}
  		EOS
  	|	PROPOSAL
  		{
  			struct secprotospec *spspec;
  
--- 844,894 ----
  				return -1;
  			}
  			cur_rmconf->idvtype = $2;
  		}
  		EOS
  	|	PEERS_IDENTIFIER IDENTIFIERTYPE identifierstring
  		{
  			if (set_identifier(&cur_rmconf->idv_p, $2, $3) != 0) {
  				yyerror("failed to set identifer.\n");
  				return -1;
  			}
  			cur_rmconf->idvtype_p = $2;
  		}
  		EOS
  	|	VERIFY_IDENTIFIER SWITCH { cur_rmconf->verify_identifier = $2; } EOS
  	|	NONCE_SIZE NUMBER { cur_rmconf->nonce_size = $2; } EOS
  	|	DH_GROUP
  		{
  			yyerror("dh_group cannot be defined here.");
  			return -1;
  		}
  		dh_group_num EOS
  	|	KEEPALIVE { cur_rmconf->keepalive = TRUE; } EOS
  	|	PASSIVE SWITCH { cur_rmconf->passive = $2; } EOS
  	|	GENERATE_POLICY SWITCH { cur_rmconf->gen_policy = $2; } EOS
! 	|	SUPPORT_PROXY SWITCH { cur_rmconf->support_proxy = $2; } EOS
  	|	INITIAL_CONTACT SWITCH { cur_rmconf->ini_contact = $2; } EOS
  	|	PROPOSAL_CHECK PROPOSAL_CHECK_LEVEL { cur_rmconf->pcheck_level = $2; } EOS
  	|	LIFETIME LIFETYPE_TIME NUMBER unittype_time
  		{
  			prhead->lifetime = $3 * $4;
  		}
  		EOS
  	|	LIFETIME LIFETYPE_BYTE NUMBER unittype_byte
  		{
  #if 1
  			yyerror("byte lifetime support is deprecated");
  			return -1;
  #else
  			yywarn("the lifetime of bytes in phase 1 "
  				"will be ignored at the moment.");
  			prhead->lifebyte = fix_lifebyte($3 * $4);
  			if (prhead->lifebyte == 0)
  				return -1;
  #endif
  		}
  		EOS
  	|	PROPOSAL
  		{
  			struct secprotospec *spspec;
  
***************
*** 1301,1373 ****
  /*
   * fix lifebyte.
   * Must be more than 1024B because its unit is kilobytes.
   * That is defined RFC2407.
   */
  static int
  fix_lifebyte(t)
  	unsigned long t;
  {
  	if (t < 1024) {
  		yyerror("byte size should be more than 1024B.");
  		return 0;
  	}
  
  	return(t / 1024);
  }
  #endif
  
  int
  cfparse()
  {
  	int error;
  
  	yycf_init_buffer();
  
! 	if (yycf_set_buffer(lcconf->racoon_conf) != 0)
  		return -1;
  
  	prhead = NULL;
  
  	error = yyparse();
  	if (error != 0) {
  		if (yyerrorcount) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"fatal parse failure (%d errors)\n",
  				yyerrorcount);
  		} else {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"fatal parse failure.\n");
  		}
  		return -1;
  	}
  
  	if (error == 0 && yyerrorcount) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"parse error is nothing, but yyerrorcount is %d.\n",
  				yyerrorcount);
  		exit(1);
  	}
  
  	yycf_clean_buffer();
  
  	plog(LLV_DEBUG2, LOCATION, NULL, "parse successed.\n");
  
  	return 0;
  }
  
  int
  cfreparse()
  {
  	flushph2();
  	flushph1();
  	flushrmconf();
  	cleanprhead();
  	clean_tmpalgtype();
  	yycf_init_buffer();
  
! 	if (yycf_set_buffer(lcconf->racoon_conf) != 0)
  		return -1;
  
  	return(cfparse());
  }
  
--- 1363,1435 ----
  /*
   * fix lifebyte.
   * Must be more than 1024B because its unit is kilobytes.
   * That is defined RFC2407.
   */
  static int
  fix_lifebyte(t)
  	unsigned long t;
  {
  	if (t < 1024) {
  		yyerror("byte size should be more than 1024B.");
  		return 0;
  	}
  
  	return(t / 1024);
  }
  #endif
  
  int
  cfparse()
  {
  	int error;
  
  	yycf_init_buffer();
  
! 	if (yycf_switch_buffer(lcconf->racoon_conf) != 0)
  		return -1;
  
  	prhead = NULL;
  
  	error = yyparse();
  	if (error != 0) {
  		if (yyerrorcount) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"fatal parse failure (%d errors)\n",
  				yyerrorcount);
  		} else {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"fatal parse failure.\n");
  		}
  		return -1;
  	}
  
  	if (error == 0 && yyerrorcount) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"parse error is nothing, but yyerrorcount is %d.\n",
  				yyerrorcount);
  		exit(1);
  	}
  
  	yycf_clean_buffer();
  
  	plog(LLV_DEBUG2, LOCATION, NULL, "parse successed.\n");
  
  	return 0;
  }
  
  int
  cfreparse()
  {
  	flushph2();
  	flushph1();
  	flushrmconf();
  	cleanprhead();
  	clean_tmpalgtype();
  	yycf_init_buffer();
  
! 	if (yycf_switch_buffer(lcconf->racoon_conf) != 0)
  		return -1;
  
  	return(cfparse());
  }
  
diff -Nr -c25 ac_am/src/racoon/cftoken.l ac_am_fixed/src/racoon/cftoken.l
*** ac_am/src/racoon/cftoken.l	2003-03-04 00:56:56.000000000 +0100
--- ac_am_fixed/src/racoon/cftoken.l	2003-12-11 18:19:59.152055640 +0100
***************
*** 1,93 ****
  /*	$KAME: cftoken.l,v 1.69 2002/09/27 06:03:51 itojun Exp $	*/
  
  %{
  #include <sys/types.h>
  #include <sys/param.h>
  #include <sys/socket.h>
  
  #include <netinet/in.h>
  #include <netinet/ipsec.h>
  
  #include <stdlib.h>
  #include <stdio.h>
  #include <string.h>
  #include <errno.h>
  #include <limits.h>
  #include <ctype.h>
  #ifdef HAVE_STDARG_H
  #include <stdarg.h>
  #else
  #include <varargs.h>
  #endif
  
  #include "var.h"
  #include "misc.h"
  #include "vmbuf.h"
  #include "plog.h"
  #include "debug.h"
  
  #include "algorithm.h"
  #include "cfparse_proto.h"
  #include "cftoken_proto.h"
  #include "localconf.h"
  #include "oakley.h"
  #include "isakmp_var.h"
  #include "isakmp.h"
  #include "ipsec_doi.h"
  #include "proposal.h"
  #ifdef GC
  #include "gcmalloc.h"
  #endif
  
  #ifdef HAVE_CFPARSE_H
  #include "cfparse.h"
  #else
  #include "y.tab.h"
  #endif
  
  int yyerrorcount = 0;
  
  #if defined(YIPS_DEBUG)
  #  define YYDB plog(LLV_DEBUG2, LOCATION, NULL,                                \
  		"begin <%d>%s\n", yy_start, yytext);
  #  define YYD {                                                                \
  	plog(LLV_DEBUG2, LOCATION, NULL, "<%d>%s",                             \
  	    yy_start, loglevel >= LLV_DEBUG2 ? "\n" : "");                     \
  }
  #else
  #  define YYDB
  #  define YYD
  #endif /* defined(YIPS_DEBUG) */
  
  #define MAX_INCLUDE_DEPTH 10
  
  static struct include_stack {
  	char *path;
  	FILE *fp;
! 	YY_BUFFER_STATE state;
  	int lineno;
  } incstack[MAX_INCLUDE_DEPTH];
  static int incstackp = 0;
  
  static int yy_first_time = 1;
  %}
  
  /* common seciton */
  nl		\n
  ws		[ \t]+
  digit		[0-9]
  letter		[A-Za-z]
  hexdigit	[0-9A-Fa-f]
  /*octet		(([01]?{digit}?{digit})|((2([0-4]{digit}))|(25[0-5]))) */
  special		[()+\|\?\*]
  comma		\,
  dot		\.
  slash		\/
  bcl		\{
  ecl		\}
  blcl		\[
  elcl		\]
  percent		\%
  semi		\;
  comment		\#.*
  ccomment	"/*"
--- 1,125 ----
  /*	$KAME: cftoken.l,v 1.69 2002/09/27 06:03:51 itojun Exp $	*/
  
  %{
+ /*
+  * Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002 and 2003 WIDE Project.
+  * All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions
+  * are met:
+  * 1. Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  * 2. Redistributions in binary form must reproduce the above copyright
+  *    notice, this list of conditions and the following disclaimer in the
+  *    documentation and/or other materials provided with the distribution.
+  * 3. Neither the name of the project nor the names of its contributors
+  *    may be used to endorse or promote products derived from this software
+  *    without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+  * SUCH DAMAGE.
+  */
+ 
  #include <sys/types.h>
  #include <sys/param.h>
  #include <sys/socket.h>
  
  #include <netinet/in.h>
  #include <netinet/ipsec.h>
  
  #include <stdlib.h>
  #include <stdio.h>
  #include <string.h>
  #include <errno.h>
  #include <limits.h>
  #include <ctype.h>
+ #include <glob.h>
  #ifdef HAVE_STDARG_H
  #include <stdarg.h>
  #else
  #include <varargs.h>
  #endif
  
  #include "var.h"
  #include "misc.h"
  #include "vmbuf.h"
  #include "plog.h"
  #include "debug.h"
  
  #include "algorithm.h"
  #include "cfparse_proto.h"
  #include "cftoken_proto.h"
  #include "localconf.h"
  #include "oakley.h"
  #include "isakmp_var.h"
  #include "isakmp.h"
  #include "ipsec_doi.h"
  #include "proposal.h"
  #ifdef GC
  #include "gcmalloc.h"
  #endif
  
  #ifdef HAVE_CFPARSE_H
  #include "cfparse.h"
  #else
  #include "y.tab.h"
  #endif
  
  int yyerrorcount = 0;
  
  #if defined(YIPS_DEBUG)
  #  define YYDB plog(LLV_DEBUG2, LOCATION, NULL,                                \
  		"begin <%d>%s\n", yy_start, yytext);
  #  define YYD {                                                                \
  	plog(LLV_DEBUG2, LOCATION, NULL, "<%d>%s",                             \
  	    yy_start, loglevel >= LLV_DEBUG2 ? "\n" : "");                     \
  }
  #else
  #  define YYDB
  #  define YYD
  #endif /* defined(YIPS_DEBUG) */
  
  #define MAX_INCLUDE_DEPTH 10
  
  static struct include_stack {
  	char *path;
  	FILE *fp;
! 	YY_BUFFER_STATE prevstate;
  	int lineno;
+ 	glob_t matches;
+ 	int matchon;
  } incstack[MAX_INCLUDE_DEPTH];
  static int incstackp = 0;
  
  static int yy_first_time = 1;
  %}
  
  /* common seciton */
  nl		\n
  ws		[ \t]+
  digit		[0-9]
  letter		[A-Za-z]
  hexdigit	[0-9A-Fa-f]
  /*octet		(([01]?{digit}?{digit})|((2([0-4]{digit}))|(25[0-5]))) */
  special		[()+\|\?\*]
  comma		\,
  dot		\.
  slash		\/
  bcl		\{
  ecl		\}
  blcl		\[
  elcl		\]
  percent		\%
  semi		\;
  comment		\#.*
  ccomment	"/*"
***************
*** 154,250 ****
  <S_PAD>{ecl}		{ BEGIN S_INI; return(EOC); }
  
  	/* listen */
  <S_INI>listen		{ BEGIN S_LST; YYDB; return(LISTEN); }
  <S_LST>{bcl}		{ return(BOC); }
  <S_LST>isakmp		{ YYD; return(X_ISAKMP); }
  <S_LST>admin		{ YYD; return(X_ADMIN); }
  <S_LST>strict_address	{ YYD; return(STRICT_ADDRESS); }
  <S_LST>{ecl}		{ BEGIN S_INI; return(EOC); }
  
  	/* timer */
  <S_INI>timer		{ BEGIN S_RTRY; YYDB; return(RETRY); }
  <S_RTRY>{bcl}		{ return(BOC); }
  <S_RTRY>counter		{ YYD; return(RETRY_COUNTER); }
  <S_RTRY>interval	{ YYD; return(RETRY_INTERVAL); }
  <S_RTRY>persend		{ YYD; return(RETRY_PERSEND); }
  <S_RTRY>phase1		{ YYD; return(RETRY_PHASE1); }
  <S_RTRY>phase2		{ YYD; return(RETRY_PHASE2); }
  <S_RTRY>{ecl}		{ BEGIN S_INI; return(EOC); }
  
  	/* sainfo */
  <S_INI>sainfo		{ BEGIN S_SAINF; YYDB; return(SAINFO); }
  <S_SAINF>anonymous	{ YYD; return(ANONYMOUS); }
  <S_SAINF>{blcl}any{elcl}	{ YYD; return(PORTANY); }
  <S_SAINF>any		{ YYD; return(ANY); }
  	/* sainfo spec */
  <S_SAINF>{bcl}		{ BEGIN S_SAINFS; return(BOC); }
  <S_SAINF>{semi}		{ BEGIN S_INI; return(EOS); }
  <S_SAINFS>{ecl}		{ BEGIN S_INI; return(EOC); }
  <S_SAINFS>pfs_group	{ YYD; return(PFS_GROUP); }
  <S_SAINFS>identifier	{ YYD; yywarn("it is obsoleted.  use \"my_identifier\"."); return(IDENTIFIER); }
  <S_SAINFS>my_identifier	{ YYD; return(MY_IDENTIFIER); }
  <S_SAINFS>lifetime	{ YYD; return(LIFETIME); }
  <S_SAINFS>time		{ YYD; return(LIFETYPE_TIME); }
  <S_SAINFS>byte		{ YYD; return(LIFETYPE_BYTE); }
  <S_SAINFS>encryption_algorithm { YYD; yylval.num = algclass_ipsec_enc; return(ALGORITHM_CLASS); }
  <S_SAINFS>authentication_algorithm { YYD; yylval.num = algclass_ipsec_auth; return(ALGORITHM_CLASS); }
  <S_SAINFS>compression_algorithm	{ YYD; yylval.num = algclass_ipsec_comp; return(ALGORITHM_CLASS); }
  <S_SAINFS>{comma}	{ YYD; return(COMMA); }
  
  	/* remote */
  <S_INI>remote		{ BEGIN S_RMT; YYDB; return(REMOTE); }
  <S_RMT>anonymous	{ YYD; return(ANONYMOUS); }
  	/* remote spec */
  <S_RMT>{bcl}		{ BEGIN S_RMTS; return(BOC); }
  <S_RMTS>{ecl}		{ BEGIN S_INI; return(EOC); }
  <S_RMTS>exchange_mode	{ YYD; return(EXCHANGE_MODE); }
  <S_RMTS>{comma}		{ YYD; /* XXX ignored, but to be handled. */ ; }
  <S_RMTS>base		{ YYD; yylval.num = ISAKMP_ETYPE_BASE; return(EXCHANGETYPE); }
  <S_RMTS>main		{ YYD; yylval.num = ISAKMP_ETYPE_IDENT; return(EXCHANGETYPE); }
  <S_RMTS>aggressive	{ YYD; yylval.num = ISAKMP_ETYPE_AGG; return(EXCHANGETYPE); }
  <S_RMTS>doi		{ YYD; return(DOI); }
  <S_RMTS>ipsec_doi	{ YYD; yylval.num = IPSEC_DOI; return(DOITYPE); }
  <S_RMTS>situation	{ YYD; return(SITUATION); }
  <S_RMTS>identity_only	{ YYD; yylval.num = IPSECDOI_SIT_IDENTITY_ONLY; return(SITUATIONTYPE); }
  <S_RMTS>secrecy		{ YYD; yylval.num = IPSECDOI_SIT_SECRECY; return(SITUATIONTYPE); }
  <S_RMTS>integrity	{ YYD; yylval.num = IPSECDOI_SIT_INTEGRITY; return(SITUATIONTYPE); }
  <S_RMTS>identifier	{ YYD; yywarn("it is obsoleted.  use \"my_identifier\"."); return(IDENTIFIER); }
  <S_RMTS>my_identifier	{ YYD; return(MY_IDENTIFIER); }
  <S_RMTS>peers_identifier	{ YYD; return(PEERS_IDENTIFIER); }
  <S_RMTS>verify_identifier	{ YYD; return(VERIFY_IDENTIFIER); }
  <S_RMTS>certificate_type	{ YYD; return(CERTIFICATE_TYPE); }
  <S_RMTS>x509		{ YYD; yylval.num = ISAKMP_CERT_X509SIGN; return(CERT_X509); }
  <S_RMTS>peers_certfile	{ YYD; return(PEERS_CERTFILE); }
  <S_RMTS>dnssec		{ YYD; return(DNSSEC); }
  <S_RMTS>verify_cert	{ YYD; return(VERIFY_CERT); }
  <S_RMTS>send_cert	{ YYD; return(SEND_CERT); }
  <S_RMTS>send_cr		{ YYD; return(SEND_CR); }
  <S_RMTS>dh_group	{ YYD; return(DH_GROUP); }
  <S_RMTS>nonce_size	{ YYD; return(NONCE_SIZE); }
  <S_RMTS>generate_policy	{ YYD; return(GENERATE_POLICY); }
! <S_RMTS>support_mip6	{ YYD; return(SUPPORT_MIP6); }
  <S_RMTS>initial_contact	{ YYD; return(INITIAL_CONTACT); }
  <S_RMTS>proposal_check	{ YYD; return(PROPOSAL_CHECK); }
  <S_RMTS>obey		{ YYD; yylval.num = PROP_CHECK_OBEY; return(PROPOSAL_CHECK_LEVEL); }
  <S_RMTS>strict		{ YYD; yylval.num = PROP_CHECK_STRICT; return(PROPOSAL_CHECK_LEVEL); }
  <S_RMTS>exact		{ YYD; yylval.num = PROP_CHECK_EXACT; return(PROPOSAL_CHECK_LEVEL); }
  <S_RMTS>claim		{ YYD; yylval.num = PROP_CHECK_CLAIM; return(PROPOSAL_CHECK_LEVEL); }
  <S_RMTS>keepalive	{ YYD; return(KEEPALIVE); }
  <S_RMTS>passive		{ YYD; return(PASSIVE); }
  <S_RMTS>lifetime	{ YYD; return(LIFETIME); }
  <S_RMTS>time		{ YYD; return(LIFETYPE_TIME); }
  <S_RMTS>byte		{ YYD; return(LIFETYPE_BYTE); }
  	/* remote proposal */
  <S_RMTS>proposal	{ BEGIN S_RMTP; YYDB; return(PROPOSAL); }
  <S_RMTP>{bcl}		{ return(BOC); }
  <S_RMTP>{ecl}		{ BEGIN S_RMTS; return(EOC); }
  <S_RMTP>lifetime	{ YYD; return(LIFETIME); }
  <S_RMTP>time		{ YYD; return(LIFETYPE_TIME); }
  <S_RMTP>byte		{ YYD; return(LIFETYPE_BYTE); }
  <S_RMTP>encryption_algorithm { YYD; yylval.num = algclass_isakmp_enc; return(ALGORITHM_CLASS); }
  <S_RMTP>authentication_method { YYD; yylval.num = algclass_isakmp_ameth; return(ALGORITHM_CLASS); }
  <S_RMTP>hash_algorithm	{ YYD; yylval.num = algclass_isakmp_hash; return(ALGORITHM_CLASS); }
  <S_RMTP>dh_group	{ YYD; return(DH_GROUP); }
  <S_RMTP>gssapi_id	{ YYD; return(GSSAPI_ID); }
  
  	/* parameter */
--- 186,284 ----
  <S_PAD>{ecl}		{ BEGIN S_INI; return(EOC); }
  
  	/* listen */
  <S_INI>listen		{ BEGIN S_LST; YYDB; return(LISTEN); }
  <S_LST>{bcl}		{ return(BOC); }
  <S_LST>isakmp		{ YYD; return(X_ISAKMP); }
  <S_LST>admin		{ YYD; return(X_ADMIN); }
  <S_LST>strict_address	{ YYD; return(STRICT_ADDRESS); }
  <S_LST>{ecl}		{ BEGIN S_INI; return(EOC); }
  
  	/* timer */
  <S_INI>timer		{ BEGIN S_RTRY; YYDB; return(RETRY); }
  <S_RTRY>{bcl}		{ return(BOC); }
  <S_RTRY>counter		{ YYD; return(RETRY_COUNTER); }
  <S_RTRY>interval	{ YYD; return(RETRY_INTERVAL); }
  <S_RTRY>persend		{ YYD; return(RETRY_PERSEND); }
  <S_RTRY>phase1		{ YYD; return(RETRY_PHASE1); }
  <S_RTRY>phase2		{ YYD; return(RETRY_PHASE2); }
  <S_RTRY>{ecl}		{ BEGIN S_INI; return(EOC); }
  
  	/* sainfo */
  <S_INI>sainfo		{ BEGIN S_SAINF; YYDB; return(SAINFO); }
  <S_SAINF>anonymous	{ YYD; return(ANONYMOUS); }
  <S_SAINF>{blcl}any{elcl}	{ YYD; return(PORTANY); }
  <S_SAINF>any		{ YYD; return(ANY); }
+ <S_SAINF>from		{ YYD; return(FROM); }
  	/* sainfo spec */
  <S_SAINF>{bcl}		{ BEGIN S_SAINFS; return(BOC); }
  <S_SAINF>{semi}		{ BEGIN S_INI; return(EOS); }
  <S_SAINFS>{ecl}		{ BEGIN S_INI; return(EOC); }
  <S_SAINFS>pfs_group	{ YYD; return(PFS_GROUP); }
  <S_SAINFS>identifier	{ YYD; yywarn("it is obsoleted.  use \"my_identifier\"."); return(IDENTIFIER); }
  <S_SAINFS>my_identifier	{ YYD; return(MY_IDENTIFIER); }
  <S_SAINFS>lifetime	{ YYD; return(LIFETIME); }
  <S_SAINFS>time		{ YYD; return(LIFETYPE_TIME); }
  <S_SAINFS>byte		{ YYD; return(LIFETYPE_BYTE); }
  <S_SAINFS>encryption_algorithm { YYD; yylval.num = algclass_ipsec_enc; return(ALGORITHM_CLASS); }
  <S_SAINFS>authentication_algorithm { YYD; yylval.num = algclass_ipsec_auth; return(ALGORITHM_CLASS); }
  <S_SAINFS>compression_algorithm	{ YYD; yylval.num = algclass_ipsec_comp; return(ALGORITHM_CLASS); }
  <S_SAINFS>{comma}	{ YYD; return(COMMA); }
  
  	/* remote */
  <S_INI>remote		{ BEGIN S_RMT; YYDB; return(REMOTE); }
  <S_RMT>anonymous	{ YYD; return(ANONYMOUS); }
  	/* remote spec */
  <S_RMT>{bcl}		{ BEGIN S_RMTS; return(BOC); }
  <S_RMTS>{ecl}		{ BEGIN S_INI; return(EOC); }
  <S_RMTS>exchange_mode	{ YYD; return(EXCHANGE_MODE); }
  <S_RMTS>{comma}		{ YYD; /* XXX ignored, but to be handled. */ ; }
  <S_RMTS>base		{ YYD; yylval.num = ISAKMP_ETYPE_BASE; return(EXCHANGETYPE); }
  <S_RMTS>main		{ YYD; yylval.num = ISAKMP_ETYPE_IDENT; return(EXCHANGETYPE); }
  <S_RMTS>aggressive	{ YYD; yylval.num = ISAKMP_ETYPE_AGG; return(EXCHANGETYPE); }
  <S_RMTS>doi		{ YYD; return(DOI); }
  <S_RMTS>ipsec_doi	{ YYD; yylval.num = IPSEC_DOI; return(DOITYPE); }
  <S_RMTS>situation	{ YYD; return(SITUATION); }
  <S_RMTS>identity_only	{ YYD; yylval.num = IPSECDOI_SIT_IDENTITY_ONLY; return(SITUATIONTYPE); }
  <S_RMTS>secrecy		{ YYD; yylval.num = IPSECDOI_SIT_SECRECY; return(SITUATIONTYPE); }
  <S_RMTS>integrity	{ YYD; yylval.num = IPSECDOI_SIT_INTEGRITY; return(SITUATIONTYPE); }
  <S_RMTS>identifier	{ YYD; yywarn("it is obsoleted.  use \"my_identifier\"."); return(IDENTIFIER); }
  <S_RMTS>my_identifier	{ YYD; return(MY_IDENTIFIER); }
  <S_RMTS>peers_identifier	{ YYD; return(PEERS_IDENTIFIER); }
  <S_RMTS>verify_identifier	{ YYD; return(VERIFY_IDENTIFIER); }
  <S_RMTS>certificate_type	{ YYD; return(CERTIFICATE_TYPE); }
  <S_RMTS>x509		{ YYD; yylval.num = ISAKMP_CERT_X509SIGN; return(CERT_X509); }
  <S_RMTS>peers_certfile	{ YYD; return(PEERS_CERTFILE); }
  <S_RMTS>dnssec		{ YYD; return(DNSSEC); }
  <S_RMTS>verify_cert	{ YYD; return(VERIFY_CERT); }
  <S_RMTS>send_cert	{ YYD; return(SEND_CERT); }
  <S_RMTS>send_cr		{ YYD; return(SEND_CR); }
  <S_RMTS>dh_group	{ YYD; return(DH_GROUP); }
  <S_RMTS>nonce_size	{ YYD; return(NONCE_SIZE); }
  <S_RMTS>generate_policy	{ YYD; return(GENERATE_POLICY); }
! <S_RMTS>support_mip6	{ YYD; yywarn("it is obsoleted.  use \"support_proxy\"."); return(SUPPORT_PROXY); }
! <S_RMTS>support_proxy	{ YYD; return(SUPPORT_PROXY); }
  <S_RMTS>initial_contact	{ YYD; return(INITIAL_CONTACT); }
  <S_RMTS>proposal_check	{ YYD; return(PROPOSAL_CHECK); }
  <S_RMTS>obey		{ YYD; yylval.num = PROP_CHECK_OBEY; return(PROPOSAL_CHECK_LEVEL); }
  <S_RMTS>strict		{ YYD; yylval.num = PROP_CHECK_STRICT; return(PROPOSAL_CHECK_LEVEL); }
  <S_RMTS>exact		{ YYD; yylval.num = PROP_CHECK_EXACT; return(PROPOSAL_CHECK_LEVEL); }
  <S_RMTS>claim		{ YYD; yylval.num = PROP_CHECK_CLAIM; return(PROPOSAL_CHECK_LEVEL); }
  <S_RMTS>keepalive	{ YYD; return(KEEPALIVE); }
  <S_RMTS>passive		{ YYD; return(PASSIVE); }
  <S_RMTS>lifetime	{ YYD; return(LIFETIME); }
  <S_RMTS>time		{ YYD; return(LIFETYPE_TIME); }
  <S_RMTS>byte		{ YYD; return(LIFETYPE_BYTE); }
  	/* remote proposal */
  <S_RMTS>proposal	{ BEGIN S_RMTP; YYDB; return(PROPOSAL); }
  <S_RMTP>{bcl}		{ return(BOC); }
  <S_RMTP>{ecl}		{ BEGIN S_RMTS; return(EOC); }
  <S_RMTP>lifetime	{ YYD; return(LIFETIME); }
  <S_RMTP>time		{ YYD; return(LIFETYPE_TIME); }
  <S_RMTP>byte		{ YYD; return(LIFETYPE_BYTE); }
  <S_RMTP>encryption_algorithm { YYD; yylval.num = algclass_isakmp_enc; return(ALGORITHM_CLASS); }
  <S_RMTP>authentication_method { YYD; yylval.num = algclass_isakmp_ameth; return(ALGORITHM_CLASS); }
  <S_RMTP>hash_algorithm	{ YYD; yylval.num = algclass_isakmp_hash; return(ALGORITHM_CLASS); }
  <S_RMTP>dh_group	{ YYD; return(DH_GROUP); }
  <S_RMTP>gssapi_id	{ YYD; return(GSSAPI_ID); }
  
  	/* parameter */
***************
*** 389,443 ****
  
  			yylval.val = vmalloc(yyleng - 1);
  			if (yylval.val == NULL) {
  				yyerror("vmalloc failed");
  				return -1;
  			}
  			memcpy(yylval.val->v, &yytext[1], yylval.val->l);
  
  			return(QUOTEDSTRING);
  		}
  
  {addrstring}	{
  			YYD;
  
  			yylval.val = vmalloc(yyleng + 1);
  			if (yylval.val == NULL) {
  				yyerror("vmalloc failed");
  				return -1;
  			}
  			memcpy(yylval.val->v, yytext, yylval.val->l);
  
  			return(ADDRSTRING);
  		}
  
  <<EOF>>		{
! 			if ( --incstackp < 0 ) {
! 				yyterminate();
  			} else {
! 				yy_delete_buffer(YY_CURRENT_BUFFER);
! 				yy_switch_to_buffer(incstack[incstackp].state);
  			}
  		}
  
  	/* ... */
  {ws}		{ ; }
  {nl}		{ incstack[incstackp].lineno++; }
  {comment}	{ YYD; }
  {semi}		{ return(EOS); }
  .		{ yymore(); }
  
  %%
  
  void
  yyerror(char *s, ...)
  {
  	char fmt[512];
  
  	va_list ap;
  #ifdef HAVE_STDARG_H
  	va_start(ap, s);
  #else
  	va_start(ap);
  #endif
  	snprintf(fmt, sizeof(fmt), "%s:%d: \"%s\" %s\n",
  		incstack[incstackp].path, incstack[incstackp].lineno,
--- 423,492 ----
  
  			yylval.val = vmalloc(yyleng - 1);
  			if (yylval.val == NULL) {
  				yyerror("vmalloc failed");
  				return -1;
  			}
  			memcpy(yylval.val->v, &yytext[1], yylval.val->l);
  
  			return(QUOTEDSTRING);
  		}
  
  {addrstring}	{
  			YYD;
  
  			yylval.val = vmalloc(yyleng + 1);
  			if (yylval.val == NULL) {
  				yyerror("vmalloc failed");
  				return -1;
  			}
  			memcpy(yylval.val->v, yytext, yylval.val->l);
  
  			return(ADDRSTRING);
  		}
  
  <<EOF>>		{
! 			yy_delete_buffer(YY_CURRENT_BUFFER);
! 			incstackp--;
!     nextfile:
! 			if (incstack[incstackp].matchon <
! 			    incstack[incstackp].matches.gl_pathc) {
! 				char* filepath = incstack[incstackp].matches.gl_pathv[incstack[incstackp].matchon];
! 				incstack[incstackp].matchon++;
! 				incstackp++;
! 				if (yycf_set_buffer(filepath) != 0) {
! 					incstackp--;
! 					goto nextfile;
! 				}
! 				yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
! 				BEGIN(S_INI);
  			} else {
! 				globfree(&incstack[incstackp].matches);
! 				if (incstackp == 0)
! 					yyterminate();
! 				else
! 					yy_switch_to_buffer(incstack[incstackp].prevstate);
  			}
  		}
  
  	/* ... */
  {ws}		{ ; }
  {nl}		{ incstack[incstackp].lineno++; }
  {comment}	{ YYD; }
  {semi}		{ return(EOS); }
  .		{ yymore(); }
  
  %%
  
  void
  yyerror(char *s, ...)
  {
  	char fmt[512];
  
  	va_list ap;
  #ifdef HAVE_STDARG_H
  	va_start(ap, s);
  #else
  	va_start(ap);
  #endif
  	snprintf(fmt, sizeof(fmt), "%s:%d: \"%s\" %s\n",
  		incstack[incstackp].path, incstack[incstackp].lineno,
***************
*** 448,534 ****
  	yyerrorcount++;
  }
  
  void
  yywarn(char *s, ...)
  {
  	char fmt[512];
  
  	va_list ap;
  #ifdef HAVE_STDARG_H
  	va_start(ap, s);
  #else
  	va_start(ap);
  #endif
  	snprintf(fmt, sizeof(fmt), "%s:%d: \"%s\" %s\n",
  		incstack[incstackp].path, incstack[incstackp].lineno,
  		yytext, s);
  	plogv(LLV_WARNING, LOCATION, NULL, fmt, ap);
  	va_end(ap);
  }
  
  int
  yycf_switch_buffer(path)
  	char *path;
  {
  	/* got the include file name */
  	if (incstackp >= MAX_INCLUDE_DEPTH) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"Includes nested too deeply");
  		return -1;
  	}
  
! 	incstack[incstackp++].state = YY_CURRENT_BUFFER;
  
! 	if (yycf_set_buffer(path) != 0)
  		return -1;
  
  	yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
  
  	BEGIN(S_INI);
  
  	return 0;
  }
  
  int
  yycf_set_buffer(path)
  	char *path;
  {
  	yyin = fopen(path, "r");
  	if (yyin == NULL) {
  		fprintf(stderr, "failed to open file %s (%s)\n",
  			path, strerror(errno));
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to open file %s (%s)\n",
  			path, strerror(errno));
  		return -1;
  	}
  
  	/* initialize */
  	incstack[incstackp].fp = yyin;
  	incstack[incstackp].path = strdup(path);
  	incstack[incstackp].lineno = 1;
  
  	return 0;
  }
  
  void
  yycf_init_buffer()
  {
  	int i;
  
  	for (i = 0; i < MAX_INCLUDE_DEPTH; i++)
  		memset(&incstack[i], 0, sizeof(incstack[i]));
  	incstackp = 0;
  }
  
  void
  yycf_clean_buffer()
  {
  	int i;
  
  	for (i = 0; i < MAX_INCLUDE_DEPTH; i++) {
  		if (incstack[i].path != NULL) {
  			fclose(incstack[i].fp);
  			racoon_free(incstack[i].path);
  			incstack[i].path = NULL;
  		}
--- 497,604 ----
  	yyerrorcount++;
  }
  
  void
  yywarn(char *s, ...)
  {
  	char fmt[512];
  
  	va_list ap;
  #ifdef HAVE_STDARG_H
  	va_start(ap, s);
  #else
  	va_start(ap);
  #endif
  	snprintf(fmt, sizeof(fmt), "%s:%d: \"%s\" %s\n",
  		incstack[incstackp].path, incstack[incstackp].lineno,
  		yytext, s);
  	plogv(LLV_WARNING, LOCATION, NULL, fmt, ap);
  	va_end(ap);
  }
  
  int
  yycf_switch_buffer(path)
  	char *path;
  {
+ 	char *filepath = NULL;
+ 
  	/* got the include file name */
  	if (incstackp >= MAX_INCLUDE_DEPTH) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"Includes nested too deeply");
  		return -1;
  	}
  
! 	if (glob(path, GLOB_TILDE, NULL, &incstack[incstackp].matches) != 0 ||
! 	    incstack[incstackp].matches.gl_pathc == 0) {
! 		plog(LLV_ERROR, LOCATION, NULL,
! 			"glob found no matches for path");
! 		return -1;
! 	}
! 	incstack[incstackp].matchon = 0;
! 	incstack[incstackp].prevstate = YY_CURRENT_BUFFER;
  
!     nextmatch:
! 	if (incstack[incstackp].matchon >= incstack[incstackp].matches.gl_pathc)
  		return -1;
+ 	filepath =
+ 	    incstack[incstackp].matches.gl_pathv[incstack[incstackp].matchon];
+ 	incstack[incstackp].matchon++;
+ 	incstackp++;
+ 
+ 	if (yycf_set_buffer(filepath) != 0) {
+ 	      incstackp--;
+ 	      goto nextmatch;
+ 	}
  
  	yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
  
  	BEGIN(S_INI);
  
  	return 0;
  }
  
  int
  yycf_set_buffer(path)
  	char *path;
  {
  	yyin = fopen(path, "r");
  	if (yyin == NULL) {
  		fprintf(stderr, "failed to open file %s (%s)\n",
  			path, strerror(errno));
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to open file %s (%s)\n",
  			path, strerror(errno));
  		return -1;
  	}
  
  	/* initialize */
  	incstack[incstackp].fp = yyin;
  	incstack[incstackp].path = strdup(path);
  	incstack[incstackp].lineno = 1;
+ 	plog(LLV_DEBUG, LOCATION, NULL,
+ 		"reading config file %s\n", path, 0);
  
  	return 0;
  }
  
  void
  yycf_init_buffer()
  {
  	int i;
  
  	for (i = 0; i < MAX_INCLUDE_DEPTH; i++)
  		memset(&incstack[i], 0, sizeof(incstack[i]));
  	incstackp = 0;
  }
  
  void
  yycf_clean_buffer()
  {
  	int i;
  
  	for (i = 0; i < MAX_INCLUDE_DEPTH; i++) {
  		if (incstack[i].path != NULL) {
  			fclose(incstack[i].fp);
  			racoon_free(incstack[i].path);
  			incstack[i].path = NULL;
  		}
diff -Nr -c25 ac_am/src/racoon/configure.in ac_am_fixed/src/racoon/configure.in
*** ac_am/src/racoon/configure.in	2003-12-11 18:17:29.589792560 +0100
--- ac_am_fixed/src/racoon/configure.in	2003-12-11 18:30:21.114502976 +0100
***************
*** 308,357 ****
--- 308,358 ----
  		[racoon_cv_advapi="yes"], [racoon_cv_advapi="no"])])
  	AC_MSG_RESULT($racoon_cv_advapi)
  	if test "$racoon_cv_advapi" = yes; then
  		AC_DEFINE(ADVAPI)
  	fi
  fi
  
  AC_MSG_CHECKING(getaddrinfo bug)
  AC_TRY_RUN([
  #include <sys/types.h>
  #include <sys/socket.h>
  #include <netdb.h>
  #include <string.h>
  #include <netinet/in.h>
  
  main()
  {
    int passive, gaierr, inet4 = 0, inet6 = 0;
    struct addrinfo hints, *ai, *aitop;
    char straddr[INET6_ADDRSTRLEN], strport[16];
  
    for (passive = 0; passive <= 1; passive++) {
      memset(&hints, 0, sizeof(hints));
      hints.ai_family = AF_UNSPEC;
      hints.ai_flags = passive ? AI_PASSIVE : 0;
+     hints.ai_protocol = IPPROTO_TCP;
      hints.ai_socktype = SOCK_STREAM;
      if ((gaierr = getaddrinfo(NULL, "54321", &hints, &aitop)) != 0) {
        (void)gai_strerror(gaierr);
        goto bad;
      }
      for (ai = aitop; ai; ai = ai->ai_next) {
        if (ai->ai_addr == NULL ||
            ai->ai_addrlen == 0 ||
            getnameinfo(ai->ai_addr, ai->ai_addrlen,
                        straddr, sizeof(straddr), strport, sizeof(strport),
                        NI_NUMERICHOST|NI_NUMERICSERV) != 0) {
          goto bad;
        }
        switch (ai->ai_family) {
        case AF_INET:
  	if (strcmp(strport, "54321") != 0) {
  	  goto bad;
  	}
          if (passive) {
            if (strcmp(straddr, "0.0.0.0") != 0) {
              goto bad;
            }
          } else {
            if (strcmp(straddr, "127.0.0.1") != 0) {
              goto bad;
diff -Nr -c25 ac_am/src/racoon/configure.in.orig ac_am_fixed/src/racoon/configure.in.orig
*** ac_am/src/racoon/configure.in.orig	1970-01-01 01:00:00.000000000 +0100
--- ac_am_fixed/src/racoon/configure.in.orig	2003-12-11 18:18:10.828523320 +0100
***************
*** 0 ****
--- 1,758 ----
+ 
+ AC_INIT(admin.c)
+ 
+ 
+ AC_PROG_CC
+ AC_PROG_CPP
+ AC_PROG_LEX
+ AC_PROG_YACC
+ AC_PROG_INSTALL
+ AC_PROG_MAKE_SET
+ 
+ AC_CANONICAL_HOST
+ case $host in
+ *netbsd*)
+ 	CFLAGS="-Wl,-R/usr/pkg/lib $CFLAGS" ;;
+ esac
+ 
+ AC_SUBST(OPTFLAG)
+ OPTFLAG="-O -DYIPS_DEBUG"
+ AC_MSG_CHECKING(if --enable-debug option is specified)
+ AC_ARG_ENABLE(debug, [  --enable-debug          build a debug version],
+ 	[OPTFLAG="-g $OPTFLAG"; enable_debug=yes], [enable_debug=no])
+ AC_MSG_RESULT($enable_debug)
+ 
+ AC_SUBST(DEBUGRMOBJS)
+ AC_MSG_CHECKING(if --enable-debugrm option is specified)
+ AC_ARG_ENABLE(debugrm, [  --enable-debugrm        build with the memory allocation recorder],
+ 	[OPTFLAG="-DDEBUG_RECORD_MALLOCATION $OPTFLAG"; enable_debugrm=yes],
+ 	[enable_debugrm=no])
+ if test "$enable_debugrm" != "no"; then
+ 	DEBUGRMOBJS="debugrm.o"
+ fi
+ AC_MSG_RESULT($enable_debugrm)
+ 
+ AC_MSG_CHECKING(if --enable-yydebug option is specified)
+ AC_ARG_ENABLE(yydebug, [  --enable-yydebug        build a yydebug version],
+ 	[AC_DEFINE(YYDEBUG)
+ 	enable_yydebug=yes], [enable_yydebug=no])
+ AC_MSG_RESULT($enable_yydebug)
+ 
+ OPTFLAG="-Wall -Wmissing-prototypes -Wmissing-declarations $OPTFLAG"
+ AC_MSG_CHECKING(if --enable-pedant option is specified)
+ AC_ARG_ENABLE(pedant, [  --enable-pedant         pedantic compiler options],
+ 	[OPTFLAG="-Werror $OPTFLAG"; enable_pedant=yes],
+ 	[enable_pedant=no])
+ AC_MSG_RESULT($enable_pedant)
+ 
+ AC_MSG_CHECKING(if --enable-adminport option is specified)
+ AC_ARG_ENABLE(adminport,
+ 	[  --enable-adminport      enable admin port (INSECURE!)],
+ 	[], [enable_adminport=no])
+ if test $enable_adminport = "yes"; then
+ 	AC_DEFINE(ENABLE_ADMINPORT)
+ fi
+ AC_MSG_RESULT($enable_adminport)
+ 
+ AC_MSG_CHECKING(if --enable-rc5 option is specified)
+ AC_ARG_ENABLE(rc5,
+ 	[  --enable-rc5            enable RC5 encryption (patented)],
+ 	[], [enable_rc5=no])
+ AC_MSG_RESULT($enable_rc5)
+ 
+ AC_MSG_CHECKING(if --enable-idea option is specified)
+ AC_ARG_ENABLE(idea,
+ 	[  --enable-idea           enable IDEA encryption (patented)],
+ 	[], [enable_idea=no])
+ AC_MSG_RESULT($enable_idea)
+ 
+ AC_MSG_CHECKING(if --enable-gssapi option is specified)
+ AC_ARG_ENABLE(rc5,
+         [  --enable-gssapi         enable GSS-API authentication],
+         [], [enable_gssapi=no])
+ if test "x$enable_gssapi" = "xyes"; then
+ 	AC_DEFINE(HAVE_GSSAPI)
+ fi
+ AC_MSG_RESULT($enable_gssapi)
+ 
+ AC_MSG_CHECKING(if --enable-stats option is specified)
+ AC_ARG_ENABLE(stats,
+         [  --enable-stats          enable statistics logging function],
+         [], [enable_stats=no])
+ if test "x$enable_stats" = "xyes"; then
+ 	AC_DEFINE(ENABLE_STATS)
+ fi
+ AC_MSG_RESULT($enable_stats)
+ 
+ AC_MSG_CHECKING(if --enable-samode-unspec option is specified)
+ AC_ARG_ENABLE(samode-unspec,
+         [  --enable-samode-unspec  enable to use unspecified a mode of SA],
+         [], [enable_samode_unspec=no])
+ if test "x$enable_samode_unspec" = "xyes"; then
+ 	AC_DEFINE(ENABLE_SAMODE_UNSPECIFIED)
+ fi
+ AC_MSG_RESULT($enable_samode_unspec)
+ 
+ efence_dir=
+ AC_MSG_CHECKING(if --with-efence option is specified)
+ AC_ARG_WITH(efence, [  --with-efence=DIR       specify ElectricFence directory],
+ 	[efence_dir=$withval], [efence_dir=no])
+ AC_MSG_RESULT(${efence_dir})
+ if test "$efence_dir" != "no"; then
+ 	if test "x$efence_dir" = "x"; then
+ 		RACOON_PATH_LIBS(EF_Print, efence)
+ 	else
+ 		RACOON_PATH_LIBS(EF_Print, efence, $efence_dir)
+ 	fi
+ fi
+ 
+ gc_dir=
+ AC_MSG_CHECKING(if --with-gc option is specified)
+ AC_ARG_WITH(gc, [  --with-gc=DIR           specify Bohem GC directory (experimental)],
+ 	[gc_dir=$withval], [gc_dir=no])
+ AC_MSG_RESULT(${gc_dir})
+ if test "$gc_dir" != "no"; then
+ 	AC_DEFINE(GC)
+ 	if test "x$gc_dir" = "x"; then
+ 		RACOON_PATH_LIBS(GC_malloc, leak)
+ 	else
+ 		RACOON_PATH_LIBS(GC_malloc, leak, $gc_dir)
+ 	fi
+ fi
+ 
+ dmalloc_dir=
+ AC_MSG_CHECKING(if --with-dmalloc option is specified)
+ AC_ARG_WITH(dmalloc, [  --with-dmalloc=DIR      specify Dmalloc directory],
+ 	[dmalloc_dir=$withval], [dmalloc_dir=no])
+ AC_MSG_RESULT(${dmalloc_dir})
+ if test "$dmalloc_dir" != "no"; then
+ 	AC_DEFINE(DMALLOC)
+ 	if test "x$dmalloc_dir" = "x"; then
+ 		RACOON_PATH_LIBS(dmalloc_log_unfreed, dmalloc)
+ 	else
+ 		RACOON_PATH_LIBS(dmalloc_log_unfreed, dmalloc, $dmalloc_dir)
+ 	fi
+ fi
+ 
+ AC_MSG_CHECKING(if you have KAME tcpdump in $srcdir/../tcpdump)
+ if test -f "$srcdir/../tcpdump/print-isakmp.c"; then
+ 	AC_LIBOBJ([print-isakmp])
+ 	AC_DEFINE(HAVE_PRINT_ISAKMP_C)
+ 	AC_MSG_RESULT(yes)
+ else
+ 	AC_MSG_RESULT(no)
+ fi
+ 
+ AC_MSG_CHECKING(if __func__ is available)
+ AC_TRY_COMPILE(
+ [#include <stdio.h>
+ ], [char *x = __func__;],
+ 	[AC_DEFINE(HAVE_FUNC_MACRO)
+ 	AC_MSG_RESULT(yes)],
+ 	[AC_MSG_RESULT(no)])
+ 
+ 
+ AC_MSG_CHECKING([whether to enable ipv6])
+ AC_ARG_ENABLE(ipv6,
+ [  --enable-ipv6           Enable ipv6 (with ipv4) support
+   --disable-ipv6          Disable ipv6 support],
+ [ case "$enableval" in
+   no)
+        AC_MSG_RESULT(no)
+        ipv6=no
+        ;;
+   *)   AC_MSG_RESULT(yes)
+        AC_DEFINE(INET6)
+        ipv6=yes
+        ;;
+   esac ],
+ 
+   AC_TRY_RUN([ /* AF_INET6 avalable check */
+ #include <sys/types.h>
+ #include <sys/socket.h>
+ main()
+ {
+   exit(0);
+  if (socket(AF_INET6, SOCK_STREAM, 0) < 0)
+    exit(1);
+  else
+    exit(0);
+ }
+ ],
+   AC_MSG_RESULT(yes)
+   AC_DEFINE(ENABLE_IPV6)
+   ipv6=yes,
+   AC_MSG_RESULT(no)
+   ipv6=no,
+   AC_MSG_RESULT(no)
+   ipv6=no
+ ))
+ 
+ ipv6type=unknown
+ ipv6lib=none
+ ipv6libdir=none
+ 
+ if test "$ipv6" = "yes"; then
+ 	AC_MSG_CHECKING([ipv6 stack type])
+ 	for i in inria kame linux toshiba v6d zeta; do
+ 		ipv6trylibc=no
+ 		case $i in
+ 		inria)
+ 			
+ 			AC_EGREP_CPP(yes, [
+ #include <netinet/in.h>
+ #ifdef IPV6_INRIA_VERSION
+ yes
+ #endif],
+ 				[ipv6type=$i;
+ 				ipv6lib=inet6;
+ 				ipv6libdir=/usr/lib;
+ 				ipv6trylibc=yes
+ 				CPPFLAGS="-DINET6 $CPPFLAGS"])
+ 			;;
+ 		kame)
+ 			
+ 			AC_EGREP_CPP(yes, [
+ #include <netinet/in.h>
+ #ifdef __KAME__
+ yes
+ #endif],
+ 				[ipv6type=$i;
+ 				ipv6lib=inet6;
+ 				ipv6libdir=/usr/local/v6/lib;
+ 				ipv6trylibc=yes
+ 				CPPFLAGS="-DINET6 $CPPFLAGS"])
+ 			;;
+ 		linux)
+ 			
+ 			if test -d /usr/inet6; then
+ 				ipv6type=$i
+ 				ipv6lib=inet6
+ 				ipv6libdir=/usr/inet6/lib
+ 				LIBS="$LIBS -lresolv"
+ 				CPPFLAGS="-DINET6 -I/usr/inet6/include $CPPFLAGS"
+ 			else
+ 				ipv6type=$i
+ 				ipv6trylibc=yes
+ 				LIBS="$LIBS -lresolv"
+ 
+ 				CPPFLAGS="-DINET6 -DIPV6_INRIA_VERSION $CPPFLAGS"
+ 			fi
+ 			;;
+ 		toshiba)
+ 			AC_EGREP_CPP(yes, [
+ #include <sys/param.h>
+ #ifdef _TOSHIBA_INET6
+ yes
+ #endif],
+ 				[ipv6type=$i;
+ 				ipv6lib=inet6;
+ 				ipv6libdir=/usr/local/v6/lib;
+ 				CPPFLAGS="-DINET6 $CPPFLAGS"])
+ 			;;
+ 		v6d)
+ 			AC_EGREP_CPP(yes, [
+ #include </usr/local/v6/include/sys/v6config.h>
+ #ifdef __V6D__
+ yes
+ #endif],
+ 				[ipv6type=$i;
+ 				ipv6lib=v6;
+ 				ipv6libdir=/usr/local/v6/lib;
+ 				CPPFLAGS="-I/usr/local/v6/include $CPPFLAGS"])
+ 			;;
+ 		zeta)
+ 			AC_EGREP_CPP(yes, [
+ #include <sys/param.h>
+ #ifdef _ZETA_MINAMI_INET6
+ yes
+ #endif],
+ 				[ipv6type=$i;
+ 				ipv6lib=inet6;
+ 				ipv6libdir=/usr/local/v6/lib;
+ 				CPPFLAGS="-DINET6 $CPPFLAGS"])
+ 			;;
+ 		esac
+ 		if test "$ipv6type" != "unknown"; then
+ 			break
+ 		fi
+ 	done
+ 	AC_MSG_RESULT($ipv6type)
+ fi
+ 
+ if test "$ipv6" = "yes" -a "$ipv6lib" != "none"; then
+ 	if test -d $ipv6libdir -a -f $ipv6libdir/lib$ipv6lib.a; then
+ 		echo "using lib$ipv6lib for getaddrinfo"
+ 		LIBS="$LIBS -L$ipv6libdir -l$ipv6lib"
+ 	else
+ 		if test "$ipv6trylibc" = "yes"; then
+ 			echo 'using libc for getaddrinfo'
+ 		else
+ 			echo "Fatal: no $ipv6lib library found.  "
+ 			echo "cannot continue.  You need to fetch lib$ipv6lib.a "
+ 			echo "from appropriate ipv6 kit and compile beforehand."
+ 			exit 1
+ 		fi
+ 	fi
+ fi
+ 
+ if test "$ipv6" = "yes"; then
+ 	AC_MSG_CHECKING(for advanced API support)
+ 	AC_CACHE_VAL(racoon_cv_advapi, [
+ 	AC_TRY_COMPILE([#ifndef INET6
+ #define INET6
+ #endif
+ #include <sys/types.h>
+ #include <netinet/in.h>],
+ 		[struct in6_pktinfo a;],
+ 		[racoon_cv_advapi="yes"], [racoon_cv_advapi="no"])])
+ 	AC_MSG_RESULT($racoon_cv_advapi)
+ 	if test "$racoon_cv_advapi" = yes; then
+ 		AC_DEFINE(ADVAPI)
+ 	fi
+ fi
+ 
+ AC_MSG_CHECKING(getaddrinfo bug)
+ AC_TRY_RUN([
+ #include <sys/types.h>
+ #include <sys/socket.h>
+ #include <netdb.h>
+ #include <string.h>
+ #include <netinet/in.h>
+ 
+ main()
+ {
+   int passive, gaierr, inet4 = 0, inet6 = 0;
+   struct addrinfo hints, *ai, *aitop;
+   char straddr[INET6_ADDRSTRLEN], strport[16];
+ 
+   for (passive = 0; passive <= 1; passive++) {
+     memset(&hints, 0, sizeof(hints));
+     hints.ai_family = AF_UNSPEC;
+     hints.ai_flags = passive ? AI_PASSIVE : 0;
+     hints.ai_socktype = SOCK_STREAM;
+     if ((gaierr = getaddrinfo(NULL, "54321", &hints, &aitop)) != 0) {
+       (void)gai_strerror(gaierr);
+       goto bad;
+     }
+     for (ai = aitop; ai; ai = ai->ai_next) {
+       if (ai->ai_addr == NULL ||
+           ai->ai_addrlen == 0 ||
+           getnameinfo(ai->ai_addr, ai->ai_addrlen,
+                       straddr, sizeof(straddr), strport, sizeof(strport),
+                       NI_NUMERICHOST|NI_NUMERICSERV) != 0) {
+         goto bad;
+       }
+       switch (ai->ai_family) {
+       case AF_INET:
+ 	if (strcmp(strport, "54321") != 0) {
+ 	  goto bad;
+ 	}
+         if (passive) {
+           if (strcmp(straddr, "0.0.0.0") != 0) {
+             goto bad;
+           }
+         } else {
+           if (strcmp(straddr, "127.0.0.1") != 0) {
+             goto bad;
+           }
+         }
+         inet4++;
+         break;
+       case AF_INET6:
+ 	if (strcmp(strport, "54321") != 0) {
+ 	  goto bad;
+ 	}
+         if (passive) {
+           if (strcmp(straddr, "::") != 0) {
+             goto bad;
+           }
+         } else {
+           if (strcmp(straddr, "::1") != 0) {
+             goto bad;
+           }
+         }
+         inet6++;
+         break;
+       case AF_UNSPEC:
+         goto bad;
+         break;
+       default:
+         /* another family support? */
+         break;
+       }
+     }
+   }
+ 
+   if (!(inet4 == 0 || inet4 == 2))
+     goto bad;
+   if (!(inet6 == 0 || inet6 == 2))
+     goto bad;
+ 
+   if (aitop)
+     freeaddrinfo(aitop);
+   exit(0);
+ 
+  bad:
+   if (aitop)
+     freeaddrinfo(aitop);
+   exit(1);
+ }
+ ],
+ AC_MSG_RESULT(good)
+ buggygetaddrinfo=no,
+ AC_MSG_RESULT(buggy)
+ buggygetaddrinfo=yes,
+ AC_MSG_RESULT(buggy)
+ buggygetaddrinfo=yes)
+ 
+ if test "$buggygetaddrinfo" = "yes"; then
+ 	if test "$ipv6" = "yes"; then
+ 		echo 'Fatal: You must get working getaddrinfo() function.'
+ 		echo '       or you can specify "--disable-ipv6"'.
+ 		exit 1
+ 	else
+ 		CPPFLAGS="$CPPFLAGS -I${srcdir}/missing"
+ 	fi
+ fi
+ AC_REPLACE_FUNCS(getaddrinfo getnameinfo)
+ 
+ AC_MSG_CHECKING(if --with-ssleay option is specified)
+ AC_ARG_WITH(ssleay, [  --with-ssleay=DIR       specify SSLeay directory],
+ 	[crypto_dir=$withval])
+ AC_MSG_RESULT(${crypto_dir-"default"})
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ if test "x$crypto_dir" = "x"; then
+ 	case $host_os in
+ 	netbsd*)	crypto_dir="/usr/pkg";;
+ 	freebsd*)
+ 		if test -d /usr/local/ssl; then
+ 			crypto_dir="/usr/local/ssl"
+ 		else
+ 			crypto_dir="/usr/local"
+ 		fi
+ 		;;
+ 	esac
+ else
+ 	LIBS="$LIBS -L${crypto_dir}/lib"
+ 	CPPFLAGS="-I${crypto_dir}/include $CPPFLAGS"
+ fi
+ 
+ AC_PATH_PROG(KRB5_CONFIG,krb5-config,no)
+ 
+ if test "x$krb5_incdir" = "x"; then
+ 	case $host_os in
+ 	netbsd*)	krb5_incdir="-I/usr/include/krb5";;
+ 	linux*)
+ 			if test "$KRB5_CONFIG" != "no"; then
+ 			   krb5_incdir="`$KRB5_CONFIG --cflags gssapi`"
+ 			fi
+ 			;;
+ 	esac
+ else
+ 	krb5_incdir="-I$krb5_incdir"
+ fi
+ if test "x$krb5_libs" = "x"; then
+ 	case $host_os in
+ 	netbsd*)	krb5_libs="-lgssapi -lkrb5 -lcom_err -lroken -lasn1";;
+ 	freebsd*)       krb5_libs="-lgssapi -lkrb5 -lcom_err -lroken -lasn1 -lcrypt";;
+ 	linux*)
+ 			if test "$KRB5_CONFIG" != "no"; then
+ 			   krb5_libs="`$KRB5_CONFIG --libs gssapi`"
+ 			fi
+ 			;;
+ 	esac
+ fi
+ if test "$enable_gssapi" = "yes"; then
+ 	case $host_os in
+ 	netbsd*|linux*)
+ 		LIBS="$LIBS $krb5_libs"
+ 		CPPFLAGS="$krb5_incdir $CPPFLAGS"
+ 		;;
+ 	esac
+ fi
+ 
+ 
+ RACOON_PATH_LIBS(CAST_cfb64_encrypt, crypto, ${crypto_dir}/lib)
+ AC_TRY_COMPILE([#include <sys/types.h>
+ #include <stdio.h>
+ #include <openssl/bn.h>
+ #include <openssl/dh.h>
+ #include <openssl/md5.h>
+ #include <openssl/sha.h>
+ #include <openssl/des.h>], [], [], [openssl_compile_failed=yes])
+ 
+ if test "x$openssl_compile_failed" = "xyes"; then
+ 	echo
+ 	echo "Fatal: crypto library and headers not found."
+ 	echo Specify proper directory by using --with-ssleay.
+ 	if test `uname -s` = FreeBSD; then
+ 		echo Use ports/security/SSLeay to install SSLeay, or visit
+ 	elif test `uname -s` = NetBSD; then
+ 		echo Use pkgsrc/security/SSLeay to install SSLeay, or visit
+ 	else
+ 		echo -n "Visit "
+ 	fi
+ 	echo ftp://psych.psy.uq.oz.au/pub/Crypto/SSL/, or visit
+ 	echo http://www.openssl.org/
+ 	exit 1
+ fi
+ 
+ 
+ AC_MSG_CHECKING(openssl version)
+ AC_EGREP_CPP(yes, [#include <openssl/opensslv.h>
+ #if OPENSSL_VERSION_NUMBER >= 0x00904100L
+ yes
+ #endif], [AC_MSG_RESULT(ok)], [AC_MSG_RESULT(too old)
+ 	echo
+ 	echo "FATAL: OpenSSL version must be 0.9.4 or higher."
+ 	exit 1])
+ 
+ 
+ AC_CHECK_LIB(ssl, ssl_ok, [], [], -lcrypto)
+ 
+ AC_CHECK_LIB(crypto, des_cbc_encrypt)
+ AC_CHECK_LIB(l, yywrap)
+ AC_CHECK_LIB(y, yyerror)
+ 
+ 
+ AC_MSG_CHECKING(for PF_KEYv2 support)
+ AC_CACHE_VAL(ac_cv_pfkey, [
+ AC_TRY_COMPILE([
+ #include <sys/types.h>
+ #include <sys/socket.h>
+ #include <net/pfkeyv2.h>],
+         [int x = PF_KEY, y = PF_KEY_V2;],
+         [ac_cv_pfkey="yes"], [ac_cv_pfkey="no"])])
+ AC_MSG_RESULT($ac_cv_pfkey)
+ if test "$ac_cv_pfkey" = yes; then
+         OPTFLAG="-DHAVE_PFKEYV2 $OPTFLAG"
+ fi
+ 
+ 
+ if test "$ac_cv_pfkey" = "yes"; then
+ 	AC_MSG_CHECKING(for old KAME PF_KEYv2 header file)
+ 	AC_TRY_COMPILE([
+ #include <sys/types.h>
+ #include <sys/socket.h>
+ #include <net/pfkeyv2.h>],
+ 		[struct sadb_msg m; m.sadb_msg_reserved2 = 0;],
+ 		[AC_MSG_RESULT(old)
+ 		echo "FATAL: obsolete KAME PF_KEYv2 declaration (non-PF_KEY sadb_msg)"
+ 		exit 1])
+ 	AC_TRY_COMPILE([
+ #include <sys/types.h>
+ #include <sys/socket.h>
+ #include <net/pfkeyv2.h>],
+ 		[struct sadb_x_policy m; m.sadb_x_policy_id = 0;], [],
+ 		[AC_MSG_RESULT(old)
+ 		echo "FATAL: obsolete KAME PF_KEYv2 declaration (no sadb_x_policy_id)"
+ 		exit 1])
+ 	AC_TRY_COMPILE([
+ #include <sys/types.h>
+ #include <sys/socket.h>
+ #include <net/pfkeyv2.h>],
+ 		[struct sadb_x_sa2 m;], [],
+ 		[AC_MSG_RESULT(old)
+ 		echo "FATAL: obsolete KAME PF_KEYv2 declaration (no sadb_x_sa2)"
+ 		exit 1])
+ 	AC_MSG_RESULT(fine)
+ fi
+ 
+ ipsectype=unknown
+ ipseclib=none
+ ipseclibdir=none
+ AC_MSG_CHECKING([ipsec library path])
+ for i in linux inria kame; do
+ 	ipsectrylibc=no
+ 	case $i in
+ 	inria)
+ 		
+ 		AC_EGREP_CPP(yes, [
+ #include <netinet/in.h>
+ #ifdef IPV6_INRIA_VERSION
+ yes
+ #endif],
+ 			[ipsectype=$i;
+ 			ipseclib=ipsec;
+ 			ipseclibdir=/usr/lib])
+ 		;;
+ 	kame)
+ 		
+ 		AC_EGREP_CPP(yes, [
+ #include <netinet/in.h>
+ #ifdef __KAME__
+ yes
+ #endif],
+ 			[ipsectype=$i;
+ 			ipseclib=ipsec;
+ 			ipseclibdir=/usr/local/v6/lib])
+ 		;;
+ 	linux)
+ 		AC_EGREP_CPP(yes, [
+ #include <netinet/in.h>
+ #ifdef __linux__
+ yes
+ #endif],
+ 			[ipseclib=ipsec;
+ 			ipseclibdir=../libipsec/.libs
+ 			LD_LIBRARY_PATH="../libipsec/.libs:$LD_LIBRARY_PATH"
+ 			export LD_LIBRARY_PATH
+ 			ipsectype=$i])
+ 		;;
+ 	esac
+ 	if test "$ipsectype" != "unknown"; then
+ 		break
+ 	fi
+ done
+ AC_MSG_RESULT($ipseclibdir)
+ 
+ AC_MSG_CHECKING(if --with-libpfkey option is specified)
+ AC_ARG_WITH(libpfkey, [  --with-libpfkey=DIR     specify libpfkey.a dir],
+ 	[libpfkey_dir=$withval], [libpfkey_dir=no])
+ AC_MSG_RESULT(${libpfkey_dir})
+ if test "$libpfkey_dir" != "no"; then
+ 	if test "x$libpfkey_dir" = "x"; then
+ 		RACOON_PATH_LIBS(pfkey_send_spdsetidx, pfkey)
+ 	else
+ 		RACOON_PATH_LIBS(pfkey_send_spdsetidx, pfkey, $libpfkey_dir)
+ 	fi
+ fi
+ 
+ AC_MSG_CHECKING(if --with-liblwres option is specified)
+ AC_ARG_WITH(liblwres, [  --with-lwres=DIR        specify liblwres path (like /usr/pkg)],
+ 	[liblwres_dir=$withval], [liblwres_dir=no])
+ AC_MSG_RESULT(${liblwres_dir})
+ if test "$liblwres_dir" != "no"; then
+ 	if test -d "$liblwres_dir/lib" -a -d "$liblwres_dir/lib"; then
+ 		if test "x$liblwres_dir" = "x"; then
+ 			RACOON_PATH_LIBS(lwres_getrrsetbyname, lwres)
+ 		else
+ 			RACOON_PATH_LIBS(lwres_getrrsetbyname, lwres, "$liblwres_dir/lib")
+ 		fi
+ 		CFLAGS="$CFLAGS -I$liblwres_dir/include"
+ 		AC_CHECK_FUNCS(lwres_getrrsetbyname)
+ 	else
+ 		echo "FATAL: $liblwres_dir/lib or $liblwres_dir/include not found"
+ 		exit 1
+ 	fi
+ fi
+ AC_CHECK_FUNCS(getrrsetbyname)
+ 
+ 
+ AC_HEADER_STDC
+ AC_HEADER_SYS_WAIT
+ AC_CHECK_HEADERS(limits.h sys/time.h unistd.h stdarg.h varargs.h)
+ signing=yes
+ if test "$enable_rc5" = "yes"; then
+ 	rc5header=openssl/rc5.h
+ else
+ 	rc5header=
+ fi
+ if test "$enable_idea" = "yes"; then
+ 	ideaheader=openssl/idea.h
+ else
+ 	ideaheader=
+ fi
+ AC_CHECK_HEADERS($ideaheader $rc5header openssl/rsa.h openssl/pem.h openssl/evp.h openssl/x509.h,
+ 	[], [nosymbol=`echo $ac_hdr | sed -e 's/.h$//' -e 's/^openssl.//' -e 's/^/NO_/' | tr 'a-z' 'A-Z'`
+ 	CPPFLAGS="$CPPFLAGS -D$nosymbol=1"
+ 	signing=no])
+ if test $signing = "yes"; then
+ 	AC_DEFINE(HAVE_SIGNING_C)
+ fi
+ AC_CHECK_HEADERS(openssl/cversion.h openssl/opensslv.h)
+ 
+ 
+ AC_SUBST(CRYPTOBJS)
+ AC_CHECK_HEADER(openssl/rijndael.h, [], [
+ 	CPPFLAGS="$CPPFLAGS -I${srcdir}/missing"
+ 	CRYPTOBJS="$CRYPTOBJS rijndael-api-fst.o rijndael-alg-fst.o"
+ ])
+ 
+ 
+ AC_SUBST(CRYPTOBJS)
+ AC_CHECK_HEADER(openssl/sha2.h, [], [
+ 	CPPFLAGS="$CPPFLAGS -I${srcdir}/missing"
+ 	CRYPTOBJS="$CRYPTOBJS sha2.o"
+ ])
+ 
+ 
+ AC_C_CONST
+ AC_TYPE_PID_T
+ AC_TYPE_SIZE_T
+ AC_HEADER_TIME
+ AC_STRUCT_TM
+ 
+ 
+ AC_FUNC_MEMCMP
+ AC_TYPE_SIGNAL
+ AC_FUNC_VPRINTF
+ AC_CHECK_FUNCS(gettimeofday select socket strerror strtol strtoul strlcpy)
+ AC_REPLACE_FUNCS(strdup)
+ 
+ 
+ if test "x$prefix" = xNONE; then
+ 	sysconfdir_x=`echo $sysconfdir | sed -e 's,${prefix},'"$ac_default_prefix,"`
+ else
+ 	sysconfdir_x=`echo $sysconfdir | sed -e 's,${prefix},'"$prefix,"`
+ 
+ fi
+ AC_SUBST(sysconfdir_x)
+ 
+ 
+ AC_CHECK_FUNCS(getifaddrs)
+ 
+ 
+ AC_REPLACE_FUNCS(arc4random)
+ 
+ 
+ AC_MSG_CHECKING(if --with-pkgversion option is specified)
+ AC_ARG_WITH(pkgversion, [  --with-pkgversion=VERSION   specify package version],
+ 	[AC_MSG_RESULT($withval)
+ 	CPPFLAGS="$CPPFLAGS -DRACOON_PKG_VERSION=\"\\\"$withval\\\"\""],
+ 	[AC_MSG_RESULT(no)
+ 	pkgversion=no])
+ 
+ 
+ 
+ if test "$ipseclib" != "none"; then
+    if test "$ipsectype" != "linux"; then
+ 	if test "$ipseclibdir" != "none"; then
+ 		RACOON_PATH_LIBS(ipsec_strerror, $ipseclib, $ipseclibdir)
+ 	else
+ 		RACOON_PATH_LIBS(ipsec_strerror, $ipseclib)
+ 	fi
+     else
+ 	LIBS="$LIBS -l$ipseclib"
+ 	if test "$ipseclibdir" != "none"; then
+ 	    LDFLAGS="$LDFLAGS -L$ipseclibdir"
+ 	fi
+     fi
+ fi
+ 
+ if test "$ipsectype" != "linux"; then
+     INSTALL_OPTS="-o bin -g bin"
+ else
+     AC_CHECK_HEADER(net/pfkeyv2.h, [have_net_pfkey=yes], [have_net_pfkey=no])
+     AC_CHECK_HEADER(netinet/ipsec.h, [have_netinet_ipsec=yes],
+ 				     [have_netinet_ipsec=no])
+ 
+     if test "$have_net_pfkey$have_netinet_ipsec" = nono; then
+ 	CPPFLAGS="-I${srcdir}/../include-glibc -I../include-glibc -include ${srcdir}/../include-glibc/glibc-bugs.h $CPPFLAGS"
+     fi
+ fi
+ AC_SUBST(INSTALL_OPTS)
+ 
+ AC_OUTPUT(Makefile samples/psk.txt samples/racoon.conf)
diff -Nr -c25 ac_am/src/racoon/crypto_openssl.c ac_am_fixed/src/racoon/crypto_openssl.c
*** ac_am/src/racoon/crypto_openssl.c	2003-03-04 00:56:56.000000000 +0100
--- ac_am_fixed/src/racoon/crypto_openssl.c	2003-12-11 18:19:59.162054120 +0100
***************
*** 34,112 ****
--- 34,120 ----
  
  #include <stdlib.h>
  #include <stdio.h>
  #include <limits.h>
  #include <string.h>
  
  /* get openssl/ssleay version number */
  #ifdef HAVE_OPENSSL_OPENSSLV_H
  # include <openssl/opensslv.h>
  #else
  # error no opensslv.h found.
  #endif
  
  #ifndef OPENSSL_VERSION_NUMBER
  #error OPENSSL_VERSION_NUMBER is not defined. OpenSSL0.9.4 or later required.
  #endif
  
  #ifdef HAVE_OPENSSL_PEM_H
  #include <openssl/pem.h>
  #endif
  #ifdef HAVE_OPENSSL_EVP_H
  #include <openssl/evp.h>
  #endif
  #ifdef HAVE_OPENSSL_X509_H
  #include <openssl/x509.h>
+ #include <openssl/x509v3.h>
  #include <openssl/x509_vfy.h>
  #endif
  #include <openssl/bn.h>
  #include <openssl/dh.h>
  #include <openssl/md5.h>
  #include <openssl/sha.h>
  #include <openssl/hmac.h>
  #include <openssl/des.h>
  #include <openssl/crypto.h>
  #ifdef HAVE_OPENSSL_IDEA_H
  #include <openssl/idea.h>
  #endif
  #include <openssl/blowfish.h>
  #ifdef HAVE_OPENSSL_RC5_H
  #include <openssl/rc5.h>
  #endif
  #include <openssl/cast.h>
  #include <openssl/err.h>
  #ifdef HAVE_OPENSSL_RIJNDAEL_H
  #include <openssl/rijndael.h>
  #else
  #include "crypto/rijndael/rijndael-api-fst.h"
  #endif
  #ifdef HAVE_OPENSSL_SHA2_H
  #include <openssl/sha2.h>
  #else
  #include "crypto/sha2/sha2.h"
  #endif
  
+ /* 0.9.7 stuff? */
+ #if OPENSSL_VERSION_NUMBER < 0x0090700fL
+ typedef STACK_OF(GENERAL_NAME) GENERAL_NAMES;
+ #else
+ #define USE_NEW_DES_API
+ #endif
+ 
  #include "var.h"
  #include "misc.h"
  #include "vmbuf.h"
  #include "plog.h"
  #include "crypto_openssl.h"
  #include "debug.h"
  #include "gcmalloc.h"
  
  /*
   * I hate to cast every parameter to des_xx into void *, but it is
   * necessary for SSLeay/OpenSSL portability.  It sucks.
   */
  
  #ifdef HAVE_SIGNING_C
  static int cb_check_cert __P((int, X509_STORE_CTX *));
  static void eay_setgentype __P((char *, int *));
  static X509 *mem2x509 __P((vchar_t *));
  #endif
  
  static caddr_t eay_hmac_init __P((vchar_t *, const EVP_MD *));
  
  #ifdef HAVE_SIGNING_C
  /* X509 Certificate */
  /*
   * convert the string of the subject name into DER
***************
*** 382,497 ****
  	bp = name->v;
  	len = i2d_X509_NAME(x509->cert_info->subject, &bp);
  
  	error = 0;
  
     end:
  	if (error) {
  #ifndef EAYDEBUG
  		plog(LLV_ERROR, LOCATION, NULL, "%s\n", eay_strerror());
  #else
  		printf("%s\n", eay_strerror());
  #endif
  		if (name) {
  			vfree(name);
  			name = NULL;
  		}
  	}
  	if (x509)
  		X509_free(x509);
  
  	return name;
  }
  
  /*
   * get the subjectAltName from X509 certificate.
!  * the name is terminated by '\0'.
   */
- #include <openssl/x509v3.h>
  int
  eay_get_x509subjectaltname(cert, altname, type, pos)
  	vchar_t *cert;
  	char **altname;
  	int *type;
  	int pos;
  {
  	X509 *x509 = NULL;
! 	X509_EXTENSION *ext;
! 	X509V3_EXT_METHOD *method = NULL;
! 	STACK_OF(GENERAL_NAME) *name;
! 	CONF_VALUE *cval = NULL;
! 	STACK_OF(CONF_VALUE) *nval = NULL;
! 	u_char *bp;
  	int i, len;
  	int error = -1;
  
  	*altname = NULL;
  	*type = GENT_OTHERNAME;
  
- 	bp = cert->v;
- 
  	x509 = mem2x509(cert);
  	if (x509 == NULL)
  		goto end;
  
! 	i = X509_get_ext_by_NID(x509, NID_subject_alt_name, -1);
! 	if (i < 0)
! 		goto end;
! 	ext = X509_get_ext(x509, i);
! 	method = X509V3_EXT_get(ext);
! 	if(!method)
! 		goto end;
! 	
! 	bp = ext->value->data;
! 	name = method->d2i(NULL, &bp, ext->value->length);
! 	if(!name)
  		goto end;
  
! 	nval = method->i2v(method, name, NULL);
! 	method->ext_free(name);
! 	name = NULL;
! 	if(!nval)
! 		goto end;
! 
! 	for (i = 0; i < sk_CONF_VALUE_num(nval); i++) {
! 		/* skip the name */
  		if (i + 1 != pos)
  			continue;
! 		cval = sk_CONF_VALUE_value(nval, i);
! 		len = strlen(cval->value) + 1;	/* '\0' included */
! 		*altname = racoon_malloc(len);
! 		if (!*altname) {
! 			sk_CONF_VALUE_pop_free(nval, X509V3_conf_free);
! 			goto end;
! 		}
! 		strlcpy(*altname, cval->value, len);
  
! 		/* set type of the name */
! 		eay_setgentype(cval->name, type);
  	}
  
! 	sk_CONF_VALUE_pop_free(nval, X509V3_conf_free);
  
  	error = 0;
  
     end:
  	if (error) {
  		if (*altname) {
  			racoon_free(*altname);
  			*altname = NULL;
  		}
  #ifndef EAYDEBUG
  		plog(LLV_ERROR, LOCATION, NULL, "%s\n", eay_strerror());
  #else
  		printf("%s\n", eay_strerror());
  #endif
  	}
  	if (x509)
  		X509_free(x509);
  
  	return error;
  }
  
  static void
  eay_setgentype(name, type)
  	char *name;
  	int *type;
--- 390,494 ----
  	bp = name->v;
  	len = i2d_X509_NAME(x509->cert_info->subject, &bp);
  
  	error = 0;
  
     end:
  	if (error) {
  #ifndef EAYDEBUG
  		plog(LLV_ERROR, LOCATION, NULL, "%s\n", eay_strerror());
  #else
  		printf("%s\n", eay_strerror());
  #endif
  		if (name) {
  			vfree(name);
  			name = NULL;
  		}
  	}
  	if (x509)
  		X509_free(x509);
  
  	return name;
  }
  
  /*
   * get the subjectAltName from X509 certificate.
!  * the name must be terminated by '\0'.
   */
  int
  eay_get_x509subjectaltname(cert, altname, type, pos)
  	vchar_t *cert;
  	char **altname;
  	int *type;
  	int pos;
  {
  	X509 *x509 = NULL;
!         GENERAL_NAMES *gens;
! 	GENERAL_NAME *gen;
  	int i, len;
  	int error = -1;
  
  	*altname = NULL;
  	*type = GENT_OTHERNAME;
  
  	x509 = mem2x509(cert);
  	if (x509 == NULL)
  		goto end;
  
!         gens = X509_get_ext_d2i(x509, NID_subject_alt_name, NULL, NULL);
! 	if (gens == NULL)
  		goto end;
  
!         for(i = 0; i < sk_GENERAL_NAME_num(gens); i++) {
  		if (i + 1 != pos)
  			continue;
! 		break;
! 	}
  
! 	/* there is no data at "pos" */
!         if (i == sk_GENERAL_NAME_num(gens))
! 		goto end;
! 
! 	gen = sk_GENERAL_NAME_value(gens, i);
! 
! 	/* make sure if the data is terminated by '\0'. */
! 	if (gen->d.ia5->data[gen->d.ia5->length] != '\0') {
! #ifndef EAYDEBUG
! 		plog(LLV_ERROR, LOCATION, NULL,
! 			"data is not terminated by '\0'.");
! #endif
! 		hexdump(gen->d.ia5->data, gen->d.ia5->length + 1);
! 		goto end;
  	}
  
! 	len = gen->d.ia5->length + 1;
! 	*altname = racoon_malloc(len);
! 	if (!*altname)
! 		goto end;
! 
! 	strlcpy(*altname, gen->d.ia5->data, len);
! 	*type = gen->type;
  
  	error = 0;
  
     end:
  	if (error) {
  		if (*altname) {
  			racoon_free(*altname);
  			*altname = NULL;
  		}
  #ifndef EAYDEBUG
  		plog(LLV_ERROR, LOCATION, NULL, "%s\n", eay_strerror());
  #else
  		printf("%s\n", eay_strerror());
  #endif
  	}
  	if (x509)
  		X509_free(x509);
  
  	return error;
  }
  
  static void
  eay_setgentype(name, type)
  	char *name;
  	int *type;
***************
*** 976,1067 ****
--- 973,1094 ----
  				(flags & ERR_TXT_STRING) ? data : "");
  		if (n < 0 || n >= sizeof(ebuf) - len)
  			break;
  		len += n;
  		if (sizeof(ebuf) < len)
  			break;
  	}
  
  	return ebuf;
  }
  
  void
  eay_init_error()
  {
  	ERR_load_crypto_strings();
  }
  
  /*
   * DES-CBC
   */
  vchar_t *
  eay_des_encrypt(data, key, iv)
  	vchar_t *data, *key, *iv;
  {
  	vchar_t *res;
+ #ifdef USE_NEW_DES_API
+ 	DES_key_schedule ks;
+ #else
  	des_key_schedule ks;
+ #endif
  
+ #ifdef USE_NEW_DES_API
+ 	if (DES_key_sched((void *)key->v, &ks) != 0)
+ #else
  	if (des_key_sched((void *)key->v, ks) != 0)
+ #endif
  		return NULL;
  
  	/* allocate buffer for result */
  	if ((res = vmalloc(data->l)) == NULL)
  		return NULL;
  
  	/* decryption data */
+ #ifdef USE_NEW_DES_API
+ 	DES_cbc_encrypt((void *)data->v, (void *)res->v, data->l,
+ 	                &ks, (void *)iv->v, DES_ENCRYPT);
+ #else
  	des_cbc_encrypt((void *)data->v, (void *)res->v, data->l,
  	                ks, (void *)iv->v, DES_ENCRYPT);
+ #endif
  
  	return res;
  }
  
  vchar_t *
  eay_des_decrypt(data, key, iv)
  	vchar_t *data, *key, *iv;
  {
  	vchar_t *res;
+ #ifdef USE_NEW_DES_API
+ 	DES_key_schedule ks;
+ #else
  	des_key_schedule ks;
+ #endif
  
+ #ifdef USE_NEW_DES_API
+ 	if (DES_key_sched((void *)key->v, &ks) != 0)
+ #else
  	if (des_key_sched((void *)key->v, ks) != 0)
+ #endif
  		return NULL;
  
  	/* allocate buffer for result */
  	if ((res = vmalloc(data->l)) == NULL)
  		return NULL;
  
  	/* decryption data */
+ #ifdef USE_NEW_DES_API
+ 	DES_cbc_encrypt((void *)data->v, (void *)res->v, data->l,
+ 	                &ks, (void *)iv->v, DES_DECRYPT);
+ #else
  	des_cbc_encrypt((void *)data->v, (void *)res->v, data->l,
  	                ks, (void *)iv->v, DES_DECRYPT);
+ #endif
  
  	return res;
  }
  
  int
  eay_des_weakkey(key)
  	vchar_t *key;
  {
+ #ifdef USE_NEW_DES_API
+ 	return DES_is_weak_key((void *)key->v);
+ #else
  	return des_is_weak_key((void *)key->v);
+ #endif
  }
  
  int
  eay_des_keylen(len)
  	int len;
  {
  	if (len != 0 && len != 64)
  		return -1;
  	return 64;
  }
  
  #ifdef HAVE_OPENSSL_IDEA_H
  /*
   * IDEA-CBC
   */
  vchar_t *
  eay_idea_encrypt(data, key, iv)
  	vchar_t *data, *key, *iv;
  {
  	vchar_t *res;
  	IDEA_KEY_SCHEDULE ks;
  
  	idea_set_encrypt_key(key->v, &ks);
  
  	/* allocate buffer for result */
***************
*** 1149,1199 ****
  	if ((res = vmalloc(data->l)) == NULL)
  		return NULL;
  
  	/* decryption data */
  	BF_cbc_encrypt(data->v, res->v, data->l,
  		&ks, iv->v, BF_DECRYPT);
  
  	return res;
  }
  
  int
  eay_bf_weakkey(key)
  	vchar_t *key;
  {
  	return 0;	/* XXX to be done. refer to RFC 2451 */
  }
  
  int
  eay_bf_keylen(len)
  	int len;
  {
  	if (len == 0)
  		return 448;
  	if (len < 40 || len > 448)
  		return -1;
! 	return len + 7 / 8;
  }
  
  #ifdef HAVE_OPENSSL_RC5_H
  /*
   * RC5-CBC
   */
  vchar_t *
  eay_rc5_encrypt(data, key, iv)
  	vchar_t *data, *key, *iv;
  {
  	vchar_t *res;
  	RC5_32_KEY ks;
  
  	/* in RFC 2451, there is information about the number of round. */
  	RC5_32_set_key(&ks, key->l, key->v, 16);
  
  	/* allocate buffer for result */
  	if ((res = vmalloc(data->l)) == NULL)
  		return NULL;
  
  	/* decryption data */
  	RC5_32_cbc_encrypt(data->v, res->v, data->l,
  		&ks, iv->v, RC5_ENCRYPT);
  
  	return res;
--- 1176,1226 ----
  	if ((res = vmalloc(data->l)) == NULL)
  		return NULL;
  
  	/* decryption data */
  	BF_cbc_encrypt(data->v, res->v, data->l,
  		&ks, iv->v, BF_DECRYPT);
  
  	return res;
  }
  
  int
  eay_bf_weakkey(key)
  	vchar_t *key;
  {
  	return 0;	/* XXX to be done. refer to RFC 2451 */
  }
  
  int
  eay_bf_keylen(len)
  	int len;
  {
  	if (len == 0)
  		return 448;
  	if (len < 40 || len > 448)
  		return -1;
! 	return len;
  }
  
  #ifdef HAVE_OPENSSL_RC5_H
  /*
   * RC5-CBC
   */
  vchar_t *
  eay_rc5_encrypt(data, key, iv)
  	vchar_t *data, *key, *iv;
  {
  	vchar_t *res;
  	RC5_32_KEY ks;
  
  	/* in RFC 2451, there is information about the number of round. */
  	RC5_32_set_key(&ks, key->l, key->v, 16);
  
  	/* allocate buffer for result */
  	if ((res = vmalloc(data->l)) == NULL)
  		return NULL;
  
  	/* decryption data */
  	RC5_32_cbc_encrypt(data->v, res->v, data->l,
  		&ks, iv->v, RC5_ENCRYPT);
  
  	return res;
***************
*** 1214,1336 ****
  		return NULL;
  
  	/* decryption data */
  	RC5_32_cbc_encrypt(data->v, res->v, data->l,
  		&ks, iv->v, RC5_DECRYPT);
  
  	return res;
  }
  
  int
  eay_rc5_weakkey(key)
  	vchar_t *key;
  {
  	return 0;	/* No known weak keys when used with 16 rounds. */
  
  }
  
  int
  eay_rc5_keylen(len)
  	int len;
  {
  	if (len == 0)
  		return 128;
  	if (len < 40 || len > 2040)
  		return -1;
! 	return len + 7 / 8;
  }
  #endif
  
  /*
   * 3DES-CBC
   */
  vchar_t *
  eay_3des_encrypt(data, key, iv)
  	vchar_t *data, *key, *iv;
  {
  	vchar_t *res;
  	des_key_schedule ks1, ks2, ks3;
  
  	if (key->l < 24)
  		return NULL;
  
  	if (des_key_sched((void *)key->v, ks1) != 0)
  		return NULL;
  	if (des_key_sched((void *)(key->v + 8), ks2) != 0)
  		return NULL;
  	if (des_key_sched((void *)(key->v + 16), ks3) != 0)
  		return NULL;
  
  	/* allocate buffer for result */
  	if ((res = vmalloc(data->l)) == NULL)
  		return NULL;
  
  	/* decryption data */
  	des_ede3_cbc_encrypt((void *)data->v, (void *)res->v, data->l,
  	                ks1, ks2, ks3, (void *)iv->v, DES_ENCRYPT);
  
  	return res;
  }
  
  vchar_t *
  eay_3des_decrypt(data, key, iv)
  	vchar_t *data, *key, *iv;
  {
  	vchar_t *res;
  	des_key_schedule ks1, ks2, ks3;
  
  	if (key->l < 24)
  		return NULL;
  
  	if (des_key_sched((void *)key->v, ks1) != 0)
  		return NULL;
  	if (des_key_sched((void *)(key->v + 8), ks2) != 0)
  		return NULL;
  	if (des_key_sched((void *)(key->v + 16), ks3) != 0)
  		return NULL;
  
  	/* allocate buffer for result */
  	if ((res = vmalloc(data->l)) == NULL)
  		return NULL;
  
  	/* decryption data */
  	des_ede3_cbc_encrypt((void *)data->v, (void *)res->v, data->l,
  	                ks1, ks2, ks3, (void *)iv->v, DES_DECRYPT);
  
  	return res;
  }
  
  int
  eay_3des_weakkey(key)
  	vchar_t *key;
  {
  	if (key->l < 24)
  		return 0;
  
! 	return (des_is_weak_key((void *)key->v)
! 		|| des_is_weak_key((void *)(key->v + 8))
! 		|| des_is_weak_key((void *)(key->v + 16)));
  }
  
  int
  eay_3des_keylen(len)
  	int len;
  {
  	if (len != 0 && len != 192)
  		return -1;
  	return 192;
  }
  
  /*
   * CAST-CBC
   */
  vchar_t *
  eay_cast_encrypt(data, key, iv)
  	vchar_t *data, *key, *iv;
  {
  	vchar_t *res;
  	CAST_KEY ks;
  
  	CAST_set_key(&ks, key->l, key->v);
  
  	/* allocate buffer for result */
  	if ((res = vmalloc(data->l)) == NULL)
--- 1241,1405 ----
  		return NULL;
  
  	/* decryption data */
  	RC5_32_cbc_encrypt(data->v, res->v, data->l,
  		&ks, iv->v, RC5_DECRYPT);
  
  	return res;
  }
  
  int
  eay_rc5_weakkey(key)
  	vchar_t *key;
  {
  	return 0;	/* No known weak keys when used with 16 rounds. */
  
  }
  
  int
  eay_rc5_keylen(len)
  	int len;
  {
  	if (len == 0)
  		return 128;
  	if (len < 40 || len > 2040)
  		return -1;
! 	return len;
  }
  #endif
  
  /*
   * 3DES-CBC
   */
  vchar_t *
  eay_3des_encrypt(data, key, iv)
  	vchar_t *data, *key, *iv;
  {
  	vchar_t *res;
+ #ifdef USE_NEW_DES_API
+ 	DES_key_schedule ks1, ks2, ks3;
+ #else
  	des_key_schedule ks1, ks2, ks3;
+ #endif
  
  	if (key->l < 24)
  		return NULL;
  
+ #ifdef USE_NEW_DES_API
+ 	if (DES_key_sched((void *)key->v, &ks1) != 0)
+ 		return NULL;
+ 	if (DES_key_sched((void *)(key->v + 8), &ks2) != 0)
+ 		return NULL;
+ 	if (DES_key_sched((void *)(key->v + 16), &ks3) != 0)
+ 		return NULL;
+ #else
  	if (des_key_sched((void *)key->v, ks1) != 0)
  		return NULL;
  	if (des_key_sched((void *)(key->v + 8), ks2) != 0)
  		return NULL;
  	if (des_key_sched((void *)(key->v + 16), ks3) != 0)
  		return NULL;
+ #endif
  
  	/* allocate buffer for result */
  	if ((res = vmalloc(data->l)) == NULL)
  		return NULL;
  
  	/* decryption data */
+ #ifdef USE_NEW_DES_API
+ 	DES_ede3_cbc_encrypt((void *)data->v, (void *)res->v, data->l,
+ 	                &ks1, &ks2, &ks3, (void *)iv->v, DES_ENCRYPT);
+ #else
  	des_ede3_cbc_encrypt((void *)data->v, (void *)res->v, data->l,
  	                ks1, ks2, ks3, (void *)iv->v, DES_ENCRYPT);
+ #endif
  
  	return res;
  }
  
  vchar_t *
  eay_3des_decrypt(data, key, iv)
  	vchar_t *data, *key, *iv;
  {
  	vchar_t *res;
+ #ifdef USE_NEW_DES_API
+ 	DES_key_schedule ks1, ks2, ks3;
+ #else
  	des_key_schedule ks1, ks2, ks3;
+ #endif
  
  	if (key->l < 24)
  		return NULL;
  
+ #ifdef USE_NEW_DES_API
+ 	if (DES_key_sched((void *)key->v, &ks1) != 0)
+ 		return NULL;
+ 	if (DES_key_sched((void *)(key->v + 8), &ks2) != 0)
+ 		return NULL;
+ 	if (DES_key_sched((void *)(key->v + 16), &ks3) != 0)
+ 		return NULL;
+ #else
  	if (des_key_sched((void *)key->v, ks1) != 0)
  		return NULL;
  	if (des_key_sched((void *)(key->v + 8), ks2) != 0)
  		return NULL;
  	if (des_key_sched((void *)(key->v + 16), ks3) != 0)
  		return NULL;
+ #endif
  
  	/* allocate buffer for result */
  	if ((res = vmalloc(data->l)) == NULL)
  		return NULL;
  
  	/* decryption data */
+ #ifdef USE_NEW_DES_API
+ 	DES_ede3_cbc_encrypt((void *)data->v, (void *)res->v, data->l,
+ 	                &ks1, &ks2, &ks3, (void *)iv->v, DES_DECRYPT);
+ #else
  	des_ede3_cbc_encrypt((void *)data->v, (void *)res->v, data->l,
  	                ks1, ks2, ks3, (void *)iv->v, DES_DECRYPT);
+ #endif
  
  	return res;
  }
  
  int
  eay_3des_weakkey(key)
  	vchar_t *key;
  {
  	if (key->l < 24)
  		return 0;
  
! #ifdef USE_NEW_DES_API
! 	return (DES_is_weak_key((void *)key->v) ||
! 	    DES_is_weak_key((void *)(key->v + 8)) ||
! 	    DES_is_weak_key((void *)(key->v + 16)));
! #else
! 	return (des_is_weak_key((void *)key->v) ||
! 	    des_is_weak_key((void *)(key->v + 8)) ||
! 	    des_is_weak_key((void *)(key->v + 16)));
! #endif
  }
  
  int
  eay_3des_keylen(len)
  	int len;
  {
  	if (len != 0 && len != 192)
  		return -1;
  	return 192;
  }
  
  /*
   * CAST-CBC
   */
  vchar_t *
  eay_cast_encrypt(data, key, iv)
  	vchar_t *data, *key, *iv;
  {
  	vchar_t *res;
  	CAST_KEY ks;
  
  	CAST_set_key(&ks, key->l, key->v);
  
  	/* allocate buffer for result */
  	if ((res = vmalloc(data->l)) == NULL)
***************
*** 1356,1406 ****
  	if ((res = vmalloc(data->l)) == NULL)
  		return NULL;
  
  	/* decryption data */
  	CAST_cbc_encrypt(data->v, res->v, data->l,
  	                &ks, iv->v, DES_DECRYPT);
  
  	return res;
  }
  
  int
  eay_cast_weakkey(key)
  	vchar_t *key;
  {
  	return 0;	/* No known weak keys. */
  }
  
  int
  eay_cast_keylen(len)
  	int len;
  {
  	if (len == 0)
  		return 128;
  	if (len < 40 || len > 128)
  		return -1;
! 	return len + 7 / 8;
  }
  
  /*
   * AES(RIJNDAEL)-CBC
   */
  vchar_t *
  eay_aes_encrypt(data, key, iv)
  	vchar_t *data, *key, *iv;
  {
  	vchar_t *res;
  	keyInstance k;
  	cipherInstance c;
  
  	memset(&k, 0, sizeof(k));
  	if (rijndael_makeKey(&k, DIR_ENCRYPT, key->l << 3, key->v) < 0)
  		return NULL;
  
  	/* allocate buffer for result */
  	if ((res = vmalloc(data->l)) == NULL)
  		return NULL;
  
  	/* encryption data */
  	memset(&c, 0, sizeof(c));
  	if (rijndael_cipherInit(&c, MODE_CBC, iv->v) < 0)
  		return NULL;
--- 1425,1475 ----
  	if ((res = vmalloc(data->l)) == NULL)
  		return NULL;
  
  	/* decryption data */
  	CAST_cbc_encrypt(data->v, res->v, data->l,
  	                &ks, iv->v, DES_DECRYPT);
  
  	return res;
  }
  
  int
  eay_cast_weakkey(key)
  	vchar_t *key;
  {
  	return 0;	/* No known weak keys. */
  }
  
  int
  eay_cast_keylen(len)
  	int len;
  {
  	if (len == 0)
  		return 128;
  	if (len < 40 || len > 128)
  		return -1;
! 	return len;
  }
  
  /*
   * AES(RIJNDAEL)-CBC
   */
  vchar_t *
  eay_aes_encrypt(data, key, iv)
  	vchar_t *data, *key, *iv;
  {
  	vchar_t *res;
  	keyInstance k;
  	cipherInstance c;
  
  	memset(&k, 0, sizeof(k));
  	if (rijndael_makeKey(&k, DIR_ENCRYPT, key->l << 3, key->v) < 0)
  		return NULL;
  
  	/* allocate buffer for result */
  	if ((res = vmalloc(data->l)) == NULL)
  		return NULL;
  
  	/* encryption data */
  	memset(&c, 0, sizeof(c));
  	if (rijndael_cipherInit(&c, MODE_CBC, iv->v) < 0)
  		return NULL;
diff -Nr -c25 ac_am/src/racoon/crypto_openssl.h ac_am_fixed/src/racoon/crypto_openssl.h
*** ac_am/src/racoon/crypto_openssl.h	2003-02-26 22:31:06.000000000 +0100
--- ac_am_fixed/src/racoon/crypto_openssl.h	2003-12-11 18:19:59.166053512 +0100
***************
*** 9,67 ****
   * are met:
   * 1. Redistributions of source code must retain the above copyright
   *    notice, this list of conditions and the following disclaimer.
   * 2. Redistributions in binary form must reproduce the above copyright
   *    notice, this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   * 3. Neither the name of the project nor the names of its contributors
   *    may be used to endorse or promote products derived from this software
   *    without specific prior written permission.
   * 
   * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
   * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
   * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
   * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
   * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
   * SUCH DAMAGE.
   */
  
  #ifdef HAVE_SIGNING_C
  /* X509 Certificate */
! #define GENT_OTHERNAME	0
! #define GENT_EMAIL	1
! #define GENT_DNS	2
! #define GENT_X400	3
! #define GENT_DIRNAME	4
! #define GENT_EDIPARTY	5
! #define GENT_URI	6
! #define GENT_IPADD	7
! #define GENT_RID	8
  
  extern vchar_t *eay_str2asn1dn __P((char *, int));
  extern int eay_cmp_asn1dn __P((vchar_t *, vchar_t *));
  extern int eay_check_x509cert __P((vchar_t *, char *));
  extern vchar_t *eay_get_x509asn1subjectname __P((vchar_t *));
  extern int eay_get_x509subjectaltname __P((vchar_t *, char **, int *, int));
  extern char *eay_get_x509text __P((vchar_t *));
  extern vchar_t *eay_get_x509cert __P((char *));
  extern vchar_t *eay_get_x509sign __P((vchar_t *, vchar_t *, vchar_t *));
  extern int eay_check_x509sign __P((vchar_t *, vchar_t *, vchar_t *));
  extern int eay_check_pkcs7sign __P((vchar_t *, vchar_t *, vchar_t *));
  
  /* RSA */
  extern vchar_t *eay_rsa_sign __P((vchar_t *, vchar_t *));
  extern int eay_rsa_verify __P((vchar_t *, vchar_t *, vchar_t *));
  
  /* ASN.1 */
  extern vchar_t *eay_get_pkcs1privkey __P((char *));
  extern vchar_t *eay_get_pkcs1pubkey __P((char *));
  #endif
  
  /* string error */
  extern char *eay_strerror __P((void));
  extern void eay_init_error __P((void));
  
--- 9,70 ----
   * are met:
   * 1. Redistributions of source code must retain the above copyright
   *    notice, this list of conditions and the following disclaimer.
   * 2. Redistributions in binary form must reproduce the above copyright
   *    notice, this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   * 3. Neither the name of the project nor the names of its contributors
   *    may be used to endorse or promote products derived from this software
   *    without specific prior written permission.
   * 
   * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
   * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
   * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
   * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
   * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
   * SUCH DAMAGE.
   */
  
  #ifdef HAVE_SIGNING_C
  /* X509 Certificate */
! 
! #include <openssl/x509v3.h>
! 
! #define GENT_OTHERNAME	GEN_OTHERNAME
! #define GENT_EMAIL	GEN_EMAIL
! #define GENT_DNS	GEN_DNS
! #define GENT_X400	GEN_X400
! #define GENT_DIRNAME	GEN_DIRNAME
! #define GENT_EDIPARTY	GEN_EDIPARTY
! #define GENT_URI	GEN_URI
! #define GENT_IPADD	GEN_IPADD
! #define GENT_RID	GEN_RID
  
  extern vchar_t *eay_str2asn1dn __P((char *, int));
  extern int eay_cmp_asn1dn __P((vchar_t *, vchar_t *));
  extern int eay_check_x509cert __P((vchar_t *, char *));
  extern vchar_t *eay_get_x509asn1subjectname __P((vchar_t *));
  extern int eay_get_x509subjectaltname __P((vchar_t *, char **, int *, int));
  extern char *eay_get_x509text __P((vchar_t *));
  extern vchar_t *eay_get_x509cert __P((char *));
  extern vchar_t *eay_get_x509sign __P((vchar_t *, vchar_t *, vchar_t *));
  extern int eay_check_x509sign __P((vchar_t *, vchar_t *, vchar_t *));
  extern int eay_check_pkcs7sign __P((vchar_t *, vchar_t *, vchar_t *));
  
  /* RSA */
  extern vchar_t *eay_rsa_sign __P((vchar_t *, vchar_t *));
  extern int eay_rsa_verify __P((vchar_t *, vchar_t *, vchar_t *));
  
  /* ASN.1 */
  extern vchar_t *eay_get_pkcs1privkey __P((char *));
  extern vchar_t *eay_get_pkcs1pubkey __P((char *));
  #endif
  
  /* string error */
  extern char *eay_strerror __P((void));
  extern void eay_init_error __P((void));
  
diff -Nr -c25 ac_am/src/racoon/grabmyaddr.c ac_am_fixed/src/racoon/grabmyaddr.c
*** ac_am/src/racoon/grabmyaddr.c	2003-03-05 21:57:27.000000000 +0100
--- ac_am_fixed/src/racoon/grabmyaddr.c	2003-12-11 18:19:59.168053208 +0100
***************
*** 320,369 ****
--- 320,371 ----
  void
  grab_myaddrs()
  {
  #ifdef HAVE_GETIFADDRS
  	struct myaddrs *p, *q, *old;
  	struct ifaddrs *ifa0, *ifap;
  #ifdef INET6
  #ifdef __KAME__
  	struct sockaddr_in6 *sin6;
  #endif
  #endif
  
  	char addr1[NI_MAXHOST];
  
  	if (getifaddrs(&ifa0)) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"getifaddrs failed: %s\n", strerror(errno));
  		exit(1);
  		/*NOTREACHED*/
  	}
  
  	old = lcconf->myaddrs;
  
  	for (ifap = ifa0; ifap; ifap = ifap->ifa_next) {
  
+ 		if (! ifap->ifa_addr)
+ 			continue;
  		if (ifap->ifa_addr->sa_family != AF_INET
  #ifdef INET6
  		 && ifap->ifa_addr->sa_family != AF_INET6
  #endif
  		)
  			continue;
  
  		if (!suitable_ifaddr(ifap->ifa_name, ifap->ifa_addr)) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"unsuitable address: %s %s\n",
  				ifap->ifa_name,
  				saddrwop2str(ifap->ifa_addr));
  			continue;
  		}
  
  		p = newmyaddr();
  		if (p == NULL) {
  			exit(1);
  			/*NOTREACHED*/
  		}
  		p->addr = dupsaddr(ifap->ifa_addr);
  		if (p->addr == NULL) {
  			exit(1);
  			/*NOTREACHED*/
  		}
diff -Nr -c25 ac_am/src/racoon/ipsec_doi.c ac_am_fixed/src/racoon/ipsec_doi.c
*** ac_am/src/racoon/ipsec_doi.c	2003-03-04 00:56:56.000000000 +0100
--- ac_am_fixed/src/racoon/ipsec_doi.c	2003-12-11 18:19:59.178051688 +0100
***************
*** 77,127 ****
  #include "sainfo.h"
  #include "proposal.h"
  #include "crypto_openssl.h"
  #include "strnames.h"
  #include "gcmalloc.h"
  
  #ifdef HAVE_GSSAPI
  #include "gssapi.h"
  #endif
  
  int verbose_proposal_check = 1;
  
  static vchar_t *get_ph1approval __P((struct ph1handle *, struct prop_pair **));
  static struct isakmpsa *get_ph1approvalx __P((struct prop_pair *,
  	struct isakmpsa *, struct isakmpsa *));
  static void print_ph1mismatched __P((struct prop_pair *, struct isakmpsa *));
  static int t2isakmpsa __P((struct isakmp_pl_t *, struct isakmpsa *));
  static int cmp_aproppair_i __P((struct prop_pair *, struct prop_pair *));
  static struct prop_pair *get_ph2approval __P((struct ph2handle *,
  	struct prop_pair **));
  static struct prop_pair *get_ph2approvalx __P((struct ph2handle *,
  	struct prop_pair *));
  static void free_proppair0 __P((struct prop_pair *));
  
  static int get_transform
! 	__P((struct isakmp_pl_p *, struct prop_pair **, int *));
  static u_int32_t ipsecdoi_set_ld __P((vchar_t *));
  
  static int check_doi __P((u_int32_t));
  static int check_situation __P((u_int32_t));
  
  static int check_prot_main __P((int));
  static int check_prot_quick __P((int));
  static int (*check_protocol[]) __P((int)) = {
  	check_prot_main,	/* IPSECDOI_TYPE_PH1 */
  	check_prot_quick,	/* IPSECDOI_TYPE_PH2 */
  };
  
  static int check_spi_size __P((int, int));
  
  static int check_trns_isakmp __P((int));
  static int check_trns_ah __P((int));
  static int check_trns_esp __P((int));
  static int check_trns_ipcomp __P((int));
  static int (*check_transform[]) __P((int)) = {
  	0,
  	check_trns_isakmp,	/* IPSECDOI_PROTO_ISAKMP */
  	check_trns_ah,		/* IPSECDOI_PROTO_IPSEC_AH */
  	check_trns_esp,		/* IPSECDOI_PROTO_IPSEC_ESP */
  	check_trns_ipcomp,	/* IPSECDOI_PROTO_IPCOMP */
  };
--- 77,127 ----
  #include "sainfo.h"
  #include "proposal.h"
  #include "crypto_openssl.h"
  #include "strnames.h"
  #include "gcmalloc.h"
  
  #ifdef HAVE_GSSAPI
  #include "gssapi.h"
  #endif
  
  int verbose_proposal_check = 1;
  
  static vchar_t *get_ph1approval __P((struct ph1handle *, struct prop_pair **));
  static struct isakmpsa *get_ph1approvalx __P((struct prop_pair *,
  	struct isakmpsa *, struct isakmpsa *));
  static void print_ph1mismatched __P((struct prop_pair *, struct isakmpsa *));
  static int t2isakmpsa __P((struct isakmp_pl_t *, struct isakmpsa *));
  static int cmp_aproppair_i __P((struct prop_pair *, struct prop_pair *));
  static struct prop_pair *get_ph2approval __P((struct ph2handle *,
  	struct prop_pair **));
  static struct prop_pair *get_ph2approvalx __P((struct ph2handle *,
  	struct prop_pair *));
  static void free_proppair0 __P((struct prop_pair *));
  
  static int get_transform
! 	__P((struct isakmp_pl_p *, struct prop_pair **, int *, int));
  static u_int32_t ipsecdoi_set_ld __P((vchar_t *));
  
  static int check_doi __P((u_int32_t));
  static int check_situation __P((u_int32_t));
  
  static int check_prot_main __P((int));
  static int check_prot_quick __P((int));
  static int (*check_protocol[]) __P((int)) = {
  	check_prot_main,	/* IPSECDOI_TYPE_PH1 */
  	check_prot_quick,	/* IPSECDOI_TYPE_PH2 */
  };
  
  static int check_spi_size __P((int, int));
  
  static int check_trns_isakmp __P((int));
  static int check_trns_ah __P((int));
  static int check_trns_esp __P((int));
  static int check_trns_ipcomp __P((int));
  static int (*check_transform[]) __P((int)) = {
  	0,
  	check_trns_isakmp,	/* IPSECDOI_PROTO_ISAKMP */
  	check_trns_ah,		/* IPSECDOI_PROTO_IPSEC_AH */
  	check_trns_esp,		/* IPSECDOI_PROTO_IPSEC_ESP */
  	check_trns_ipcomp,	/* IPSECDOI_PROTO_IPCOMP */
  };
***************
*** 348,402 ****
  			s->encklen, tsap->encklen);
  		plog(LLV_DEBUG, LOCATION, NULL, "hashtype = %s:%s\n",
  			s_oakley_attr_v(OAKLEY_ATTR_HASH_ALG,
  					s->hashtype),
  			s_oakley_attr_v(OAKLEY_ATTR_HASH_ALG,
  					tsap->hashtype));
  		plog(LLV_DEBUG, LOCATION, NULL, "authmethod = %s:%s\n",
  			s_oakley_attr_v(OAKLEY_ATTR_AUTH_METHOD,
  					s->authmethod),
  			s_oakley_attr_v(OAKLEY_ATTR_AUTH_METHOD,
  					tsap->authmethod));
  		plog(LLV_DEBUG, LOCATION, NULL, "dh_group = %s:%s\n",
  			s_oakley_attr_v(OAKLEY_ATTR_GRP_DESC,
  					s->dh_group),
  			s_oakley_attr_v(OAKLEY_ATTR_GRP_DESC,
  					tsap->dh_group));
  #if 0
  		/* XXX to be considered */
  		if (tsap->lifetime > s->lifetime) ;
  		if (tsap->lifebyte > s->lifebyte) ;
  #endif
  		/*
  		 * if responder side and peer's key length in proposal
  		 * is bigger than mine, it might be accepted.
  		 */
! 		if(tsap->enctype == s->enctype 
! 		 && tsap->authmethod == s->authmethod
! 		 && tsap->hashtype == s->hashtype
! 		 && tsap->dh_group == s->dh_group
! 		 && tsap->encklen == s->encklen)
  			break;
  	}
  
  	if (tsap->dhgrp != NULL)
  		oakley_dhgrp_free(tsap->dhgrp);
  	return s;
  }
  
  /*
   * print all of items in peer's proposal which are mismatched to my proposal.
   * p       : one of peer's proposal.
   * proposal: my proposals.
   */
  static void
  print_ph1mismatched(p, proposal)
  	struct prop_pair *p;
  	struct isakmpsa *proposal;
  {
  	struct isakmpsa sa, *s;
  
  	memset(&sa, 0, sizeof(sa));
  	if (t2isakmpsa(p->trns, &sa) < 0)
  		return;
  	for (s = proposal; s ; s = s->next) {
  		if (sa.enctype != s->enctype) {
--- 348,402 ----
  			s->encklen, tsap->encklen);
  		plog(LLV_DEBUG, LOCATION, NULL, "hashtype = %s:%s\n",
  			s_oakley_attr_v(OAKLEY_ATTR_HASH_ALG,
  					s->hashtype),
  			s_oakley_attr_v(OAKLEY_ATTR_HASH_ALG,
  					tsap->hashtype));
  		plog(LLV_DEBUG, LOCATION, NULL, "authmethod = %s:%s\n",
  			s_oakley_attr_v(OAKLEY_ATTR_AUTH_METHOD,
  					s->authmethod),
  			s_oakley_attr_v(OAKLEY_ATTR_AUTH_METHOD,
  					tsap->authmethod));
  		plog(LLV_DEBUG, LOCATION, NULL, "dh_group = %s:%s\n",
  			s_oakley_attr_v(OAKLEY_ATTR_GRP_DESC,
  					s->dh_group),
  			s_oakley_attr_v(OAKLEY_ATTR_GRP_DESC,
  					tsap->dh_group));
  #if 0
  		/* XXX to be considered */
  		if (tsap->lifetime > s->lifetime) ;
  		if (tsap->lifebyte > s->lifebyte) ;
  #endif
  		/*
  		 * if responder side and peer's key length in proposal
  		 * is bigger than mine, it might be accepted.
  		 */
! 		if(tsap->enctype == s->enctype &&
! 		    tsap->authmethod == s->authmethod &&
! 		    tsap->hashtype == s->hashtype &&
! 		    tsap->dh_group == s->dh_group &&
! 		    tsap->encklen == s->encklen)
  			break;
  	}
  
  	if (tsap->dhgrp != NULL)
  		oakley_dhgrp_free(tsap->dhgrp);
  	return s;
  }
  
  /*
   * print all of items in peer's proposal which are mismatched to my proposal.
   * p       : one of peer's proposal.
   * proposal: my proposals.
   */
  static void
  print_ph1mismatched(p, proposal)
  	struct prop_pair *p;
  	struct isakmpsa *proposal;
  {
  	struct isakmpsa sa, *s;
  
  	memset(&sa, 0, sizeof(sa));
  	if (t2isakmpsa(p->trns, &sa) < 0)
  		return;
  	for (s = proposal; s ; s = s->next) {
  		if (sa.enctype != s->enctype) {
***************
*** 1140,1219 ****
  	memset(pair, 0, sizeof(pair));
  
  	bp = (caddr_t)(sab + 1);
  	tlen = sa->l - sizeof(*sab);
  
      {
  	struct isakmp_pl_p *prop;
  	int proplen;
  	vchar_t *pbuf = NULL;
  	struct isakmp_parse_t *pa;
  
  	pbuf = isakmp_parsewoh(ISAKMP_NPTYPE_P, (struct isakmp_gen *)bp, tlen);
  	if (pbuf == NULL)
  		return NULL;
  
  	for (pa = (struct isakmp_parse_t *)pbuf->v;
  	     pa->type != ISAKMP_NPTYPE_NONE;
  	     pa++) {
  		/* check the value of next payload */
  		if (pa->type != ISAKMP_NPTYPE_P) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"Invalid payload type=%u\n", pa->type);
  			vfree(pbuf);
  			return NULL;
  		}
  
  		prop = (struct isakmp_pl_p *)pa->ptr;
  		proplen = pa->len;
  
  		plog(LLV_DEBUG, LOCATION, NULL,
  			"proposal #%u len=%d\n", prop->p_no, proplen);
  
  		if (proplen == 0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"invalid proposal with length %d\n", proplen);
  			vfree(pbuf);
  			return NULL;
  		}
  
  		/* check Protocol ID */
  		if (!check_protocol[mode]) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"unsupported mode %d\n", mode);
  			continue;
  		}
  
  		if (check_protocol[mode](prop->proto_id) < 0)
  			continue;
  
  		/* check SPI length when IKE. */
  		if (check_spi_size(prop->proto_id, prop->spi_size) < 0)
  			continue;
  
  		/* get transform */
! 		if (get_transform(prop, pair, &num_p) < 0) {
  			vfree(pbuf);
  			return NULL;
  		}
  	}
  	vfree(pbuf);
  	pbuf = NULL;
      }
  
      {
  	int notrans, nprop;
  	struct prop_pair *p, *q;
  
  	/* check for proposals with no transforms */
  	for (i = 0; i < MAXPROPPAIRLEN; i++) {
  		if (!pair[i])
  			continue;
  
  		plog(LLV_DEBUG, LOCATION, NULL, "pair %d:\n", i);
  		print_proppair(LLV_DEBUG, pair[i]);
  
  		notrans = nprop = 0;
  		for (p = pair[i]; p; p = p->next) {
  			if (p->trns == NULL) {
  				notrans++;
  				break;
--- 1140,1227 ----
  	memset(pair, 0, sizeof(pair));
  
  	bp = (caddr_t)(sab + 1);
  	tlen = sa->l - sizeof(*sab);
  
      {
  	struct isakmp_pl_p *prop;
  	int proplen;
  	vchar_t *pbuf = NULL;
  	struct isakmp_parse_t *pa;
  
  	pbuf = isakmp_parsewoh(ISAKMP_NPTYPE_P, (struct isakmp_gen *)bp, tlen);
  	if (pbuf == NULL)
  		return NULL;
  
  	for (pa = (struct isakmp_parse_t *)pbuf->v;
  	     pa->type != ISAKMP_NPTYPE_NONE;
  	     pa++) {
  		/* check the value of next payload */
  		if (pa->type != ISAKMP_NPTYPE_P) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"Invalid payload type=%u\n", pa->type);
  			vfree(pbuf);
  			return NULL;
  		}
+ 		if (mode == IPSECDOI_TYPE_PH1 &&
+ 		    pa != (struct isakmp_parse_t *)pbuf->v) {
+ 			plog(LLV_ERROR, LOCATION, NULL,
+ 				"Only a single proposal payload is allowed "
+ 				"during phase 1 processing.\n");
+ 			vfree(pbuf);
+ 			return NULL;
+ 		}
  
  		prop = (struct isakmp_pl_p *)pa->ptr;
  		proplen = pa->len;
  
  		plog(LLV_DEBUG, LOCATION, NULL,
  			"proposal #%u len=%d\n", prop->p_no, proplen);
  
  		if (proplen == 0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"invalid proposal with length %d\n", proplen);
  			vfree(pbuf);
  			return NULL;
  		}
  
  		/* check Protocol ID */
  		if (!check_protocol[mode]) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"unsupported mode %d\n", mode);
  			continue;
  		}
  
  		if (check_protocol[mode](prop->proto_id) < 0)
  			continue;
  
  		/* check SPI length when IKE. */
  		if (check_spi_size(prop->proto_id, prop->spi_size) < 0)
  			continue;
  
  		/* get transform */
! 		if (get_transform(prop, pair, &num_p, mode) < 0) {
  			vfree(pbuf);
  			return NULL;
  		}
  	}
  	vfree(pbuf);
  	pbuf = NULL;
      }
  
      {
  	int notrans, nprop;
  	struct prop_pair *p, *q;
  
  	/* check for proposals with no transforms */
  	for (i = 0; i < MAXPROPPAIRLEN; i++) {
  		if (!pair[i])
  			continue;
  
  		plog(LLV_DEBUG, LOCATION, NULL, "pair %d:\n", i);
  		print_proppair(LLV_DEBUG, pair[i]);
  
  		notrans = nprop = 0;
  		for (p = pair[i]; p; p = p->next) {
  			if (p->trns == NULL) {
  				notrans++;
  				break;
***************
*** 1246,1330 ****
  		} else {
  			plog(LLV_DEBUG, LOCATION, NULL,
  				"proposal #%u: %d transform\n",
  				pair[i]->prop->p_no, nprop);
  		}
  	}
      }
  
  	/* bark if no proposal is found. */
  	if (num_p <= 0) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"no Proposal found.\n");
  		return NULL;
  	}
  
  	return pair;
  }
  
  /*
   * check transform payload.
   * OUT:
   *	positive: return the pointer to the payload of valid transform.
   *	0	: No valid transform found.
   */
  static int
! get_transform(prop, pair, num_p)
  	struct isakmp_pl_p *prop;
  	struct prop_pair **pair;
  	int *num_p;
  {
  	int tlen; /* total length of all transform in a proposal */
  	caddr_t bp;
  	struct isakmp_pl_t *trns;
  	int trnslen;
  	vchar_t *pbuf = NULL;
  	struct isakmp_parse_t *pa;
  	struct prop_pair *p = NULL, *q;
  	int num_t;
  
  	bp = (caddr_t)prop + sizeof(struct isakmp_pl_p) + prop->spi_size;
  	tlen = ntohs(prop->h.len)
  		- (sizeof(struct isakmp_pl_p) + prop->spi_size);
  	pbuf = isakmp_parsewoh(ISAKMP_NPTYPE_T, (struct isakmp_gen *)bp, tlen);
  	if (pbuf == NULL)
  		return -1;
  
  	/* check and get transform for use */
  	num_t = 0;
  	for (pa = (struct isakmp_parse_t *)pbuf->v;
  	     pa->type != ISAKMP_NPTYPE_NONE;
  	     pa++) {
  
  		num_t++;
  
  		/* check the value of next payload */
  		if (pa->type != ISAKMP_NPTYPE_T) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"Invalid payload type=%u\n", pa->type);
  			break;
  		}
  
  		trns = (struct isakmp_pl_t *)pa->ptr;
  		trnslen = pa->len;
  
  		plog(LLV_DEBUG, LOCATION, NULL,
  			"transform #%u len=%u\n", trns->t_no, trnslen);
  
  		/* check transform ID */
  		if (prop->proto_id >= ARRAYLEN(check_transform)) {
  			plog(LLV_WARNING, LOCATION, NULL,
  				"unsupported proto_id %u\n",
  				prop->proto_id);
  			continue;
  		}
  		if (prop->proto_id >= ARRAYLEN(check_attributes)) {
  			plog(LLV_WARNING, LOCATION, NULL,
  				"unsupported proto_id %u\n",
  				prop->proto_id);
  			continue;
  		}
  
  		if (!check_transform[prop->proto_id]
  		 || !check_attributes[prop->proto_id]) {
  			plog(LLV_WARNING, LOCATION, NULL,
  				"unsupported proto_id %u\n",
--- 1254,1346 ----
  		} else {
  			plog(LLV_DEBUG, LOCATION, NULL,
  				"proposal #%u: %d transform\n",
  				pair[i]->prop->p_no, nprop);
  		}
  	}
      }
  
  	/* bark if no proposal is found. */
  	if (num_p <= 0) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"no Proposal found.\n");
  		return NULL;
  	}
  
  	return pair;
  }
  
  /*
   * check transform payload.
   * OUT:
   *	positive: return the pointer to the payload of valid transform.
   *	0	: No valid transform found.
   */
  static int
! get_transform(prop, pair, num_p, mode)
  	struct isakmp_pl_p *prop;
  	struct prop_pair **pair;
  	int *num_p;
+ 	int mode;
  {
  	int tlen; /* total length of all transform in a proposal */
  	caddr_t bp;
  	struct isakmp_pl_t *trns;
  	int trnslen;
  	vchar_t *pbuf = NULL;
  	struct isakmp_parse_t *pa;
  	struct prop_pair *p = NULL, *q;
  	int num_t;
  
  	bp = (caddr_t)prop + sizeof(struct isakmp_pl_p) + prop->spi_size;
  	tlen = ntohs(prop->h.len)
  		- (sizeof(struct isakmp_pl_p) + prop->spi_size);
  	pbuf = isakmp_parsewoh(ISAKMP_NPTYPE_T, (struct isakmp_gen *)bp, tlen);
  	if (pbuf == NULL)
  		return -1;
  
  	/* check and get transform for use */
  	num_t = 0;
  	for (pa = (struct isakmp_parse_t *)pbuf->v;
  	     pa->type != ISAKMP_NPTYPE_NONE;
  	     pa++) {
  
  		num_t++;
  
  		/* check the value of next payload */
  		if (pa->type != ISAKMP_NPTYPE_T) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"Invalid payload type=%u\n", pa->type);
  			break;
  		}
+ 		if (mode == IPSECDOI_TYPE_PH1 &&
+ 		    pa != (struct isakmp_parse_t *)pbuf->v) {
+ 			plog(LLV_ERROR, LOCATION, NULL,
+ 				"Only a single transform payload is allowed "
+ 				"during phase 1 processing.\n");
+ 			break;
+ 		}
  
  		trns = (struct isakmp_pl_t *)pa->ptr;
  		trnslen = pa->len;
  
  		plog(LLV_DEBUG, LOCATION, NULL,
  			"transform #%u len=%u\n", trns->t_no, trnslen);
  
  		/* check transform ID */
  		if (prop->proto_id >= ARRAYLEN(check_transform)) {
  			plog(LLV_WARNING, LOCATION, NULL,
  				"unsupported proto_id %u\n",
  				prop->proto_id);
  			continue;
  		}
  		if (prop->proto_id >= ARRAYLEN(check_attributes)) {
  			plog(LLV_WARNING, LOCATION, NULL,
  				"unsupported proto_id %u\n",
  				prop->proto_id);
  			continue;
  		}
  
  		if (!check_transform[prop->proto_id]
  		 || !check_attributes[prop->proto_id]) {
  			plog(LLV_WARNING, LOCATION, NULL,
  				"unsupported proto_id %u\n",
***************
*** 2078,2129 ****
  					"must be TV when ENC_MODE.\n");
  				return -1;
  			}
  
  			switch (lorv) {
  			case IPSECDOI_ATTR_ENC_MODE_TUNNEL:
  			case IPSECDOI_ATTR_ENC_MODE_TRNS:
  				break;
  			default:
  				plog(LLV_ERROR, LOCATION, NULL,
  					"invalid encryption mode=%u.\n",
  					lorv);
  				return -1;
  			}
  			break;
  
  		case IPSECDOI_ATTR_AUTH:
  			if (! flag) {
  				plog(LLV_ERROR, LOCATION, NULL,
  					"must be TV when AUTH.\n");
  				return -1;
  			}
  
  			switch (lorv) {
  			case IPSECDOI_ATTR_AUTH_HMAC_MD5:
! 				if (proto_id == IPSECDOI_PROTO_IPSEC_AH
! 				 && trns->t_id != IPSECDOI_AH_MD5) {
  ahmismatch:
  					plog(LLV_ERROR, LOCATION, NULL,
  						"auth algorithm %u conflicts "
  						"with transform %u.\n",
  						lorv, trns->t_id);
  					return -1;
  				}
  				break;
  			case IPSECDOI_ATTR_AUTH_HMAC_SHA1:
  				if (proto_id == IPSECDOI_PROTO_IPSEC_AH) {
  					if (trns->t_id != IPSECDOI_AH_SHA)
  						goto ahmismatch;
  				}
  				break;
  			case IPSECDOI_ATTR_AUTH_DES_MAC:
  			case IPSECDOI_ATTR_AUTH_KPDK:
  				plog(LLV_ERROR, LOCATION, NULL,
  					"auth algorithm %u isn't supported.\n",
  					lorv);
  				return -1;
  			default:
  				plog(LLV_ERROR, LOCATION, NULL,
  					"invalid auth algorithm=%u.\n",
  					lorv);
  				return -1;
--- 2094,2145 ----
  					"must be TV when ENC_MODE.\n");
  				return -1;
  			}
  
  			switch (lorv) {
  			case IPSECDOI_ATTR_ENC_MODE_TUNNEL:
  			case IPSECDOI_ATTR_ENC_MODE_TRNS:
  				break;
  			default:
  				plog(LLV_ERROR, LOCATION, NULL,
  					"invalid encryption mode=%u.\n",
  					lorv);
  				return -1;
  			}
  			break;
  
  		case IPSECDOI_ATTR_AUTH:
  			if (! flag) {
  				plog(LLV_ERROR, LOCATION, NULL,
  					"must be TV when AUTH.\n");
  				return -1;
  			}
  
  			switch (lorv) {
  			case IPSECDOI_ATTR_AUTH_HMAC_MD5:
! 				if (proto_id == IPSECDOI_PROTO_IPSEC_AH &&
! 				    trns->t_id != IPSECDOI_AH_MD5) {
  ahmismatch:
  					plog(LLV_ERROR, LOCATION, NULL,
  						"auth algorithm %u conflicts "
  						"with transform %u.\n",
  						lorv, trns->t_id);
  					return -1;
  				}
  				break;
  			case IPSECDOI_ATTR_AUTH_HMAC_SHA1:
  				if (proto_id == IPSECDOI_PROTO_IPSEC_AH) {
  					if (trns->t_id != IPSECDOI_AH_SHA)
  						goto ahmismatch;
  				}
  				break;
  			case IPSECDOI_ATTR_AUTH_DES_MAC:
  			case IPSECDOI_ATTR_AUTH_KPDK:
  				plog(LLV_ERROR, LOCATION, NULL,
  					"auth algorithm %u isn't supported.\n",
  					lorv);
  				return -1;
  			default:
  				plog(LLV_ERROR, LOCATION, NULL,
  					"invalid auth algorithm=%u.\n",
  					lorv);
  				return -1;
***************
*** 2188,2244 ****
  
  		case IPSECDOI_ATTR_KEY_ROUNDS:
  		case IPSECDOI_ATTR_COMP_DICT_SIZE:
  		case IPSECDOI_ATTR_COMP_PRIVALG:
  			plog(LLV_ERROR, LOCATION, NULL,
  				"attr type=%u isn't supported.\n", type);
  			return -1;
  
  		default:
  			plog(LLV_ERROR, LOCATION, NULL,
  				"invalid attribute type %d.\n", type);
  			return -1;
  		}
  
  		if (flag) {
  			tlen -= sizeof(*d);
  			d = (struct isakmp_data *)((char *)d
  				+ sizeof(*d));
  		} else {
  			tlen -= (sizeof(*d) + lorv);
  			d = (struct isakmp_data *)((caddr_t)d
  				+ sizeof(*d) + lorv);
  		}
  	}
  
! 	if (proto_id == IPSECDOI_PROTO_IPSEC_AH
! 	 && !attrseen[IPSECDOI_ATTR_AUTH]) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"attr AUTH must be present for AH.\n", type);
  		return -1;
  	}
  
  	return 0;
  }
  
  static int
  check_attr_ipcomp(trns)
  	struct isakmp_pl_t *trns;
  {
  	struct isakmp_data *d;
  	int tlen;
  	int flag, type = 0;
  	u_int16_t lorv;
  	int attrseen[16];	/* XXX magic number */
  
  	tlen = ntohs(trns->h.len) - sizeof(struct isakmp_pl_t);
  	d = (struct isakmp_data *)((caddr_t)trns + sizeof(struct isakmp_pl_t));
  	memset(attrseen, 0, sizeof(attrseen));
  
  	while (tlen > 0) {
  		type = ntohs(d->type) & ~ISAKMP_GEN_MASK;
  		flag = ntohs(d->type) & ISAKMP_GEN_MASK;
  		lorv = ntohs(d->lorv);
  
  		plog(LLV_DEBUG, LOCATION, NULL,
  			"type=%d, flag=0x%04x, lorv=0x%04x\n",
  			type, flag, lorv);
--- 2204,2268 ----
  
  		case IPSECDOI_ATTR_KEY_ROUNDS:
  		case IPSECDOI_ATTR_COMP_DICT_SIZE:
  		case IPSECDOI_ATTR_COMP_PRIVALG:
  			plog(LLV_ERROR, LOCATION, NULL,
  				"attr type=%u isn't supported.\n", type);
  			return -1;
  
  		default:
  			plog(LLV_ERROR, LOCATION, NULL,
  				"invalid attribute type %d.\n", type);
  			return -1;
  		}
  
  		if (flag) {
  			tlen -= sizeof(*d);
  			d = (struct isakmp_data *)((char *)d
  				+ sizeof(*d));
  		} else {
  			tlen -= (sizeof(*d) + lorv);
  			d = (struct isakmp_data *)((caddr_t)d
  				+ sizeof(*d) + lorv);
  		}
  	}
  
! 	if (proto_id == IPSECDOI_PROTO_IPSEC_AH &&
! 	    !attrseen[IPSECDOI_ATTR_AUTH]) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"attr AUTH must be present for AH.\n", type);
  		return -1;
  	}
  
+ 	if (proto_id == IPSECDOI_PROTO_IPSEC_ESP &&
+ 	    trns->t_id == IPSECDOI_ESP_NULL &&
+ 	    !attrseen[IPSECDOI_ATTR_AUTH]) {
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 		    "attr AUTH must be present for ESP NULL encryption.\n");
+ 		return -1;
+ 	}
+ 
  	return 0;
  }
  
  static int
  check_attr_ipcomp(trns)
  	struct isakmp_pl_t *trns;
  {
  	struct isakmp_data *d;
  	int tlen;
  	int flag, type = 0;
  	u_int16_t lorv;
  	int attrseen[16];	/* XXX magic number */
  
  	tlen = ntohs(trns->h.len) - sizeof(struct isakmp_pl_t);
  	d = (struct isakmp_data *)((caddr_t)trns + sizeof(struct isakmp_pl_t));
  	memset(attrseen, 0, sizeof(attrseen));
  
  	while (tlen > 0) {
  		type = ntohs(d->type) & ~ISAKMP_GEN_MASK;
  		flag = ntohs(d->type) & ISAKMP_GEN_MASK;
  		lorv = ntohs(d->lorv);
  
  		plog(LLV_DEBUG, LOCATION, NULL,
  			"type=%d, flag=0x%04x, lorv=0x%04x\n",
  			type, flag, lorv);
***************
*** 2323,2374 ****
  		case IPSECDOI_ATTR_KEY_ROUNDS:
  		case IPSECDOI_ATTR_COMP_DICT_SIZE:
  		case IPSECDOI_ATTR_COMP_PRIVALG:
  			plog(LLV_ERROR, LOCATION, NULL,
  				"attr type=%u isn't supported.\n", type);
  			return -1;
  
  		default:
  			plog(LLV_ERROR, LOCATION, NULL,
  				"invalid attribute type %d.\n", type);
  			return -1;
  		}
  
  		if (flag) {
  			tlen -= sizeof(*d);
  			d = (struct isakmp_data *)((char *)d
  				+ sizeof(*d));
  		} else {
  			tlen -= (sizeof(*d) + lorv);
  			d = (struct isakmp_data *)((caddr_t)d
  				+ sizeof(*d) + lorv);
  		}
  	}
  
  #if 0
! 	if (proto_id == IPSECDOI_PROTO_IPCOMP
! 	 && !attrseen[IPSECDOI_ATTR_AUTH]) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"attr AUTH must be present for AH.\n", type);
  		return -1;
  	}
  #endif
  
  	return 0;
  }
  
  /* %%% */
  /*
   * create phase1 proposal from remote configuration.
   * NOT INCLUDING isakmp general header of SA payload
   */
  vchar_t *
  ipsecdoi_setph1proposal(props)
  	struct isakmpsa *props;
  {
  	vchar_t *mysa;
  	int sablen;
  
  	/* count total size of SA minus isakmp general header */
  	/* not including isakmp general header of SA payload */
  	sablen = sizeof(struct ipsecdoi_sa_b);
  	sablen += setph1prop(props, NULL);
--- 2347,2398 ----
  		case IPSECDOI_ATTR_KEY_ROUNDS:
  		case IPSECDOI_ATTR_COMP_DICT_SIZE:
  		case IPSECDOI_ATTR_COMP_PRIVALG:
  			plog(LLV_ERROR, LOCATION, NULL,
  				"attr type=%u isn't supported.\n", type);
  			return -1;
  
  		default:
  			plog(LLV_ERROR, LOCATION, NULL,
  				"invalid attribute type %d.\n", type);
  			return -1;
  		}
  
  		if (flag) {
  			tlen -= sizeof(*d);
  			d = (struct isakmp_data *)((char *)d
  				+ sizeof(*d));
  		} else {
  			tlen -= (sizeof(*d) + lorv);
  			d = (struct isakmp_data *)((caddr_t)d
  				+ sizeof(*d) + lorv);
  		}
  	}
  
  #if 0
! 	if (proto_id == IPSECDOI_PROTO_IPCOMP &&
! 	    !attrseen[IPSECDOI_ATTR_AUTH]) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"attr AUTH must be present for AH.\n", type);
  		return -1;
  	}
  #endif
  
  	return 0;
  }
  
  /* %%% */
  /*
   * create phase1 proposal from remote configuration.
   * NOT INCLUDING isakmp general header of SA payload
   */
  vchar_t *
  ipsecdoi_setph1proposal(props)
  	struct isakmpsa *props;
  {
  	vchar_t *mysa;
  	int sablen;
  
  	/* count total size of SA minus isakmp general header */
  	/* not including isakmp general header of SA payload */
  	sablen = sizeof(struct ipsecdoi_sa_b);
  	sablen += setph1prop(props, NULL);
***************
*** 2617,2666 ****
--- 2641,2707 ----
  	case IPSECDOI_PROTO_IPCOMP:
  		/*
  		 * draft-shacham-ippcp-rfc2393bis-05.txt:
  		 * construct 16bit SPI (CPI).
  		 * XXX we may need to provide a configuration option to
  		 * generate 32bit SPI.  otherwise we cannot interoeprate
  		 * with nodes that uses 32bit SPI, in case we are initiator.
  		 */
  		prop->spi_size = sizeof(u_int16_t);
  		spi += sizeof(pr->spi) - sizeof(u_int16_t);
  		p->l -= sizeof(pr->spi);
  		p->l += sizeof(u_int16_t);
  		break;
  	default:
  		prop->spi_size = sizeof(pr->spi);
  		break;
  	}
  	memcpy(prop + 1, spi, prop->spi_size);
  
  	/* create transform */
  	trnsoff = sizeof(*prop) + prop->spi_size;
  	np_t = NULL;
  
  	for (tr = pr->head; tr; tr = tr->next) {
  	
+ 		switch (pr->proto_id) {
+ 		case IPSECDOI_PROTO_IPSEC_ESP:
+ 			/*
+ 			 * don't build a null encryption
+ 			 * with no authentication transform.
+ 			 */
+ 			if (tr->trns_id == IPSECDOI_ESP_NULL &&
+ 			    tr->authtype == IPSECDOI_ATTR_AUTH_NONE) {
+ 				plog(LLV_ERROR, LOCATION, NULL,
+ 				    "attr AUTH must be present "
+ 				    "for ESP NULL encryption.\n");
+ 				vfree(p);
+ 				return NULL;
+ 			}
+ 			break;
+ 		}
+ 
  		if (np_t) {
  			*np_t = ISAKMP_NPTYPE_T;
  			prop->num_t++;
  		}
  
  		/* get attribute length */
  		attrlen = 0;
  		if (pp->lifetime) {
  			attrlen += sizeof(struct isakmp_data)
  				+ sizeof(struct isakmp_data);
  			if (pp->lifetime > 0xffff)
  				attrlen += sizeof(u_int32_t);
  		}
  		if (pp->lifebyte && pp->lifebyte != IPSECDOI_ATTR_SA_LD_KB_MAX) {
  			attrlen += sizeof(struct isakmp_data)
  				+ sizeof(struct isakmp_data);
  			if (pp->lifebyte > 0xffff)
  				attrlen += sizeof(u_int32_t);
  		}
  		attrlen += sizeof(struct isakmp_data);	/* enc mode */
  		if (tr->encklen)
  			attrlen += sizeof(struct isakmp_data);
  
  		switch (pr->proto_id) {
  		case IPSECDOI_PROTO_IPSEC_ESP:
***************
*** 2802,2861 ****
  
  			iph2->sa = vrealloc(iph2->sa, iph2->sa->l + q->l);
  			if (iph2->sa == NULL) {
  				plog(LLV_ERROR, LOCATION, NULL,
  					"failed to allocate my sa buffer\n");
  				if (q)
  					vfree(q);
  				return -1;
  			}
  			memcpy(iph2->sa->v + iph2->sa->l - q->l, q->v, q->l);
  			if (propoff != 0) {
  				prop = (struct isakmp_pl_p *)(iph2->sa->v +
  					propoff);
  				prop->h.np = ISAKMP_NPTYPE_P;
  			}
  			propoff = iph2->sa->l - q->l;
  
  			vfree(q);
  		}
  	}
  
  	return 0;
  }
  
  /*
!  * return 1 if all of the proposed protocols are transport mode.
   */
  int
! ipsecdoi_transportmode(iph2)
! 	struct ph2handle *iph2;
! {
  	struct saprop *pp;
  	struct saproto *pr = NULL;
  
! 	for (pp = iph2->proposal; pp; pp = pp->next) {
  		for (pr = pp->head; pr; pr = pr->next) {
  			if (pr->encmode != IPSECDOI_ATTR_ENC_MODE_TRNS)
  				return 0;
  		}
  	}
  
  	return 1;
  }
  
  int
  ipsecdoi_get_defaultlifetime()
  {
  	return IPSECDOI_ATTR_SA_LD_SEC_DEFAULT;
  }
  
  int
  ipsecdoi_checkalgtypes(proto_id, enc, auth, comp)
  	int proto_id, enc, auth, comp;
  {
  #define TMPALGTYPE2STR(n) s_algtype(algclass_ipsec_##n, n)
  	switch (proto_id) {
  	case IPSECDOI_PROTO_IPSEC_ESP:
  		if (enc == 0 || comp != 0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"illegal algorithm defined "
--- 2843,2901 ----
  
  			iph2->sa = vrealloc(iph2->sa, iph2->sa->l + q->l);
  			if (iph2->sa == NULL) {
  				plog(LLV_ERROR, LOCATION, NULL,
  					"failed to allocate my sa buffer\n");
  				if (q)
  					vfree(q);
  				return -1;
  			}
  			memcpy(iph2->sa->v + iph2->sa->l - q->l, q->v, q->l);
  			if (propoff != 0) {
  				prop = (struct isakmp_pl_p *)(iph2->sa->v +
  					propoff);
  				prop->h.np = ISAKMP_NPTYPE_P;
  			}
  			propoff = iph2->sa->l - q->l;
  
  			vfree(q);
  		}
  	}
  
  	return 0;
  }
  
  /*
!  * return 1 if all of the given protocols are transport mode.
   */
  int
! ipsecdoi_transportmode(pp)
  	struct saprop *pp;
+ {
  	struct saproto *pr = NULL;
  
! 	for (; pp; pp = pp->next) {
  		for (pr = pp->head; pr; pr = pr->next) {
  			if (pr->encmode != IPSECDOI_ATTR_ENC_MODE_TRNS)
  				return 0;
  		}
  	}
  
  	return 1;
  }
  
  int
  ipsecdoi_get_defaultlifetime()
  {
  	return IPSECDOI_ATTR_SA_LD_SEC_DEFAULT;
  }
  
  int
  ipsecdoi_checkalgtypes(proto_id, enc, auth, comp)
  	int proto_id, enc, auth, comp;
  {
  #define TMPALGTYPE2STR(n) s_algtype(algclass_ipsec_##n, n)
  	switch (proto_id) {
  	case IPSECDOI_PROTO_IPSEC_ESP:
  		if (enc == 0 || comp != 0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"illegal algorithm defined "
***************
*** 2936,3011 ****
   * - if ID payload sent from peer is equal to the ID expected by me.
   *
   * both of "id" and "id_p" should be ID payload without general header,
   */
  int
  ipsecdoi_checkid1(iph1)
  	struct ph1handle *iph1;
  {
  	struct ipsecdoi_id_b *id_b;
  
  	if (iph1->id_p == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"invalid iph1 passed id_p == NULL\n");
  		return ISAKMP_INTERNAL_ERROR;
  	}
  	if (iph1->id_p->l < sizeof(*id_b)) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"invalid value passed as \"ident\" (len=%lu)\n",
  			(u_long)iph1->id_p->l);
  		return ISAKMP_NTYPE_INVALID_ID_INFORMATION;
  	}
  
  	id_b = (struct ipsecdoi_id_b *)iph1->id_p->v;
  
  	/* In main mode with pre-shared key, only address type can be used. */
! 	if (iph1->etype == ISAKMP_ETYPE_IDENT
! 	 && iph1->approval->authmethod == OAKLEY_ATTR_AUTH_METHOD_PSKEY) {
  		 if (id_b->type != IPSECDOI_ID_IPV4_ADDR
  		  && id_b->type != IPSECDOI_ID_IPV6_ADDR) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"Expecting IP address type in main mode, "
  				"but %s.\n", s_ipsecdoi_ident(id_b->type));
  			return ISAKMP_NTYPE_INVALID_ID_INFORMATION;
  		}
  	}
  
  	/* if proper type for phase 1 ? */
  	switch (id_b->type) {
  	case IPSECDOI_ID_IPV4_ADDR_SUBNET:
  	case IPSECDOI_ID_IPV6_ADDR_SUBNET:
  	case IPSECDOI_ID_IPV4_ADDR_RANGE:
  	case IPSECDOI_ID_IPV6_ADDR_RANGE:
  		plog(LLV_WARNING, LOCATION, NULL,
  			"such ID type %s is not proper.\n",
  			s_ipsecdoi_ident(id_b->type));
  		/*FALLTHROUGH*/
  	}
  
  	/* if phase 1 ID payload conformed RFC2407 4.6.2. */
! 	if (id_b->type == IPSECDOI_ID_IPV4_ADDR
! 	 && id_b->type == IPSECDOI_ID_IPV6_ADDR) {
  
  		if (id_b->proto_id == 0 && ntohs(id_b->port) != 0) {
  			plog(LLV_WARNING, LOCATION, NULL,
  				"protocol ID and Port mismatched. "
  				"proto_id:%d port:%d\n",
  				id_b->proto_id, ntohs(id_b->port));
  			/*FALLTHROUGH*/
  
  		} else if (id_b->proto_id == IPPROTO_UDP) {
  			/*
  			 * copmaring with expecting port.
  			 * always permit if port is equal to PORT_ISAKMP
  			 */
  			if (ntohs(id_b->port) != PORT_ISAKMP) {
  
  				u_int16_t port;
  
  				switch (iph1->remote->sa_family) {
  				case AF_INET:
  					port = ((struct sockaddr_in *)iph1->remote)->sin_port;
  					break;
  #ifdef INET6
  				case AF_INET6:
  					port = ((struct sockaddr_in6 *)iph1->remote)->sin6_port;
  					break;
--- 2976,3051 ----
   * - if ID payload sent from peer is equal to the ID expected by me.
   *
   * both of "id" and "id_p" should be ID payload without general header,
   */
  int
  ipsecdoi_checkid1(iph1)
  	struct ph1handle *iph1;
  {
  	struct ipsecdoi_id_b *id_b;
  
  	if (iph1->id_p == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"invalid iph1 passed id_p == NULL\n");
  		return ISAKMP_INTERNAL_ERROR;
  	}
  	if (iph1->id_p->l < sizeof(*id_b)) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"invalid value passed as \"ident\" (len=%lu)\n",
  			(u_long)iph1->id_p->l);
  		return ISAKMP_NTYPE_INVALID_ID_INFORMATION;
  	}
  
  	id_b = (struct ipsecdoi_id_b *)iph1->id_p->v;
  
  	/* In main mode with pre-shared key, only address type can be used. */
! 	if (iph1->etype == ISAKMP_ETYPE_IDENT &&
! 	    iph1->approval->authmethod == OAKLEY_ATTR_AUTH_METHOD_PSKEY) {
  		 if (id_b->type != IPSECDOI_ID_IPV4_ADDR
  		  && id_b->type != IPSECDOI_ID_IPV6_ADDR) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"Expecting IP address type in main mode, "
  				"but %s.\n", s_ipsecdoi_ident(id_b->type));
  			return ISAKMP_NTYPE_INVALID_ID_INFORMATION;
  		}
  	}
  
  	/* if proper type for phase 1 ? */
  	switch (id_b->type) {
  	case IPSECDOI_ID_IPV4_ADDR_SUBNET:
  	case IPSECDOI_ID_IPV6_ADDR_SUBNET:
  	case IPSECDOI_ID_IPV4_ADDR_RANGE:
  	case IPSECDOI_ID_IPV6_ADDR_RANGE:
  		plog(LLV_WARNING, LOCATION, NULL,
  			"such ID type %s is not proper.\n",
  			s_ipsecdoi_ident(id_b->type));
  		/*FALLTHROUGH*/
  	}
  
  	/* if phase 1 ID payload conformed RFC2407 4.6.2. */
! 	if (id_b->type == IPSECDOI_ID_IPV4_ADDR &&
! 	    id_b->type == IPSECDOI_ID_IPV6_ADDR) {
  
  		if (id_b->proto_id == 0 && ntohs(id_b->port) != 0) {
  			plog(LLV_WARNING, LOCATION, NULL,
  				"protocol ID and Port mismatched. "
  				"proto_id:%d port:%d\n",
  				id_b->proto_id, ntohs(id_b->port));
  			/*FALLTHROUGH*/
  
  		} else if (id_b->proto_id == IPPROTO_UDP) {
  			/*
  			 * copmaring with expecting port.
  			 * always permit if port is equal to PORT_ISAKMP
  			 */
  			if (ntohs(id_b->port) != PORT_ISAKMP) {
  
  				u_int16_t port;
  
  				switch (iph1->remote->sa_family) {
  				case AF_INET:
  					port = ((struct sockaddr_in *)iph1->remote)->sin_port;
  					break;
  #ifdef INET6
  				case AF_INET6:
  					port = ((struct sockaddr_in6 *)iph1->remote)->sin6_port;
  					break;
***************
*** 3286,3377 ****
  
  	return 0;
  }
  
  /*
   * create ID payload for phase 2, and set into iph2->id and id_p.  There are
   * NOT INCLUDING isakmp general header.
   * this function is for initiator.  responder will get to copy from payload.
   * responder ID type is always address type.
   * see, RFC2407 4.6.2.1
   */
  int
  ipsecdoi_setid2(iph2)
  	struct ph2handle *iph2;
  {
  	struct secpolicy *sp;
  
  	/* check there is phase 2 handler ? */
  	sp = getspbyspid(iph2->spid);
  	if (sp == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"no policy found for spid:%lu.\n", iph2->spid);
  		return -1;
  	}
  
! 	if (!iph2->sainfo->idv) {
! 		iph2->id = ipsecdoi_sockaddr2id((struct sockaddr *)&sp->spidx.src,
  					sp->spidx.prefs, sp->spidx.ul_proto);
! 		if (iph2->id == NULL) {
! 			plog(LLV_ERROR, LOCATION, NULL,
! 				"failed to get ID for %s\n",
! 				spidx2str(&sp->spidx));
! 			return -1;
! 		}
! 		plog(LLV_DEBUG, LOCATION, NULL, "use local ID type %s\n",
! 			s_ipsecdoi_ident(((struct ipsecdoi_id_b *)iph2->id->v)->type));
! 	} else {
! 		struct ipsecdoi_id_b id_b;
! 		vchar_t *ident;
! 
! 		id_b.type = idtype2doi(iph2->sainfo->idvtype);
! 		if (id_b.type == 255) {
! 			plog(LLV_ERROR, LOCATION, NULL,
! 				"failed to convert ID type to DOI.\n");
! 			return -1;
! 		}
! 		id_b.proto_id = 0;
! 		id_b.port = 0;
! 
! 		ident = getidval(iph2->sainfo->idvtype, iph2->sainfo->idv);
! 		if (!ident) {
! 			plog(LLV_ERROR, LOCATION, NULL,
! 				"failed to get ID value.\n");
! 			return -1;
! 		}
! 		iph2->id = vmalloc(sizeof(id_b) + ident->l);
! 		if (iph2->id == NULL) {
! 			plog(LLV_ERROR, LOCATION, NULL,
! 				"failed to get ID buffer.\n");
! 			vfree(ident);
! 			return -1;
! 		}
! 
! 		memcpy(iph2->id->v, &id_b, sizeof(id_b));
! 		memcpy(iph2->id->v + sizeof(id_b), ident->v, ident->l);
! 		vfree(ident);
  	}
  
  	/* remote side */
  	iph2->id_p = ipsecdoi_sockaddr2id((struct sockaddr *)&sp->spidx.dst,
  				sp->spidx.prefd, sp->spidx.ul_proto);
  	if (iph2->id_p == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to get ID for %s\n",
  			spidx2str(&sp->spidx));
  		vfree(iph2->id);
  		iph2->id = NULL;
  		return -1;
  	}
  	plog(LLV_DEBUG, LOCATION, NULL,
  		"use remote ID type %s\n",
  		s_ipsecdoi_ident(((struct ipsecdoi_id_b *)iph2->id_p->v)->type));
  
  	return 0;
  }
  
  /*
   * set address type of ID.
   * NOT INCLUDING general header.
   */
  vchar_t *
  ipsecdoi_sockaddr2id(saddr, prefixlen, ul_proto)
--- 3326,3385 ----
  
  	return 0;
  }
  
  /*
   * create ID payload for phase 2, and set into iph2->id and id_p.  There are
   * NOT INCLUDING isakmp general header.
   * this function is for initiator.  responder will get to copy from payload.
   * responder ID type is always address type.
   * see, RFC2407 4.6.2.1
   */
  int
  ipsecdoi_setid2(iph2)
  	struct ph2handle *iph2;
  {
  	struct secpolicy *sp;
  
  	/* check there is phase 2 handler ? */
  	sp = getspbyspid(iph2->spid);
  	if (sp == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"no policy found for spid:%lu.\n", iph2->spid);
  		return -1;
  	}
  
! 	iph2->id = ipsecdoi_sockaddr2id((struct sockaddr *)&sp->spidx.src,
  					sp->spidx.prefs, sp->spidx.ul_proto);
! 	if (iph2->id == NULL) {
! 		plog(LLV_ERROR, LOCATION, NULL,
! 			"failed to get ID for %s\n",
! 			spidx2str(&sp->spidx));
! 		return -1;
  	}
+ 	plog(LLV_DEBUG, LOCATION, NULL, "use local ID type %s\n",
+ 		s_ipsecdoi_ident(((struct ipsecdoi_id_b *)iph2->id->v)->type));
  
  	/* remote side */
  	iph2->id_p = ipsecdoi_sockaddr2id((struct sockaddr *)&sp->spidx.dst,
  				sp->spidx.prefd, sp->spidx.ul_proto);
  	if (iph2->id_p == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to get ID for %s\n",
  			spidx2str(&sp->spidx));
  		vfree(iph2->id);
  		iph2->id = NULL;
  		return -1;
  	}
  	plog(LLV_DEBUG, LOCATION, NULL,
  		"use remote ID type %s\n",
  		s_ipsecdoi_ident(((struct ipsecdoi_id_b *)iph2->id_p->v)->type));
  
  	return 0;
  }
  
  /*
   * set address type of ID.
   * NOT INCLUDING general header.
   */
  vchar_t *
  ipsecdoi_sockaddr2id(saddr, prefixlen, ul_proto)
***************
*** 3745,3796 ****
  				plog(LLV_ERROR, LOCATION, NULL,
  					"invalid life type: %d\n", life_t);
  				goto end;
  			}
  		    }
  			break;
  
  		case IPSECDOI_ATTR_GRP_DESC:
  			/*
  			 * RFC2407: 4.5 IPSEC Security Association Attributes
  			 *   Specifies the Oakley Group to be used in a PFS QM
  			 *   negotiation.  For a list of supported values, see
  			 *   Appendix A of [IKE].
  			 */
  			if (pp->pfs_group == 0)
  				pp->pfs_group = (u_int16_t)ntohs(d->lorv);
  			else if (pp->pfs_group != (u_int16_t)ntohs(d->lorv)) {
  				plog(LLV_ERROR, LOCATION, NULL,
  					"pfs_group mismatched "
  					"in a proposal.\n");
  				goto end;
  			}
  			break;
  
  		case IPSECDOI_ATTR_ENC_MODE:
! 			if (pr->encmode
! 			 && pr->encmode != (u_int16_t)ntohs(d->lorv)) {
  				plog(LLV_ERROR, LOCATION, NULL,
  					"multiple encmode exist "
  					"in a transform.\n");
  				goto end;
  			}
  			pr->encmode = (u_int16_t)ntohs(d->lorv);
  			break;
  
  		case IPSECDOI_ATTR_AUTH:
  			if (tr->authtype != IPSECDOI_ATTR_AUTH_NONE) {
  				plog(LLV_ERROR, LOCATION, NULL,
  					"multiple authtype exist "
  					"in a transform.\n");
  				goto end;
  			}
  			tr->authtype = (u_int16_t)ntohs(d->lorv);
  			break;
  
  		case IPSECDOI_ATTR_KEY_LENGTH:
  			if (pr->proto_id != IPSECDOI_PROTO_IPSEC_ESP) {
  				plog(LLV_ERROR, LOCATION, NULL,
  					"key length defined but not ESP");
  				goto end;
  			}
  			tr->encklen = ntohs(d->lorv);
--- 3753,3804 ----
  				plog(LLV_ERROR, LOCATION, NULL,
  					"invalid life type: %d\n", life_t);
  				goto end;
  			}
  		    }
  			break;
  
  		case IPSECDOI_ATTR_GRP_DESC:
  			/*
  			 * RFC2407: 4.5 IPSEC Security Association Attributes
  			 *   Specifies the Oakley Group to be used in a PFS QM
  			 *   negotiation.  For a list of supported values, see
  			 *   Appendix A of [IKE].
  			 */
  			if (pp->pfs_group == 0)
  				pp->pfs_group = (u_int16_t)ntohs(d->lorv);
  			else if (pp->pfs_group != (u_int16_t)ntohs(d->lorv)) {
  				plog(LLV_ERROR, LOCATION, NULL,
  					"pfs_group mismatched "
  					"in a proposal.\n");
  				goto end;
  			}
  			break;
  
  		case IPSECDOI_ATTR_ENC_MODE:
! 			if (pr->encmode &&
! 			    pr->encmode != (u_int16_t)ntohs(d->lorv)) {
  				plog(LLV_ERROR, LOCATION, NULL,
  					"multiple encmode exist "
  					"in a transform.\n");
  				goto end;
  			}
  			pr->encmode = (u_int16_t)ntohs(d->lorv);
  			break;
  
  		case IPSECDOI_ATTR_AUTH:
  			if (tr->authtype != IPSECDOI_ATTR_AUTH_NONE) {
  				plog(LLV_ERROR, LOCATION, NULL,
  					"multiple authtype exist "
  					"in a transform.\n");
  				goto end;
  			}
  			tr->authtype = (u_int16_t)ntohs(d->lorv);
  			break;
  
  		case IPSECDOI_ATTR_KEY_LENGTH:
  			if (pr->proto_id != IPSECDOI_PROTO_IPSEC_ESP) {
  				plog(LLV_ERROR, LOCATION, NULL,
  					"key length defined but not ESP");
  				goto end;
  			}
  			tr->encklen = ntohs(d->lorv);
diff -Nr -c25 ac_am/src/racoon/ipsec_doi.h ac_am_fixed/src/racoon/ipsec_doi.h
*** ac_am/src/racoon/ipsec_doi.h	2003-02-26 22:31:12.000000000 +0100
--- ac_am_fixed/src/racoon/ipsec_doi.h	2003-12-11 18:19:59.181051232 +0100
***************
*** 176,212 ****
  struct ipsecdoi_pl_sa;
  struct saprop;
  struct saproto;
  struct satrns;
  struct prop_pair;
  
  extern int ipsecdoi_checkph1proposal __P((vchar_t *, struct ph1handle *));
  extern int ipsecdoi_selectph2proposal __P((struct ph2handle *));
  extern int ipsecdoi_checkph2proposal __P((struct ph2handle *));
  
  extern struct prop_pair **get_proppair __P((vchar_t *, int));
  extern vchar_t *get_sabyproppair __P((struct prop_pair *, struct ph1handle *));
  extern int ipsecdoi_updatespi __P((struct ph2handle *iph2));
  extern vchar_t *get_sabysaprop __P((struct saprop *, vchar_t *));
  extern int ipsecdoi_checkid1 __P((struct ph1handle *));
  extern int ipsecdoi_setid1 __P((struct ph1handle *));
  extern int set_identifier __P((vchar_t **, int, vchar_t *));
  extern int ipsecdoi_setid2 __P((struct ph2handle *));
  extern vchar_t *ipsecdoi_sockaddr2id __P((struct sockaddr *, u_int, u_int));
  extern int ipsecdoi_id2sockaddr __P((vchar_t *, struct sockaddr *,
  	u_int8_t *, u_int16_t *));
  extern const char *ipsecdoi_id2str __P((const vchar_t *));
  
  extern vchar_t *ipsecdoi_setph1proposal __P((struct isakmpsa *));
  extern int ipsecdoi_setph2proposal __P((struct ph2handle *));
! extern int ipsecdoi_transportmode __P((struct ph2handle *));
  extern int ipsecdoi_get_defaultlifetime __P((void));
  extern int ipsecdoi_checkalgtypes __P((int, int, int, int));
  extern int ipproto2doi __P((int));
  extern int doi2ipproto __P((int));
  
  extern int ipsecdoi_t2satrns __P((struct isakmp_pl_t *,
  	struct saprop *, struct saproto *, struct satrns *));
  extern int ipsecdoi_authalg2trnsid __P((int));
  extern int idtype2doi __P((int));
  extern int doi2idtype __P((int));
  
--- 176,212 ----
  struct ipsecdoi_pl_sa;
  struct saprop;
  struct saproto;
  struct satrns;
  struct prop_pair;
  
  extern int ipsecdoi_checkph1proposal __P((vchar_t *, struct ph1handle *));
  extern int ipsecdoi_selectph2proposal __P((struct ph2handle *));
  extern int ipsecdoi_checkph2proposal __P((struct ph2handle *));
  
  extern struct prop_pair **get_proppair __P((vchar_t *, int));
  extern vchar_t *get_sabyproppair __P((struct prop_pair *, struct ph1handle *));
  extern int ipsecdoi_updatespi __P((struct ph2handle *iph2));
  extern vchar_t *get_sabysaprop __P((struct saprop *, vchar_t *));
  extern int ipsecdoi_checkid1 __P((struct ph1handle *));
  extern int ipsecdoi_setid1 __P((struct ph1handle *));
  extern int set_identifier __P((vchar_t **, int, vchar_t *));
  extern int ipsecdoi_setid2 __P((struct ph2handle *));
  extern vchar_t *ipsecdoi_sockaddr2id __P((struct sockaddr *, u_int, u_int));
  extern int ipsecdoi_id2sockaddr __P((vchar_t *, struct sockaddr *,
  	u_int8_t *, u_int16_t *));
  extern const char *ipsecdoi_id2str __P((const vchar_t *));
  
  extern vchar_t *ipsecdoi_setph1proposal __P((struct isakmpsa *));
  extern int ipsecdoi_setph2proposal __P((struct ph2handle *));
! extern int ipsecdoi_transportmode __P((struct saprop *));
  extern int ipsecdoi_get_defaultlifetime __P((void));
  extern int ipsecdoi_checkalgtypes __P((int, int, int, int));
  extern int ipproto2doi __P((int));
  extern int doi2ipproto __P((int));
  
  extern int ipsecdoi_t2satrns __P((struct isakmp_pl_t *,
  	struct saprop *, struct saproto *, struct satrns *));
  extern int ipsecdoi_authalg2trnsid __P((int));
  extern int idtype2doi __P((int));
  extern int doi2idtype __P((int));
  
diff -Nr -c25 ac_am/src/racoon/isakmp.c ac_am_fixed/src/racoon/isakmp.c
*** ac_am/src/racoon/isakmp.c	2003-03-04 00:56:56.000000000 +0100
--- ac_am_fixed/src/racoon/isakmp.c	2003-12-11 18:19:59.185050624 +0100
***************
*** 732,809 ****
  		SCHED_KILL(iph2->scr);
  
  	/* send */
  	plog(LLV_DEBUG, LOCATION, NULL, "===\n");
  	if ((ph2exchange[etypesw2(isakmp->etype)]
  			[iph2->side]
  			[iph2->status])(iph2, msg) != 0) {
  		plog(LLV_ERROR, LOCATION, iph2->ph1->remote,
  			"failed to process packet.\n");
  		return -1;
  	}
  
  #ifdef ENABLE_STATS
  	gettimeofday(&end, NULL);
  	syslog(LOG_NOTICE, "%s(%s): %8.6f",
  		"phase2",
  		s_isakmp_state(ISAKMP_ETYPE_QUICK, iph2->side, iph2->status),
  		timedelta(&start, &end));
  #endif
  
  	return 0;
  }
  
  /* new negotiation of phase 1 for initiator */
  int
! isakmp_ph1begin_i(rmconf, remote)
  	struct remoteconf *rmconf;
! 	struct sockaddr *remote;
  {
  	struct ph1handle *iph1;
  #ifdef ENABLE_STATS
  	struct timeval start, end;
  #endif
  
  	/* get new entry to isakmp status table. */
  	iph1 = newph1();
  	if (iph1 == NULL)
  		return -1;
  
  	iph1->status = PHASE1ST_START;
  	iph1->rmconf = rmconf;
  	iph1->side = INITIATOR;
  	iph1->version = ISAKMP_VERSION_NUMBER;
  	iph1->msgid = 0;
  	iph1->flags = 0;
  	iph1->ph2cnt = 0;
  #ifdef HAVE_GSSAPI
  	iph1->gssapi_state = NULL;
  #endif
  	iph1->approval = NULL;
  
  	/* XXX copy remote address */
! 	if (copy_ph1addresses(iph1, rmconf, remote, NULL) < 0)
  		return -1;
  
  	(void)insph1(iph1);
  
  	/* start phase 1 exchange */
  	iph1->etype = rmconf->etypes->type;
  
  	plog(LLV_DEBUG, LOCATION, NULL, "===\n");
      {
  	char *a;
  
  	a = strdup(saddr2str(iph1->local));
  	plog(LLV_INFO, LOCATION, NULL,
  		"initiate new phase 1 negotiation: %s<=>%s\n",
  		a, saddr2str(iph1->remote));
  	racoon_free(a);
      }
  	plog(LLV_INFO, LOCATION, NULL,
  		"begin %s mode.\n",
  		s_isakmp_etype(iph1->etype));
  
  #ifdef ENABLE_STATS
  	gettimeofday(&iph1->start, NULL);
  	gettimeofday(&start, NULL);
  #endif
--- 732,809 ----
  		SCHED_KILL(iph2->scr);
  
  	/* send */
  	plog(LLV_DEBUG, LOCATION, NULL, "===\n");
  	if ((ph2exchange[etypesw2(isakmp->etype)]
  			[iph2->side]
  			[iph2->status])(iph2, msg) != 0) {
  		plog(LLV_ERROR, LOCATION, iph2->ph1->remote,
  			"failed to process packet.\n");
  		return -1;
  	}
  
  #ifdef ENABLE_STATS
  	gettimeofday(&end, NULL);
  	syslog(LOG_NOTICE, "%s(%s): %8.6f",
  		"phase2",
  		s_isakmp_state(ISAKMP_ETYPE_QUICK, iph2->side, iph2->status),
  		timedelta(&start, &end));
  #endif
  
  	return 0;
  }
  
  /* new negotiation of phase 1 for initiator */
  int
! isakmp_ph1begin_i(rmconf, remote, local)
  	struct remoteconf *rmconf;
! 	struct sockaddr *remote, *local;
  {
  	struct ph1handle *iph1;
  #ifdef ENABLE_STATS
  	struct timeval start, end;
  #endif
  
  	/* get new entry to isakmp status table. */
  	iph1 = newph1();
  	if (iph1 == NULL)
  		return -1;
  
  	iph1->status = PHASE1ST_START;
  	iph1->rmconf = rmconf;
  	iph1->side = INITIATOR;
  	iph1->version = ISAKMP_VERSION_NUMBER;
  	iph1->msgid = 0;
  	iph1->flags = 0;
  	iph1->ph2cnt = 0;
  #ifdef HAVE_GSSAPI
  	iph1->gssapi_state = NULL;
  #endif
  	iph1->approval = NULL;
  
  	/* XXX copy remote address */
! 	if (copy_ph1addresses(iph1, rmconf, remote, local) < 0)
  		return -1;
  
  	(void)insph1(iph1);
  
  	/* start phase 1 exchange */
  	iph1->etype = rmconf->etypes->type;
  
  	plog(LLV_DEBUG, LOCATION, NULL, "===\n");
      {
  	char *a;
  
  	a = strdup(saddr2str(iph1->local));
  	plog(LLV_INFO, LOCATION, NULL,
  		"initiate new phase 1 negotiation: %s<=>%s\n",
  		a, saddr2str(iph1->remote));
  	racoon_free(a);
      }
  	plog(LLV_INFO, LOCATION, NULL,
  		"begin %s mode.\n",
  		s_isakmp_etype(iph1->etype));
  
  #ifdef ENABLE_STATS
  	gettimeofday(&iph1->start, NULL);
  	gettimeofday(&start, NULL);
  #endif
***************
*** 1669,1719 ****
  
  	/* if passive mode, ignore the acquire message */
  	if (rmconf->passive) {
  		plog(LLV_DEBUG, LOCATION, NULL,
  			"because of passive mode, "
  			"ignore the acquire message for %s.\n",
  			saddrwop2str(iph2->dst));
  		return 0;
  	}
  
  	/* search isakmp status table by address with masking port */
  	iph1 = getph1byaddr(iph2->src, iph2->dst);
  
  	/* no ISAKMP-SA found. */
  	if (iph1 == NULL) {
  		struct sched *sc;
  
  		iph2->retry_checkph1 = lcconf->retry_checkph1;
  		sc = sched_new(1, isakmp_chkph1there_stub, iph2);
  		plog(LLV_INFO, LOCATION, NULL,
  			"IPsec-SA request for %s queued "
  			"due to no phase1 found.\n",
  			saddrwop2str(iph2->dst));
  
  		/* start phase 1 negotiation as a initiator. */
! 		if (isakmp_ph1begin_i(rmconf, iph2->dst) < 0) {
  			SCHED_KILL(sc);
  			return -1;
  		}
  
  		return 0;
  		/*NOTREACHED*/
  	}
  
  	/* found ISAKMP-SA, but on negotiation. */
  	if (iph1->status != PHASE1ST_ESTABLISHED) {
  		iph2->retry_checkph1 = lcconf->retry_checkph1;
  		sched_new(1, isakmp_chkph1there_stub, iph2);
  		plog(LLV_INFO, LOCATION, iph2->dst,
  			"request for establishing IPsec-SA was queued "
  			"due to no phase1 found.\n");
  		return 0;
  		/*NOTREACHED*/
  	}
  
  	/* found established ISAKMP-SA */
  	/* i.e. iph1->status == PHASE1ST_ESTABLISHED */
  
  	/* found ISAKMP-SA. */
  	plog(LLV_DEBUG, LOCATION, NULL, "begin QUICK mode.\n");
  
--- 1669,1719 ----
  
  	/* if passive mode, ignore the acquire message */
  	if (rmconf->passive) {
  		plog(LLV_DEBUG, LOCATION, NULL,
  			"because of passive mode, "
  			"ignore the acquire message for %s.\n",
  			saddrwop2str(iph2->dst));
  		return 0;
  	}
  
  	/* search isakmp status table by address with masking port */
  	iph1 = getph1byaddr(iph2->src, iph2->dst);
  
  	/* no ISAKMP-SA found. */
  	if (iph1 == NULL) {
  		struct sched *sc;
  
  		iph2->retry_checkph1 = lcconf->retry_checkph1;
  		sc = sched_new(1, isakmp_chkph1there_stub, iph2);
  		plog(LLV_INFO, LOCATION, NULL,
  			"IPsec-SA request for %s queued "
  			"due to no phase1 found.\n",
  			saddrwop2str(iph2->dst));
  
  		/* start phase 1 negotiation as a initiator. */
! 		if (isakmp_ph1begin_i(rmconf, iph2->dst, iph2->src) < 0) {
  			SCHED_KILL(sc);
  			return -1;
  		}
  
  		return 0;
  		/*NOTREACHED*/
  	}
  
  	/* found ISAKMP-SA, but on negotiation. */
  	if (iph1->status != PHASE1ST_ESTABLISHED) {
  		iph2->retry_checkph1 = lcconf->retry_checkph1;
  		sched_new(1, isakmp_chkph1there_stub, iph2);
  		plog(LLV_INFO, LOCATION, iph2->dst,
  			"request for establishing IPsec-SA was queued "
  			"due to no phase1 found.\n");
  		return 0;
  		/*NOTREACHED*/
  	}
  
  	/* found established ISAKMP-SA */
  	/* i.e. iph1->status == PHASE1ST_ESTABLISHED */
  
  	/* found ISAKMP-SA. */
  	plog(LLV_DEBUG, LOCATION, NULL, "begin QUICK mode.\n");
  
diff -Nr -c25 ac_am/src/racoon/isakmp_quick.c ac_am_fixed/src/racoon/isakmp_quick.c
*** ac_am/src/racoon/isakmp_quick.c	2003-02-28 05:06:40.000000000 +0100
--- ac_am_fixed/src/racoon/isakmp_quick.c	2003-12-11 18:19:59.189050016 +0100
***************
*** 190,249 ****
  		if (oakley_setdhgroup(pfsgroup, &iph2->pfsgrp) < 0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"failed to set DH value.\n");
  			goto end;
  		}
  		if (oakley_dh_generate(iph2->pfsgrp,
  				&iph2->dhpub, &iph2->dhpriv) < 0) {
  			goto end;
  		}
  	}
  
  	/* generate ID value */
  	if (ipsecdoi_setid2(iph2) < 0) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to get ID.\n");
  		goto end;
  	}
  	plog(LLV_DEBUG, LOCATION, NULL, "IDci:");
  	plogdump(LLV_DEBUG, iph2->id->v, iph2->id->l);
  	plog(LLV_DEBUG, LOCATION, NULL, "IDcr:");
  	plogdump(LLV_DEBUG, iph2->id_p->v, iph2->id_p->l);
  
  	/*
  	 * we do not attach IDci nor IDcr, under the following condition:
  	 * - all proposals are transport mode
! 	 * - no MIP6
  	 * - id payload suggests to encrypt all the traffic (no specific
  	 *   protocol type)
  	 */
  	id = (struct ipsecdoi_id_b *)iph2->id->v;
  	id_p = (struct ipsecdoi_id_b *)iph2->id_p->v;
  	if (id->proto_id == 0
  	 && id_p->proto_id == 0
! 	 && iph2->ph1->rmconf->support_mip6 == 0
! 	 && ipsecdoi_transportmode(iph2)) {
  		idci = idcr = 0;
  	} else
  		idci = idcr = 1;
  
  	/* create SA;NONCE payload, and KE if need, and IDii, IDir. */
  	tlen = + sizeof(*gen) + iph2->sa->l
  		+ sizeof(*gen) + iph2->nonce->l;
  	if (pfsgroup)
  		tlen += (sizeof(*gen) + iph2->dhpub->l);
  	if (idci)
  		tlen += sizeof(*gen) + iph2->id->l;
  	if (idcr)
  		tlen += sizeof(*gen) + iph2->id_p->l;
  
  	body = vmalloc(tlen);
  	if (body == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to get buffer to send.\n");
  		goto end;
  	}
  
  	p = body->v;
  
  	/* add SA payload */
  	p = set_isakmp_payload(p, iph2->sa, ISAKMP_NPTYPE_NONCE);
--- 190,249 ----
  		if (oakley_setdhgroup(pfsgroup, &iph2->pfsgrp) < 0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"failed to set DH value.\n");
  			goto end;
  		}
  		if (oakley_dh_generate(iph2->pfsgrp,
  				&iph2->dhpub, &iph2->dhpriv) < 0) {
  			goto end;
  		}
  	}
  
  	/* generate ID value */
  	if (ipsecdoi_setid2(iph2) < 0) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to get ID.\n");
  		goto end;
  	}
  	plog(LLV_DEBUG, LOCATION, NULL, "IDci:");
  	plogdump(LLV_DEBUG, iph2->id->v, iph2->id->l);
  	plog(LLV_DEBUG, LOCATION, NULL, "IDcr:");
  	plogdump(LLV_DEBUG, iph2->id_p->v, iph2->id_p->l);
  
  	/*
  	 * we do not attach IDci nor IDcr, under the following condition:
  	 * - all proposals are transport mode
! 	 * - no MIP6 or proxy
  	 * - id payload suggests to encrypt all the traffic (no specific
  	 *   protocol type)
  	 */
  	id = (struct ipsecdoi_id_b *)iph2->id->v;
  	id_p = (struct ipsecdoi_id_b *)iph2->id_p->v;
  	if (id->proto_id == 0
  	 && id_p->proto_id == 0
! 	 && iph2->ph1->rmconf->support_proxy == 0
! 	 && ipsecdoi_transportmode(iph2->proposal)) {
  		idci = idcr = 0;
  	} else
  		idci = idcr = 1;
  
  	/* create SA;NONCE payload, and KE if need, and IDii, IDir. */
  	tlen = + sizeof(*gen) + iph2->sa->l
  		+ sizeof(*gen) + iph2->nonce->l;
  	if (pfsgroup)
  		tlen += (sizeof(*gen) + iph2->dhpub->l);
  	if (idci)
  		tlen += sizeof(*gen) + iph2->id->l;
  	if (idcr)
  		tlen += sizeof(*gen) + iph2->id_p->l;
  
  	body = vmalloc(tlen);
  	if (body == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to get buffer to send.\n");
  		goto end;
  	}
  
  	p = body->v;
  
  	/* add SA payload */
  	p = set_isakmp_payload(p, iph2->sa, ISAKMP_NPTYPE_NONCE);
***************
*** 1784,1834 ****
  
  	if (iph2->id == NULL) {
  		switch (iph2->dst->sa_family) {
  		case AF_INET:
  			prefixlen = sizeof(struct in_addr) << 3;
  			break;
  		case AF_INET6:
  			prefixlen = sizeof(struct in6_addr) << 3;
  			break;
  		default:
  			plog(LLV_ERROR, LOCATION, NULL,
  				"invalid family: %d\n", iph2->dst->sa_family);
  			goto end;
  		}
  		iddst = ipsecdoi_sockaddr2id(iph2->dst, prefixlen,
  					IPSEC_ULPROTO_ANY);
  	} else {
  		iddst = vdup(iph2->id_p);
  	}
  	if (iddst == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to set ID for destination.\n");
  		goto end;
  	}
  
! 	iph2->sainfo = getsainfo(idsrc, iddst);
  	if (iph2->sainfo == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to get sainfo.\n");
  		goto end;
  	}
  
  	plog(LLV_DEBUG, LOCATION, NULL,
  		"get sa info: %s\n", sainfo2str(iph2->sainfo));
  
  	error = 0;
  end:
  	if (idsrc)
  		vfree(idsrc);
  	if (iddst)
  		vfree(iddst);
  
  	return error;
  }
  
  /*
   * Copy both IP addresses in ID payloads into [src,dst]_id if both ID types
   * are IP address and same address family.
   * Then get remote's policy from SPD copied from kernel.
   * If the type of ID payload is address or subnet type, then the index is
   * made from the payload.  If there is no ID payload, or the type of ID
--- 1784,1834 ----
  
  	if (iph2->id == NULL) {
  		switch (iph2->dst->sa_family) {
  		case AF_INET:
  			prefixlen = sizeof(struct in_addr) << 3;
  			break;
  		case AF_INET6:
  			prefixlen = sizeof(struct in6_addr) << 3;
  			break;
  		default:
  			plog(LLV_ERROR, LOCATION, NULL,
  				"invalid family: %d\n", iph2->dst->sa_family);
  			goto end;
  		}
  		iddst = ipsecdoi_sockaddr2id(iph2->dst, prefixlen,
  					IPSEC_ULPROTO_ANY);
  	} else {
  		iddst = vdup(iph2->id_p);
  	}
  	if (iddst == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to set ID for destination.\n");
  		goto end;
  	}
  
! 	iph2->sainfo = getsainfo(idsrc, iddst, iph2->ph1->id_p);
  	if (iph2->sainfo == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to get sainfo.\n");
  		goto end;
  	}
  
  	plog(LLV_DEBUG, LOCATION, NULL,
  		"get sa info: %s\n", sainfo2str(iph2->sainfo));
  
  	error = 0;
  end:
  	if (idsrc)
  		vfree(idsrc);
  	if (iddst)
  		vfree(iddst);
  
  	return error;
  }
  
  /*
   * Copy both IP addresses in ID payloads into [src,dst]_id if both ID types
   * are IP address and same address family.
   * Then get remote's policy from SPD copied from kernel.
   * If the type of ID payload is address or subnet type, then the index is
   * made from the payload.  If there is no ID payload, or the type of ID
diff -Nr -c25 ac_am/src/racoon/isakmp_var.h ac_am_fixed/src/racoon/isakmp_var.h
*** ac_am/src/racoon/isakmp_var.h	2003-02-26 22:31:18.000000000 +0100
--- ac_am_fixed/src/racoon/isakmp_var.h	2003-12-11 18:19:59.192049560 +0100
***************
*** 32,82 ****
  #define PORT_ISAKMP 500
  
  #define DEFAULT_NONCE_SIZE	16
  
  typedef u_char cookie_t[8];
  typedef u_char msgid_t[4];
  
  typedef struct { /* i_cookie + r_cookie */
  	cookie_t i_ck;
  	cookie_t r_ck;
  } isakmp_index;
  
  struct isakmp_gen;
  struct sched;
  
  struct sockaddr;
  struct ph1handle;
  struct ph2handle;
  struct remoteconf;
  struct isakmp_gen;
  struct ipsecdoi_pl_id;	/* XXX */
  struct isakmp_pl_ke;	/* XXX */
  struct isakmp_pl_nonce;	/* XXX */
  
  extern int isakmp_handler __P((int));
! extern int isakmp_ph1begin_i __P((struct remoteconf *, struct sockaddr *));
  
  extern vchar_t *isakmp_parsewoh __P((int, struct isakmp_gen *, int));
  extern vchar_t *isakmp_parse __P((vchar_t *));
  
  extern int isakmp_init __P((void));
  extern const char *isakmp_pindex __P((const isakmp_index *, const u_int32_t));
  extern int isakmp_open __P((void));
  extern void isakmp_close __P((void));
  extern int isakmp_send __P((struct ph1handle *, vchar_t *));
  
  extern void isakmp_ph1resend_stub __P((void *));
  extern int isakmp_ph1resend __P((struct ph1handle *));
  extern void isakmp_ph2resend_stub __P((void *));
  extern int isakmp_ph2resend __P((struct ph2handle *));
  extern void isakmp_ph1expire_stub __P((void *));
  extern void isakmp_ph1expire __P((struct ph1handle *));
  extern void isakmp_ph1delete_stub __P((void *));
  extern void isakmp_ph1delete __P((struct ph1handle *));
  extern void isakmp_ph2expire_stub __P((void *));
  extern void isakmp_ph2expire __P((struct ph2handle *));
  extern void isakmp_ph2delete_stub __P((void *));
  extern void isakmp_ph2delete __P((struct ph2handle *));
  
  extern int isakmp_post_acquire __P((struct ph2handle *));
  extern int isakmp_post_getspi __P((struct ph2handle *));
--- 32,83 ----
  #define PORT_ISAKMP 500
  
  #define DEFAULT_NONCE_SIZE	16
  
  typedef u_char cookie_t[8];
  typedef u_char msgid_t[4];
  
  typedef struct { /* i_cookie + r_cookie */
  	cookie_t i_ck;
  	cookie_t r_ck;
  } isakmp_index;
  
  struct isakmp_gen;
  struct sched;
  
  struct sockaddr;
  struct ph1handle;
  struct ph2handle;
  struct remoteconf;
  struct isakmp_gen;
  struct ipsecdoi_pl_id;	/* XXX */
  struct isakmp_pl_ke;	/* XXX */
  struct isakmp_pl_nonce;	/* XXX */
  
  extern int isakmp_handler __P((int));
! extern int isakmp_ph1begin_i __P((struct remoteconf *, struct sockaddr *,
! 	struct sockaddr *));
  
  extern vchar_t *isakmp_parsewoh __P((int, struct isakmp_gen *, int));
  extern vchar_t *isakmp_parse __P((vchar_t *));
  
  extern int isakmp_init __P((void));
  extern const char *isakmp_pindex __P((const isakmp_index *, const u_int32_t));
  extern int isakmp_open __P((void));
  extern void isakmp_close __P((void));
  extern int isakmp_send __P((struct ph1handle *, vchar_t *));
  
  extern void isakmp_ph1resend_stub __P((void *));
  extern int isakmp_ph1resend __P((struct ph1handle *));
  extern void isakmp_ph2resend_stub __P((void *));
  extern int isakmp_ph2resend __P((struct ph2handle *));
  extern void isakmp_ph1expire_stub __P((void *));
  extern void isakmp_ph1expire __P((struct ph1handle *));
  extern void isakmp_ph1delete_stub __P((void *));
  extern void isakmp_ph1delete __P((struct ph1handle *));
  extern void isakmp_ph2expire_stub __P((void *));
  extern void isakmp_ph2expire __P((struct ph2handle *));
  extern void isakmp_ph2delete_stub __P((void *));
  extern void isakmp_ph2delete __P((struct ph2handle *));
  
  extern int isakmp_post_acquire __P((struct ph2handle *));
  extern int isakmp_post_getspi __P((struct ph2handle *));
diff -Nr -c25 ac_am/src/racoon/kmpstat.c ac_am_fixed/src/racoon/kmpstat.c
*** ac_am/src/racoon/kmpstat.c	2003-03-07 00:19:34.000000000 +0100
--- ac_am_fixed/src/racoon/kmpstat.c	2003-12-11 18:19:59.196048952 +0100
***************
*** 157,208 ****
  {
  	printf(
  "Usage:\n"
  "  %s reload-config\n"
  "  %s [-l [-l]] show-sa [protocol]\n"
  "  %s flush-sa [protocol]\n"
  "  %s delete-sa <saopts>\n"
  "  %s establish-sa <saopts>\n"
  "\n"
  "    <protocol>: \"isakmp\", \"esp\" or \"ah\".\n"
  "        In the case of \"show-sa\" or \"flush-sa\", you can use \"ipsec\".\n"
  "\n"
  "    <saopts>: \"isakmp\" <family> <src> <dst>\n"
  "            : {\"esp\",\"ah\"} <family> <src/prefixlen/port> <dst/prefixlen/port>\n"
  "                              <ul_proto>\n"
  "    <family>: \"inet\" or \"inet6\"\n"
  "    <ul_proto>: \"icmp\", \"tcp\", \"udp\" or \"any\"\n",
  	pname, pname, pname, pname, pname);
  }
  
  int
  main(ac, av)
  	int ac;
  	char **av;
  {
- 	extern char *optarg;
- 	extern int optind;
  	vchar_t *combuf;
  	int c;
  
  	pname = *av;
  
  	while ((c = getopt(ac, av, "ld")) != -1) {
  		switch(c) {
  		case 'l':
  			long_format++;
  			break;
  
  		case 'd':
  			loglevel++;
  			break;
  
  		default:
  			usage();
  			exit(0);
  		}
  	}
  
  	ac -= optind;
  	av += optind;
  
  	combuf = get_combuf(ac, av);
--- 157,206 ----
diff -Nr -c25 ac_am/src/racoon/missing/crypto/sha2/sha2.c ac_am_fixed/src/racoon/missing/crypto/sha2/sha2.c
*** ac_am/src/racoon/missing/crypto/sha2/sha2.c	2003-03-06 23:07:24.000000000 +0100
--- ac_am_fixed/src/racoon/missing/crypto/sha2/sha2.c	2003-12-11 18:19:59.201048192 +0100
***************
*** 601,672 ****
  
  			/* Begin padding with a 1 bit: */
  			*context->buffer = 0x80;
  		}
  		/* Set the bit count: */
  		*(sha2_word64*)&context->buffer[SHA256_SHORT_BLOCK_LENGTH] = context->bitcount;
  
  		/* Final transform: */
  		SHA256_Transform(context, (sha2_word32*)context->buffer);
  
  #if BYTE_ORDER == LITTLE_ENDIAN
  		{
  			/* Convert TO host byte order */
  			int	j;
  			for (j = 0; j < 8; j++) {
  				REVERSE32(context->state[j],context->state[j]);
  				*d++ = context->state[j];
  			}
  		}
  #else
  		bcopy(context->state, d, SHA256_DIGEST_LENGTH);
  #endif
  	}
  
  	/* Clean up state data: */
! 	bzero(context, sizeof(context));
  	usedspace = 0;
  }
  
  char *SHA256_End(SHA256_CTX* context, char buffer[]) {
  	sha2_byte	digest[SHA256_DIGEST_LENGTH], *d = digest;
  	int		i;
  
  	/* Sanity check: */
  	assert(context != (SHA256_CTX*)0);
  
  	if (buffer != (char*)0) {
  		SHA256_Final(digest, context);
  
  		for (i = 0; i < SHA256_DIGEST_LENGTH; i++) {
  			*buffer++ = sha2_hex_digits[(*d & 0xf0) >> 4];
  			*buffer++ = sha2_hex_digits[*d & 0x0f];
  			d++;
  		}
  		*buffer = (char)0;
  	} else {
! 		bzero(context, sizeof(context));
  	}
  	bzero(digest, SHA256_DIGEST_LENGTH);
  	return buffer;
  }
  
  char* SHA256_Data(const sha2_byte* data, size_t len, char digest[SHA256_DIGEST_STRING_LENGTH]) {
  	SHA256_CTX	context;
  
  	SHA256_Init(&context);
  	SHA256_Update(&context, data, len);
  	return SHA256_End(&context, digest);
  }
  
  
  /*** SHA-512: *********************************************************/
  void SHA512_Init(SHA512_CTX* context) {
  	if (context == (SHA512_CTX*)0) {
  		return;
  	}
  	bcopy(sha512_initial_hash_value, context->state, SHA512_DIGEST_LENGTH);
  	bzero(context->buffer, SHA512_BLOCK_LENGTH);
  	context->bitcount[0] = context->bitcount[1] =  0;
  }
  
  #ifdef SHA2_UNROLL_TRANSFORM
--- 601,672 ----
  
  			/* Begin padding with a 1 bit: */
  			*context->buffer = 0x80;
  		}
  		/* Set the bit count: */
  		*(sha2_word64*)&context->buffer[SHA256_SHORT_BLOCK_LENGTH] = context->bitcount;
  
  		/* Final transform: */
  		SHA256_Transform(context, (sha2_word32*)context->buffer);
  
  #if BYTE_ORDER == LITTLE_ENDIAN
  		{
  			/* Convert TO host byte order */
  			int	j;
  			for (j = 0; j < 8; j++) {
  				REVERSE32(context->state[j],context->state[j]);
  				*d++ = context->state[j];
  			}
  		}
  #else
  		bcopy(context->state, d, SHA256_DIGEST_LENGTH);
  #endif
  	}
  
  	/* Clean up state data: */
! 	bzero(context, sizeof(*context));
  	usedspace = 0;
  }
  
  char *SHA256_End(SHA256_CTX* context, char buffer[]) {
  	sha2_byte	digest[SHA256_DIGEST_LENGTH], *d = digest;
  	int		i;
  
  	/* Sanity check: */
  	assert(context != (SHA256_CTX*)0);
  
  	if (buffer != (char*)0) {
  		SHA256_Final(digest, context);
  
  		for (i = 0; i < SHA256_DIGEST_LENGTH; i++) {
  			*buffer++ = sha2_hex_digits[(*d & 0xf0) >> 4];
  			*buffer++ = sha2_hex_digits[*d & 0x0f];
  			d++;
  		}
  		*buffer = (char)0;
  	} else {
! 		bzero(context, sizeof(*context));
  	}
  	bzero(digest, SHA256_DIGEST_LENGTH);
  	return buffer;
  }
  
  char* SHA256_Data(const sha2_byte* data, size_t len, char digest[SHA256_DIGEST_STRING_LENGTH]) {
  	SHA256_CTX	context;
  
  	SHA256_Init(&context);
  	SHA256_Update(&context, data, len);
  	return SHA256_End(&context, digest);
  }
  
  
  /*** SHA-512: *********************************************************/
  void SHA512_Init(SHA512_CTX* context) {
  	if (context == (SHA512_CTX*)0) {
  		return;
  	}
  	bcopy(sha512_initial_hash_value, context->state, SHA512_DIGEST_LENGTH);
  	bzero(context->buffer, SHA512_BLOCK_LENGTH);
  	context->bitcount[0] = context->bitcount[1] =  0;
  }
  
  #ifdef SHA2_UNROLL_TRANSFORM
***************
*** 931,1001 ****
  	sha2_word64	*d = (sha2_word64*)digest;
  
  	/* Sanity check: */
  	assert(context != (SHA512_CTX*)0);
  
  	/* If no digest buffer is passed, we don't bother doing this: */
  	if (digest != (sha2_byte*)0) {
  		SHA512_Last(context);
  
  		/* Save the hash data for output: */
  #if BYTE_ORDER == LITTLE_ENDIAN
  		{
  			/* Convert TO host byte order */
  			int	j;
  			for (j = 0; j < 8; j++) {
  				REVERSE64(context->state[j],context->state[j]);
  				*d++ = context->state[j];
  			}
  		}
  #else
  		bcopy(context->state, d, SHA512_DIGEST_LENGTH);
  #endif
  	}
  
  	/* Zero out state data */
! 	bzero(context, sizeof(context));
  }
  
  char *SHA512_End(SHA512_CTX* context, char buffer[]) {
  	sha2_byte	digest[SHA512_DIGEST_LENGTH], *d = digest;
  	int		i;
  
  	/* Sanity check: */
  	assert(context != (SHA512_CTX*)0);
  
  	if (buffer != (char*)0) {
  		SHA512_Final(digest, context);
  
  		for (i = 0; i < SHA512_DIGEST_LENGTH; i++) {
  			*buffer++ = sha2_hex_digits[(*d & 0xf0) >> 4];
  			*buffer++ = sha2_hex_digits[*d & 0x0f];
  			d++;
  		}
  		*buffer = (char)0;
  	} else {
! 		bzero(context, sizeof(context));
  	}
  	bzero(digest, SHA512_DIGEST_LENGTH);
  	return buffer;
  }
  
  char* SHA512_Data(const sha2_byte* data, size_t len, char digest[SHA512_DIGEST_STRING_LENGTH]) {
  	SHA512_CTX	context;
  
  	SHA512_Init(&context);
  	SHA512_Update(&context, data, len);
  	return SHA512_End(&context, digest);
  }
  
  
  /*** SHA-384: *********************************************************/
  void SHA384_Init(SHA384_CTX* context) {
  	if (context == (SHA384_CTX*)0) {
  		return;
  	}
  	bcopy(sha384_initial_hash_value, context->state, SHA512_DIGEST_LENGTH);
  	bzero(context->buffer, SHA384_BLOCK_LENGTH);
  	context->bitcount[0] = context->bitcount[1] = 0;
  }
  
  void SHA384_Update(SHA384_CTX* context, const sha2_byte* data, size_t len) {
--- 931,1001 ----
  	sha2_word64	*d = (sha2_word64*)digest;
  
  	/* Sanity check: */
  	assert(context != (SHA512_CTX*)0);
  
  	/* If no digest buffer is passed, we don't bother doing this: */
  	if (digest != (sha2_byte*)0) {
  		SHA512_Last(context);
  
  		/* Save the hash data for output: */
  #if BYTE_ORDER == LITTLE_ENDIAN
  		{
  			/* Convert TO host byte order */
  			int	j;
  			for (j = 0; j < 8; j++) {
  				REVERSE64(context->state[j],context->state[j]);
  				*d++ = context->state[j];
  			}
  		}
  #else
  		bcopy(context->state, d, SHA512_DIGEST_LENGTH);
  #endif
  	}
  
  	/* Zero out state data */
! 	bzero(context, sizeof(*context));
  }
  
  char *SHA512_End(SHA512_CTX* context, char buffer[]) {
  	sha2_byte	digest[SHA512_DIGEST_LENGTH], *d = digest;
  	int		i;
  
  	/* Sanity check: */
  	assert(context != (SHA512_CTX*)0);
  
  	if (buffer != (char*)0) {
  		SHA512_Final(digest, context);
  
  		for (i = 0; i < SHA512_DIGEST_LENGTH; i++) {
  			*buffer++ = sha2_hex_digits[(*d & 0xf0) >> 4];
  			*buffer++ = sha2_hex_digits[*d & 0x0f];
  			d++;
  		}
  		*buffer = (char)0;
  	} else {
! 		bzero(context, sizeof(*context));
  	}
  	bzero(digest, SHA512_DIGEST_LENGTH);
  	return buffer;
  }
  
  char* SHA512_Data(const sha2_byte* data, size_t len, char digest[SHA512_DIGEST_STRING_LENGTH]) {
  	SHA512_CTX	context;
  
  	SHA512_Init(&context);
  	SHA512_Update(&context, data, len);
  	return SHA512_End(&context, digest);
  }
  
  
  /*** SHA-384: *********************************************************/
  void SHA384_Init(SHA384_CTX* context) {
  	if (context == (SHA384_CTX*)0) {
  		return;
  	}
  	bcopy(sha384_initial_hash_value, context->state, SHA512_DIGEST_LENGTH);
  	bzero(context->buffer, SHA384_BLOCK_LENGTH);
  	context->bitcount[0] = context->bitcount[1] = 0;
  }
  
  void SHA384_Update(SHA384_CTX* context, const sha2_byte* data, size_t len) {
***************
*** 1006,1076 ****
  	sha2_word64	*d = (sha2_word64*)digest;
  
  	/* Sanity check: */
  	assert(context != (SHA384_CTX*)0);
  
  	/* If no digest buffer is passed, we don't bother doing this: */
  	if (digest != (sha2_byte*)0) {
  		SHA512_Last((SHA512_CTX*)context);
  
  		/* Save the hash data for output: */
  #if BYTE_ORDER == LITTLE_ENDIAN
  		{
  			/* Convert TO host byte order */
  			int	j;
  			for (j = 0; j < 6; j++) {
  				REVERSE64(context->state[j],context->state[j]);
  				*d++ = context->state[j];
  			}
  		}
  #else
  		bcopy(context->state, d, SHA384_DIGEST_LENGTH);
  #endif
  	}
  
  	/* Zero out state data */
! 	bzero(context, sizeof(context));
  }
  
  char *SHA384_End(SHA384_CTX* context, char buffer[]) {
  	sha2_byte	digest[SHA384_DIGEST_LENGTH], *d = digest;
  	int		i;
  
  	/* Sanity check: */
  	assert(context != (SHA384_CTX*)0);
  
  	if (buffer != (char*)0) {
  		SHA384_Final(digest, context);
  
  		for (i = 0; i < SHA384_DIGEST_LENGTH; i++) {
  			*buffer++ = sha2_hex_digits[(*d & 0xf0) >> 4];
  			*buffer++ = sha2_hex_digits[*d & 0x0f];
  			d++;
  		}
  		*buffer = (char)0;
  	} else {
! 		bzero(context, sizeof(context));
  	}
  	bzero(digest, SHA384_DIGEST_LENGTH);
  	return buffer;
  }
  
  char* SHA384_Data(const sha2_byte* data, size_t len, char digest[SHA384_DIGEST_STRING_LENGTH]) {
  	SHA384_CTX	context;
  
  	SHA384_Init(&context);
  	SHA384_Update(&context, data, len);
  	return SHA384_End(&context, digest);
  }
  
  /*glue*/
  #ifdef HAVE_EVP_097
  
  /* SHA256 */
  #define data(ctx) ((SHA256_CTX *)(ctx)->md_data)
  static int sha256_init(EVP_MD_CTX *ctx)
  {
    SHA256_Init(data(ctx));
    return 1;
  }
  static int sha256_update(EVP_MD_CTX *ctx, const void *data, unsigned long count)
  {
--- 1006,1076 ----
  	sha2_word64	*d = (sha2_word64*)digest;
  
  	/* Sanity check: */
  	assert(context != (SHA384_CTX*)0);
  
  	/* If no digest buffer is passed, we don't bother doing this: */
  	if (digest != (sha2_byte*)0) {
  		SHA512_Last((SHA512_CTX*)context);
  
  		/* Save the hash data for output: */
  #if BYTE_ORDER == LITTLE_ENDIAN
  		{
  			/* Convert TO host byte order */
  			int	j;
  			for (j = 0; j < 6; j++) {
  				REVERSE64(context->state[j],context->state[j]);
  				*d++ = context->state[j];
  			}
  		}
  #else
  		bcopy(context->state, d, SHA384_DIGEST_LENGTH);
  #endif
  	}
  
  	/* Zero out state data */
! 	bzero(context, sizeof(*context));
  }
  
  char *SHA384_End(SHA384_CTX* context, char buffer[]) {
  	sha2_byte	digest[SHA384_DIGEST_LENGTH], *d = digest;
  	int		i;
  
  	/* Sanity check: */
  	assert(context != (SHA384_CTX*)0);
  
  	if (buffer != (char*)0) {
  		SHA384_Final(digest, context);
  
  		for (i = 0; i < SHA384_DIGEST_LENGTH; i++) {
  			*buffer++ = sha2_hex_digits[(*d & 0xf0) >> 4];
  			*buffer++ = sha2_hex_digits[*d & 0x0f];
  			d++;
  		}
  		*buffer = (char)0;
  	} else {
! 		bzero(context, sizeof(*context));
  	}
  	bzero(digest, SHA384_DIGEST_LENGTH);
  	return buffer;
  }
  
  char* SHA384_Data(const sha2_byte* data, size_t len, char digest[SHA384_DIGEST_STRING_LENGTH]) {
  	SHA384_CTX	context;
  
  	SHA384_Init(&context);
  	SHA384_Update(&context, data, len);
  	return SHA384_End(&context, digest);
  }
  
  /*glue*/
  #ifdef HAVE_EVP_097
  
  /* SHA256 */
  #define data(ctx) ((SHA256_CTX *)(ctx)->md_data)
  static int sha256_init(EVP_MD_CTX *ctx)
  {
    SHA256_Init(data(ctx));
    return 1;
  }
  static int sha256_update(EVP_MD_CTX *ctx, const void *data, unsigned long count)
  {
diff -Nr -c25 ac_am/src/racoon/oakley.c ac_am_fixed/src/racoon/oakley.c
*** ac_am/src/racoon/oakley.c	2003-03-04 00:30:51.000000000 +0100
--- ac_am_fixed/src/racoon/oakley.c	2003-12-11 18:19:59.205047584 +0100
***************
*** 83,132 ****
--- 83,134 ----
  #endif
  
  #define OUTBOUND_SA	0
  #define INBOUND_SA	1
  
  #define INITDHVAL(a, s, d, t)                                                  \
  do {                                                                           \
  	vchar_t buf;                                                           \
  	buf.v = str2val((s), 16, &buf.l);                                      \
  	memset(&a, 0, sizeof(struct dhgroup));                                 \
  	a.type = (t);                                                          \
  	a.prime = vdup(&buf);                                                  \
  	a.gen1 = 2;                                                            \
  	a.gen2 = 0;                                                            \
  } while(0);
  
  struct dhgroup dh_modp768;
  struct dhgroup dh_modp1024;
  struct dhgroup dh_modp1536;
  struct dhgroup dh_modp2048;
  struct dhgroup dh_modp3072;
  struct dhgroup dh_modp4096;
  struct dhgroup dh_modp6144;
  struct dhgroup dh_modp8192;
  
+ 
+ static int oakley_check_dh_pub __P((vchar_t *, vchar_t **));
  static int oakley_compute_keymat_x __P((struct ph2handle *, int, int));
  #ifdef HAVE_SIGNING_C
  static int get_cert_fromlocal __P((struct ph1handle *, int));
  static int oakley_check_certid __P((struct ph1handle *iph1));
  static int check_typeofcertname __P((int, int));
  static cert_t *save_certbuf __P((struct isakmp_gen *));
  #endif
  static int oakley_padlen __P((int, int));
  
  int
  oakley_get_defaultlifetime()
  {
  	return OAKLEY_ATTR_SA_LD_SEC_DEFAULT;
  }
  
  int
  oakley_dhinit()
  {
  	/* set DH MODP */
  	INITDHVAL(dh_modp768, OAKLEY_PRIME_MODP768,
  		OAKLEY_ATTR_GRP_DESC_MODP768, OAKLEY_ATTR_GRP_TYPE_MODP);
  	INITDHVAL(dh_modp1024, OAKLEY_PRIME_MODP1024,
  		OAKLEY_ATTR_GRP_DESC_MODP1024, OAKLEY_ATTR_GRP_TYPE_MODP);
  	INITDHVAL(dh_modp1536, OAKLEY_PRIME_MODP1536,
  		OAKLEY_ATTR_GRP_DESC_MODP1536, OAKLEY_ATTR_GRP_TYPE_MODP);
***************
*** 138,187 ****
--- 140,227 ----
  		OAKLEY_ATTR_GRP_DESC_MODP4096, OAKLEY_ATTR_GRP_TYPE_MODP);
  	INITDHVAL(dh_modp6144, OAKLEY_PRIME_MODP6144,
  		OAKLEY_ATTR_GRP_DESC_MODP6144, OAKLEY_ATTR_GRP_TYPE_MODP);
  	INITDHVAL(dh_modp8192, OAKLEY_PRIME_MODP8192,
  		OAKLEY_ATTR_GRP_DESC_MODP8192, OAKLEY_ATTR_GRP_TYPE_MODP);
  
  	return 0;
  }
  
  void
  oakley_dhgrp_free(dhgrp)
  	struct dhgroup *dhgrp;
  {
  	if (dhgrp->prime)
  		vfree(dhgrp->prime);
  	if (dhgrp->curve_a)
  		vfree(dhgrp->curve_a);
  	if (dhgrp->curve_b)
  		vfree(dhgrp->curve_b);
  	if (dhgrp->order)
  		vfree(dhgrp->order);
  	racoon_free(dhgrp);
  }
  
  /*
+  * RFC2409 5
+  * The length of the Diffie-Hellman public value MUST be equal to the
+  * length of the prime modulus over which the exponentiation was
+  * performed, prepending zero bits to the value if necessary.
+  */
+ static int
+ oakley_check_dh_pub(prime, pub0)
+ 	vchar_t *prime, **pub0;
+ {
+ 	vchar_t *tmp;
+ 	vchar_t *pub = *pub0;
+ 
+ 	if (prime->l == pub->l)
+ 		return 0;
+ 
+ 	if (prime->l < pub->l) {
+ 		/* what should i do ? */
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"invalid public information was generated.\n");
+ 		return -1;
+ 	}
+ 
+ 	/* prime->l > pub->l */
+ 	tmp = vmalloc(prime->l);
+ 	if (tmp == NULL) {
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"failed to get DH buffer.\n");
+ 		return -1;
+ 	}
+ 	memcpy(tmp->v + prime->l - pub->l, pub->v, pub->l);
+ 
+ 	vfree(*pub0);
+ 	*pub0 = tmp;
+ 
+ 	return 0;
+ }
+ 
+ /*
   * compute sharing secret of DH
   * IN:	*dh, *pub, *priv, *pub_p
   * OUT: **gxy
   */
  int
  oakley_dh_compute(dh, pub, priv, pub_p, gxy)
  	const struct dhgroup *dh;
  	vchar_t *pub, *priv, *pub_p, **gxy;
  {
  #ifdef ENABLE_STATS
  	struct timeval start, end;
  #endif
  	if ((*gxy = vmalloc(dh->prime->l)) == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to get DH buffer.\n");
  		return -1;
  	}
  
  #ifdef ENABLE_STATS
  	gettimeofday(&start, NULL);
  #endif
  	switch (dh->type) {
  	case OAKLEY_ATTR_GRP_TYPE_MODP:
  		if (eay_dh_compute(dh->prime, dh->gen1, pub, priv, pub_p, gxy) < 0) {
  			plog(LLV_ERROR, LOCATION, NULL,
***************
*** 231,280 ****
--- 271,324 ----
  	case OAKLEY_ATTR_GRP_TYPE_MODP:
  		if (eay_dh_generate(dh->prime, dh->gen1, dh->gen2, pub, priv) < 0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"failed to compute dh value.\n");
  			return -1;
  		}
  		break;
  
  	case OAKLEY_ATTR_GRP_TYPE_ECP:
  	case OAKLEY_ATTR_GRP_TYPE_EC2N:
  		plog(LLV_ERROR, LOCATION, NULL,
  			"dh type %d isn't supported.\n", dh->type);
  		return -1;
  	default:
  		plog(LLV_ERROR, LOCATION, NULL,
  			"invalid dh type %d.\n", dh->type);
  		return -1;
  	}
  
  #ifdef ENABLE_STATS
  	gettimeofday(&end, NULL);
  	syslog(LOG_NOTICE, "%s(%s%d): %8.6f", __func__,
  		s_attr_isakmp_group(dh->type), dh->prime->l << 3,
  		timedelta(&start, &end));
  #endif
+ 
+ 	if (oakley_check_dh_pub(dh->prime, pub) != 0)
+ 		return -1;
+ 
  	plog(LLV_DEBUG, LOCATION, NULL, "compute DH's private.\n");
  	plogdump(LLV_DEBUG, (*priv)->v, (*priv)->l);
  	plog(LLV_DEBUG, LOCATION, NULL, "compute DH's public.\n");
  	plogdump(LLV_DEBUG, (*pub)->v, (*pub)->l);
  
  	return 0;
  }
  
  /*
   * copy pre-defined dhgroup values.
   */
  int
  oakley_setdhgroup(group, dhgrp)
  	int group;
  	struct dhgroup **dhgrp;
  {
  	struct dhgroup *g;
  
  	*dhgrp = NULL;	/* just make sure, initialize */
  
  	g = alg_oakley_dhdef_group(group);
  	if (g == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"invalid DH parameter grp=%d.\n", group);
  		return -1;
diff -Nr -c25 ac_am/src/racoon/pfkey.c ac_am_fixed/src/racoon/pfkey.c
*** ac_am/src/racoon/pfkey.c	2003-03-04 00:56:57.000000000 +0100
--- ac_am_fixed/src/racoon/pfkey.c	2003-12-11 18:19:59.214046216 +0100
***************
*** 742,831 ****
  		saddrwop2str(iph2->dst));
  	SCHED_KILL(iph2->sce);
  
  	/* If initiator side, send error to kernel by SADB_ACQUIRE. */
  	if (iph2->side == INITIATOR)
  		pk_sendeacquire(iph2);
  
  	unbindph12(iph2);
  	remph2(iph2);
  	delph2(iph2);
  
  	return;
  }
  
  /*%%%*/
  /* send getspi message per ipsec protocol per remote address */
  /*
   * the local address and remote address in ph1handle are dealed
   * with destination address and source address respectively.
   * Because SPI is decided by responder.
   */
  int
  pk_sendgetspi(iph2)
  	struct ph2handle *iph2;
  {
  	u_int satype, mode;
  	struct saprop *pp;
  	struct saproto *pr;
  
! 	pp = iph2->side == INITIATOR
! 			? iph2->proposal
! 			: iph2->approval;
  
  	for (pr = pp->head; pr != NULL; pr = pr->next) {
! 
! 		/* validity check */
  		satype = ipsecdoi2pfkey_proto(pr->proto_id);
  		if (satype == ~0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"invalid proto_id %d\n", pr->proto_id);
! 			return -1;
  		}
  		mode = ipsecdoi2pfkey_mode(pr->encmode);
  		if (mode == ~0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"invalid encmode %d\n", pr->encmode);
  			return -1;
  		}
  
  		plog(LLV_DEBUG, LOCATION, NULL, "call pfkey_send_getspi\n");
  		if (pfkey_send_getspi(
  				lcconf->sock_pfkey,
  				satype,
  				mode,
! 				iph2->dst,		/* src of SA */
! 				iph2->src,		/* dst of SA */
  				0, 0, pr->reqid_in, iph2->seq) < 0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"ipseclib failed send getspi (%s)\n",
  				ipsec_strerror());
  			return -1;
  		}
  		plog(LLV_DEBUG, LOCATION, NULL,
  			"pfkey GETSPI sent: %s\n",
! 			sadbsecas2str(iph2->dst, iph2->src, satype, 0, mode));
  	}
  
  	return 0;
  }
  
  /*
   * receive GETSPI from kernel.
   */
  static int
  pk_recvgetspi(mhp) 
  	caddr_t *mhp;
  {
  	struct sadb_msg *msg;
  	struct sadb_sa *sa;
  	struct ph2handle *iph2;
  	struct sockaddr *dst;
  	int proto_id;
  	int allspiok, notfound;
  	struct saprop *pp;
  	struct saproto *pr;
  
  	/* validity check */
  	if (mhp[SADB_EXT_SA] == NULL
  	 || mhp[SADB_EXT_ADDRESS_DST] == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
--- 742,846 ----
  		saddrwop2str(iph2->dst));
  	SCHED_KILL(iph2->sce);
  
  	/* If initiator side, send error to kernel by SADB_ACQUIRE. */
  	if (iph2->side == INITIATOR)
  		pk_sendeacquire(iph2);
  
  	unbindph12(iph2);
  	remph2(iph2);
  	delph2(iph2);
  
  	return;
  }
  
  /*%%%*/
  /* send getspi message per ipsec protocol per remote address */
  /*
   * the local address and remote address in ph1handle are dealed
   * with destination address and source address respectively.
   * Because SPI is decided by responder.
   */
  int
  pk_sendgetspi(iph2)
  	struct ph2handle *iph2;
  {
+ 	struct sockaddr *src = NULL, *dst = NULL;
  	u_int satype, mode;
  	struct saprop *pp;
  	struct saproto *pr;
+ 	int proxy = 0;
  
! 	if (iph2->side == INITIATOR) {
! 		pp = iph2->proposal;
! 		proxy = iph2->ph1->rmconf->support_proxy;
! 	} else {
! 		pp = iph2->approval;
! 		if (iph2->sainfo && iph2->sainfo->id_i)
! 			proxy = 1;
! 	}
  
+ 	/* for mobile IPv6 */
+ 	if (proxy && iph2->src_id && iph2->dst_id &&
+ 	    ipsecdoi_transportmode(pp)) {
+ 		src = iph2->src_id;
+ 		dst = iph2->dst_id;
+ 	} else {
+ 		src = iph2->src;
+ 		dst = iph2->dst;
+ 	}
  	for (pr = pp->head; pr != NULL; pr = pr->next) {
! 		/* validity check */ 
  		satype = ipsecdoi2pfkey_proto(pr->proto_id);
  		if (satype == ~0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"invalid proto_id %d\n", pr->proto_id);
! 	      		return -1;
  		}
  		mode = ipsecdoi2pfkey_mode(pr->encmode);
  		if (mode == ~0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"invalid encmode %d\n", pr->encmode);
  			return -1;
  		}
  
  		plog(LLV_DEBUG, LOCATION, NULL, "call pfkey_send_getspi\n");
  		if (pfkey_send_getspi(
  				lcconf->sock_pfkey,
  				satype,
  				mode,
! 				dst,			/* src of SA */
! 				src,			/* dst of SA */
  				0, 0, pr->reqid_in, iph2->seq) < 0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"ipseclib failed send getspi (%s)\n",
  				ipsec_strerror());
  			return -1;
  		}
  		plog(LLV_DEBUG, LOCATION, NULL,
  			"pfkey GETSPI sent: %s\n",
! 			sadbsecas2str(dst, src, satype, 0, mode));
  	}
  
  	return 0;
  }
  
  /*
   * receive GETSPI from kernel.
   */
  static int
  pk_recvgetspi(mhp) 
  	caddr_t *mhp;
  {
  	struct sadb_msg *msg;
  	struct sadb_sa *sa;
  	struct ph2handle *iph2;
  	struct sockaddr *dst;
  	int proto_id;
  	int allspiok, notfound;
  	struct saprop *pp;
  	struct saproto *pr;
  
  	/* validity check */
  	if (mhp[SADB_EXT_SA] == NULL
  	 || mhp[SADB_EXT_ADDRESS_DST] == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
***************
*** 897,1042 ****
  			plog(LLV_ERROR, LOCATION, NULL,
  				"failed to start post getspi.\n");
  			unbindph12(iph2);
  			remph2(iph2);
  			delph2(iph2);
  			iph2 = NULL;
  			return -1;
  		}
  	}
  
  	return 0;
  }
  
  /*
   * set inbound SA
   */
  int
  pk_sendupdate(iph2)
  	struct ph2handle *iph2;
  {
  	struct saproto *pr;
  	struct sockaddr *src = NULL, *dst = NULL;
  	int e_type, e_keylen, a_type, a_keylen, flags;
  	u_int satype, mode;
  	u_int64_t lifebyte = 0;
  
  	/* sanity check */
  	if (iph2->approval == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"no approvaled SAs found.\n");
  	}
  
  	/* for mobile IPv6 */
! 	if (iph2->ph1->rmconf->support_mip6 && iph2->src_id && iph2->dst_id) {
  		src = iph2->src_id;
  		dst = iph2->dst_id;
  	} else {
  		src = iph2->src;
  		dst = iph2->dst;
  	}
  
  	for (pr = iph2->approval->head; pr != NULL; pr = pr->next) {
  		/* validity check */
  		satype = ipsecdoi2pfkey_proto(pr->proto_id);
  		if (satype == ~0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"invalid proto_id %d\n", pr->proto_id);
  			return -1;
  		}
  #ifdef ENABLE_SAMODE_UNSPECIFIED
  		mode = IPSEC_MODE_ANY;
  #else
  		mode = ipsecdoi2pfkey_mode(pr->encmode);
  		if (mode == ~0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"invalid encmode %d\n", pr->encmode);
  			return -1;
  		}
  #endif
  
  		/* set algorithm type and key length */
  		e_keylen = pr->head->encklen;
  		if (pfkey_convertfromipsecdoi(
  				pr->proto_id,
  				pr->head->trns_id,
  				pr->head->authtype,
  				&e_type, &e_keylen,
  				&a_type, &a_keylen, &flags) < 0)
  			return -1;
  
  #if 0
  		lifebyte = iph2->approval->lifebyte * 1024,
  #else
  		lifebyte = 0;
  #endif
  
  		plog(LLV_DEBUG, LOCATION, NULL, "call pfkey_send_update\n");
  
  		if (pfkey_send_update(
  				lcconf->sock_pfkey,
  				satype,
  				mode,
! 				iph2->dst,
! 				iph2->src,
  				pr->spi,
  				pr->reqid_in,
  				4,	/* XXX static size of window */
  				pr->keymat->v,
  				e_type, e_keylen, a_type, a_keylen, flags,
  				0, lifebyte, iph2->approval->lifetime, 0,
  				iph2->seq) < 0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"libipsec failed send update (%s)\n",
  				ipsec_strerror());
  			return -1;
  		}
  
  		if (!lcconf->pathinfo[LC_PATHTYPE_BACKUPSA])
  			continue;
  
  		/*
  		 * It maybe good idea to call backupsa_to_file() after
  		 * racoon will receive the sadb_update messages.
  		 * But it is impossible because there is not key in the
  		 * information from the kernel.
  		 */
! 		if (backupsa_to_file(satype, mode, iph2->dst, iph2->src,
  				pr->spi, pr->reqid_in, 4,
  				pr->keymat->v,
  				e_type, e_keylen, a_type, a_keylen, flags,
  				0, iph2->approval->lifebyte * 1024,
  				iph2->approval->lifetime, 0,
  				iph2->seq) < 0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"backuped SA failed: %s\n",
! 				sadbsecas2str(iph2->dst, iph2->src,
  				satype, pr->spi, mode));
  		}
  		plog(LLV_DEBUG, LOCATION, NULL,
  			"backuped SA: %s\n",
! 			sadbsecas2str(iph2->dst, iph2->src,
  			satype, pr->spi, mode));
  	}
  
  	return 0;
  }
  
  static int
  pk_recvupdate(mhp)
  	caddr_t *mhp;
  {
  	struct sadb_msg *msg;
  	struct sadb_sa *sa;
  	struct sockaddr *src, *dst;
  	struct ph2handle *iph2;
  	u_int proto_id, encmode, sa_mode;
  	int incomplete = 0;
  	struct saproto *pr;
  
  	/* ignore this message because of local test mode. */
  	if (f_local)
  		return 0;
  
  	/* sanity check */
  	if (mhp[0] == NULL
  	 || mhp[SADB_EXT_SA] == NULL
--- 912,1064 ----
  			plog(LLV_ERROR, LOCATION, NULL,
  				"failed to start post getspi.\n");
  			unbindph12(iph2);
  			remph2(iph2);
  			delph2(iph2);
  			iph2 = NULL;
  			return -1;
  		}
  	}
  
  	return 0;
  }
  
  /*
   * set inbound SA
   */
  int
  pk_sendupdate(iph2)
  	struct ph2handle *iph2;
  {
  	struct saproto *pr;
  	struct sockaddr *src = NULL, *dst = NULL;
  	int e_type, e_keylen, a_type, a_keylen, flags;
  	u_int satype, mode;
  	u_int64_t lifebyte = 0;
+ 	int proxy = 0;
  
  	/* sanity check */
  	if (iph2->approval == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"no approvaled SAs found.\n");
  	}
  
+ 	if (iph2->side == INITIATOR)
+ 		proxy = iph2->ph1->rmconf->support_proxy;
+ 	else if (iph2->sainfo && iph2->sainfo->id_i)
+ 		proxy = 1;
+ 
  	/* for mobile IPv6 */
! 	if (proxy && iph2->src_id && iph2->dst_id &&
! 	    ipsecdoi_transportmode(iph2->approval)) {
  		src = iph2->src_id;
  		dst = iph2->dst_id;
  	} else {
  		src = iph2->src;
  		dst = iph2->dst;
  	}
  
  	for (pr = iph2->approval->head; pr != NULL; pr = pr->next) {
  		/* validity check */
  		satype = ipsecdoi2pfkey_proto(pr->proto_id);
  		if (satype == ~0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"invalid proto_id %d\n", pr->proto_id);
  			return -1;
  		}
  #ifdef ENABLE_SAMODE_UNSPECIFIED
  		mode = IPSEC_MODE_ANY;
  #else
  		mode = ipsecdoi2pfkey_mode(pr->encmode);
  		if (mode == ~0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"invalid encmode %d\n", pr->encmode);
  			return -1;
  		}
  #endif
  
  		/* set algorithm type and key length */
  		e_keylen = pr->head->encklen;
  		if (pfkey_convertfromipsecdoi(
  				pr->proto_id,
  				pr->head->trns_id,
  				pr->head->authtype,
  				&e_type, &e_keylen,
  				&a_type, &a_keylen, &flags) < 0)
  			return -1;
  
  #if 0
  		lifebyte = iph2->approval->lifebyte * 1024,
  #else
  		lifebyte = 0;
  #endif
  
  		plog(LLV_DEBUG, LOCATION, NULL, "call pfkey_send_update\n");
  
  		if (pfkey_send_update(
  				lcconf->sock_pfkey,
  				satype,
  				mode,
! 				dst,
! 				src,
  				pr->spi,
  				pr->reqid_in,
  				4,	/* XXX static size of window */
  				pr->keymat->v,
  				e_type, e_keylen, a_type, a_keylen, flags,
  				0, lifebyte, iph2->approval->lifetime, 0,
  				iph2->seq) < 0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"libipsec failed send update (%s)\n",
  				ipsec_strerror());
  			return -1;
  		}
  
  		if (!lcconf->pathinfo[LC_PATHTYPE_BACKUPSA])
  			continue;
  
  		/*
  		 * It maybe good idea to call backupsa_to_file() after
  		 * racoon will receive the sadb_update messages.
  		 * But it is impossible because there is not key in the
  		 * information from the kernel.
  		 */
! 		if (backupsa_to_file(satype, mode, dst, src,
  				pr->spi, pr->reqid_in, 4,
  				pr->keymat->v,
  				e_type, e_keylen, a_type, a_keylen, flags,
  				0, iph2->approval->lifebyte * 1024,
  				iph2->approval->lifetime, 0,
  				iph2->seq) < 0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"backuped SA failed: %s\n",
! 				sadbsecas2str(dst, src,
  				satype, pr->spi, mode));
  		}
  		plog(LLV_DEBUG, LOCATION, NULL,
  			"backuped SA: %s\n",
! 			sadbsecas2str(dst, src,
  			satype, pr->spi, mode));
  	}
  
  	return 0;
  }
  
  static int
  pk_recvupdate(mhp)
  	caddr_t *mhp;
  {
  	struct sadb_msg *msg;
  	struct sadb_sa *sa;
  	struct sockaddr *src, *dst;
  	struct ph2handle *iph2;
  	u_int proto_id, encmode, sa_mode;
  	int incomplete = 0;
  	struct saproto *pr;
  
  	/* ignore this message because of local test mode. */
  	if (f_local)
  		return 0;
  
  	/* sanity check */
  	if (mhp[0] == NULL
  	 || mhp[SADB_EXT_SA] == NULL
***************
*** 1113,1283 ****
  					sa_mode));
  		}
  
  		if (pr->ok == 0)
  			incomplete = 1;
  	}
  
  	if (incomplete)
  		return 0;
  
  	/* turn off the timer for calling pfkey_timeover() */
  	SCHED_KILL(iph2->sce);
  	
  	/* update status */
  	iph2->status = PHASE2ST_ESTABLISHED;
  
  #ifdef ENABLE_STATS
  	gettimeofday(&iph2->end, NULL);
  	syslog(LOG_NOTICE, "%s(%s): %8.6f",
  		"phase2", "quick", timedelta(&iph2->start, &iph2->end));
  #endif
  
  	/* count up */
  	iph2->ph1->ph2cnt++;
  
  	/*
  	 * since we are going to reuse the phase2 handler, we need to
  	 * remain it and refresh all the references between ph1 and ph2 to use.
  	 */
  	unbindph12(iph2);
  
  	iph2->sce = sched_new(iph2->approval->lifetime,
  	    isakmp_ph2expire_stub, iph2);
  
  	plog(LLV_DEBUG, LOCATION, NULL, "===\n");
  	return 0;
  }
  
  /*
   * set outbound SA
   */
  int
  pk_sendadd(iph2)
  	struct ph2handle *iph2;
  {
  	struct saproto *pr;
  	struct sockaddr *src = NULL, *dst = NULL;
  	int e_type, e_keylen, a_type, a_keylen, flags;
  	u_int satype, mode;
  	u_int64_t lifebyte = 0;
  
  	/* sanity check */
  	if (iph2->approval == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"no approvaled SAs found.\n");
  	}
  
  	/* for mobile IPv6 */
! 	if (iph2->ph1->rmconf->support_mip6 && iph2->src_id && iph2->dst_id) {
  		src = iph2->src_id;
  		dst = iph2->dst_id;
  	} else {
  		src = iph2->src;
  		dst = iph2->dst;
  	}
  
  	for (pr = iph2->approval->head; pr != NULL; pr = pr->next) {
  		/* validity check */
  		satype = ipsecdoi2pfkey_proto(pr->proto_id);
  		if (satype == ~0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"invalid proto_id %d\n", pr->proto_id);
  			return -1;
  		}
  #ifdef ENABLE_SAMODE_UNSPECIFIED
  		mode = IPSEC_MODE_ANY;
  #else
  		mode = ipsecdoi2pfkey_mode(pr->encmode);
  		if (mode == ~0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"invalid encmode %d\n", pr->encmode);
  			return -1;
  		}
  #endif
  
  		/* set algorithm type and key length */
  		e_keylen = pr->head->encklen;
  		if (pfkey_convertfromipsecdoi(
  				pr->proto_id,
  				pr->head->trns_id,
  				pr->head->authtype,
  				&e_type, &e_keylen,
  				&a_type, &a_keylen, &flags) < 0)
  			return -1;
  
  #if 0
  		lifebyte = iph2->approval->lifebyte * 1024,
  #else
  		lifebyte = 0;
  #endif
  
  		plog(LLV_DEBUG, LOCATION, NULL, "call pfkey_send_add\n");
  
  		if (pfkey_send_add(
  				lcconf->sock_pfkey,
  				satype,
  				mode,
! 				iph2->src,
! 				iph2->dst,
  				pr->spi_p,
  				pr->reqid_out,
  				4,	/* XXX static size of window */
  				pr->keymat_p->v,
  				e_type, e_keylen, a_type, a_keylen, flags,
  				0, lifebyte, iph2->approval->lifetime, 0,
  				iph2->seq) < 0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"libipsec failed send add (%s)\n",
  				ipsec_strerror());
  			return -1;
  		}
  
  		if (!lcconf->pathinfo[LC_PATHTYPE_BACKUPSA])
  			continue;
  
  		/*
  		 * It maybe good idea to call backupsa_to_file() after
  		 * racoon will receive the sadb_update messages.
  		 * But it is impossible because there is not key in the
  		 * information from the kernel.
  		 */
! 		if (backupsa_to_file(satype, mode, iph2->src, iph2->dst,
  				pr->spi_p, pr->reqid_out, 4,
  				pr->keymat_p->v,
  				e_type, e_keylen, a_type, a_keylen, flags,
  				0, iph2->approval->lifebyte * 1024,
  				iph2->approval->lifetime, 0,
  				iph2->seq) < 0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"backuped SA failed: %s\n",
! 				sadbsecas2str(iph2->src, iph2->dst,
  				satype, pr->spi_p, mode));
  		}
  		plog(LLV_DEBUG, LOCATION, NULL,
  			"backuped SA: %s\n",
! 			sadbsecas2str(iph2->src, iph2->dst,
  			satype, pr->spi_p, mode));
  	}
  
  	return 0;
  }
  
  static int
  pk_recvadd(mhp)
  	caddr_t *mhp;
  {
  	struct sadb_msg *msg;
  	struct sadb_sa *sa;
  	struct sockaddr *src, *dst;
  	struct ph2handle *iph2;
  	u_int sa_mode;
  
  	/* ignore this message because of local test mode. */
  	if (f_local)
  		return 0;
  
  	/* sanity check */
  	if (mhp[0] == NULL
  	 || mhp[SADB_EXT_SA] == NULL
  	 || mhp[SADB_EXT_ADDRESS_SRC] == NULL
  	 || mhp[SADB_EXT_ADDRESS_DST] == NULL) {
--- 1135,1316 ----
  					sa_mode));
  		}
  
  		if (pr->ok == 0)
  			incomplete = 1;
  	}
  
  	if (incomplete)
  		return 0;
  
  	/* turn off the timer for calling pfkey_timeover() */
  	SCHED_KILL(iph2->sce);
  	
  	/* update status */
  	iph2->status = PHASE2ST_ESTABLISHED;
  
  #ifdef ENABLE_STATS
  	gettimeofday(&iph2->end, NULL);
  	syslog(LOG_NOTICE, "%s(%s): %8.6f",
  		"phase2", "quick", timedelta(&iph2->start, &iph2->end));
  #endif
  
  	/* count up */
  	iph2->ph1->ph2cnt++;
  
+ 	/* turn off schedule */
+ 	if (iph2->scr)
+ 		SCHED_KILL(iph2->scr);
+ 
  	/*
  	 * since we are going to reuse the phase2 handler, we need to
  	 * remain it and refresh all the references between ph1 and ph2 to use.
  	 */
  	unbindph12(iph2);
  
  	iph2->sce = sched_new(iph2->approval->lifetime,
  	    isakmp_ph2expire_stub, iph2);
  
  	plog(LLV_DEBUG, LOCATION, NULL, "===\n");
  	return 0;
  }
  
  /*
   * set outbound SA
   */
  int
  pk_sendadd(iph2)
  	struct ph2handle *iph2;
  {
  	struct saproto *pr;
  	struct sockaddr *src = NULL, *dst = NULL;
  	int e_type, e_keylen, a_type, a_keylen, flags;
  	u_int satype, mode;
  	u_int64_t lifebyte = 0;
+ 	int proxy = 0;
  
  	/* sanity check */
  	if (iph2->approval == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"no approvaled SAs found.\n");
  	}
  
+ 	if (iph2->side == INITIATOR)
+ 		proxy = iph2->ph1->rmconf->support_proxy;
+ 	else if (iph2->sainfo && iph2->sainfo->id_i)
+ 		proxy = 1;
+ 
  	/* for mobile IPv6 */
! 	if (proxy && iph2->src_id && iph2->dst_id &&
! 	    ipsecdoi_transportmode(iph2->approval)) {
  		src = iph2->src_id;
  		dst = iph2->dst_id;
  	} else {
  		src = iph2->src;
  		dst = iph2->dst;
  	}
  
  	for (pr = iph2->approval->head; pr != NULL; pr = pr->next) {
  		/* validity check */
  		satype = ipsecdoi2pfkey_proto(pr->proto_id);
  		if (satype == ~0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"invalid proto_id %d\n", pr->proto_id);
  			return -1;
  		}
  #ifdef ENABLE_SAMODE_UNSPECIFIED
  		mode = IPSEC_MODE_ANY;
  #else
  		mode = ipsecdoi2pfkey_mode(pr->encmode);
  		if (mode == ~0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"invalid encmode %d\n", pr->encmode);
  			return -1;
  		}
  #endif
  
  		/* set algorithm type and key length */
  		e_keylen = pr->head->encklen;
  		if (pfkey_convertfromipsecdoi(
  				pr->proto_id,
  				pr->head->trns_id,
  				pr->head->authtype,
  				&e_type, &e_keylen,
  				&a_type, &a_keylen, &flags) < 0)
  			return -1;
  
  #if 0
  		lifebyte = iph2->approval->lifebyte * 1024,
  #else
  		lifebyte = 0;
  #endif
  
  		plog(LLV_DEBUG, LOCATION, NULL, "call pfkey_send_add\n");
  
  		if (pfkey_send_add(
  				lcconf->sock_pfkey,
  				satype,
  				mode,
! 				src,
! 				dst,
  				pr->spi_p,
  				pr->reqid_out,
  				4,	/* XXX static size of window */
  				pr->keymat_p->v,
  				e_type, e_keylen, a_type, a_keylen, flags,
  				0, lifebyte, iph2->approval->lifetime, 0,
  				iph2->seq) < 0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"libipsec failed send add (%s)\n",
  				ipsec_strerror());
  			return -1;
  		}
  
  		if (!lcconf->pathinfo[LC_PATHTYPE_BACKUPSA])
  			continue;
  
  		/*
  		 * It maybe good idea to call backupsa_to_file() after
  		 * racoon will receive the sadb_update messages.
  		 * But it is impossible because there is not key in the
  		 * information from the kernel.
  		 */
! 		if (backupsa_to_file(satype, mode, src, dst,
  				pr->spi_p, pr->reqid_out, 4,
  				pr->keymat_p->v,
  				e_type, e_keylen, a_type, a_keylen, flags,
  				0, iph2->approval->lifebyte * 1024,
  				iph2->approval->lifetime, 0,
  				iph2->seq) < 0) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"backuped SA failed: %s\n",
! 				sadbsecas2str(src, dst,
  				satype, pr->spi_p, mode));
  		}
  		plog(LLV_DEBUG, LOCATION, NULL,
  			"backuped SA: %s\n",
! 			sadbsecas2str(src, dst,
  			satype, pr->spi_p, mode));
  	}
  
  	return 0;
  }
  
  static int
  pk_recvadd(mhp)
  	caddr_t *mhp;
  {
  	struct sadb_msg *msg;
  	struct sadb_sa *sa;
  	struct sockaddr *src, *dst;
  	struct ph2handle *iph2;
  	u_int sa_mode;
  
  	/* ignore this message because of local test mode. */
  	if (f_local)
  		return 0;
  
  	/* sanity check */
  	if (mhp[0] == NULL
  	 || mhp[SADB_EXT_SA] == NULL
  	 || mhp[SADB_EXT_ADDRESS_SRC] == NULL
  	 || mhp[SADB_EXT_ADDRESS_DST] == NULL) {
***************
*** 1445,1495 ****
  	struct sadb_x_policy *xpl;
  	struct secpolicy *sp_out = NULL, *sp_in = NULL;
  #define MAXNESTEDSA	5	/* XXX */
  	struct ph2handle *iph2[MAXNESTEDSA];
  	int n;	/* # of phase 2 handler */
  
  	/* ignore this message because of local test mode. */
  	if (f_local)
  		return 0;
  
  	/* sanity check */
  	if (mhp[0] == NULL
  	 || mhp[SADB_EXT_ADDRESS_SRC] == NULL
  	 || mhp[SADB_EXT_ADDRESS_DST] == NULL
  	 || mhp[SADB_X_EXT_POLICY] == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"inappropriate sadb acquire message passed.\n");
  		return -1;
  	}
  	msg = (struct sadb_msg *)mhp[0];
  	xpl = (struct sadb_x_policy *)mhp[SADB_X_EXT_POLICY];
  
  	/* ignore if type is not IPSEC_POLICY_IPSEC */
  	if (xpl->sadb_x_policy_type != IPSEC_POLICY_IPSEC) {
  		plog(LLV_DEBUG, LOCATION, NULL,
! 			"ignore SPDGET message. type is not IPsec.\n");
  		return 0;
  	}
  
  	/* ignore it if src is multicast address */
      {
  	struct sockaddr *sa = PFKEY_ADDR_SADDR(mhp[SADB_EXT_ADDRESS_DST]);
  
  	if ((sa->sa_family == AF_INET
  	  && IN_MULTICAST(ntohl(((struct sockaddr_in *)sa)->sin_addr.s_addr)))
  #ifdef INET6
  	 || (sa->sa_family == AF_INET6
  	  && IN6_IS_ADDR_MULTICAST(&((struct sockaddr_in6 *)sa)->sin6_addr))
  #endif
  	) {
  		plog(LLV_DEBUG, LOCATION, NULL,
  			"ignore due to multicast address: %s.\n",
  			saddrwop2str(sa));
  		return 0;
  	}
      }
  
  	/*
  	 * If there is a phase 2 handler against the policy identifier in
  	 * the acquire message, and if
  	 *    1. its state is less than PHASE2ST_ESTABLISHED, then racoon
--- 1478,1528 ----
  	struct sadb_x_policy *xpl;
  	struct secpolicy *sp_out = NULL, *sp_in = NULL;
  #define MAXNESTEDSA	5	/* XXX */
  	struct ph2handle *iph2[MAXNESTEDSA];
  	int n;	/* # of phase 2 handler */
  
  	/* ignore this message because of local test mode. */
  	if (f_local)
  		return 0;
  
  	/* sanity check */
  	if (mhp[0] == NULL
  	 || mhp[SADB_EXT_ADDRESS_SRC] == NULL
  	 || mhp[SADB_EXT_ADDRESS_DST] == NULL
  	 || mhp[SADB_X_EXT_POLICY] == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"inappropriate sadb acquire message passed.\n");
  		return -1;
  	}
  	msg = (struct sadb_msg *)mhp[0];
  	xpl = (struct sadb_x_policy *)mhp[SADB_X_EXT_POLICY];
  
  	/* ignore if type is not IPSEC_POLICY_IPSEC */
  	if (xpl->sadb_x_policy_type != IPSEC_POLICY_IPSEC) {
  		plog(LLV_DEBUG, LOCATION, NULL,
! 			"ignore ACQUIRE message. type is not IPsec.\n");
  		return 0;
  	}
  
  	/* ignore it if src is multicast address */
      {
  	struct sockaddr *sa = PFKEY_ADDR_SADDR(mhp[SADB_EXT_ADDRESS_DST]);
  
  	if ((sa->sa_family == AF_INET
  	  && IN_MULTICAST(ntohl(((struct sockaddr_in *)sa)->sin_addr.s_addr)))
  #ifdef INET6
  	 || (sa->sa_family == AF_INET6
  	  && IN6_IS_ADDR_MULTICAST(&((struct sockaddr_in6 *)sa)->sin6_addr))
  #endif
  	) {
  		plog(LLV_DEBUG, LOCATION, NULL,
  			"ignore due to multicast address: %s.\n",
  			saddrwop2str(sa));
  		return 0;
  	}
      }
  
  	/*
  	 * If there is a phase 2 handler against the policy identifier in
  	 * the acquire message, and if
  	 *    1. its state is less than PHASE2ST_ESTABLISHED, then racoon
***************
*** 1577,1627 ****
  		"new acquire %s\n", spidx2str(&sp_out->spidx));
  
  	/* get sainfo */
      {
  	vchar_t *idsrc, *iddst;
  
  	idsrc = ipsecdoi_sockaddr2id((struct sockaddr *)&sp_out->spidx.src,
  				sp_out->spidx.prefs, sp_out->spidx.ul_proto);
  	if (idsrc == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to get ID for %s\n",
  			spidx2str(&sp_out->spidx));
  		delph2(iph2[n]);
  		return -1;
  	}
  	iddst = ipsecdoi_sockaddr2id((struct sockaddr *)&sp_out->spidx.dst,
  				sp_out->spidx.prefd, sp_out->spidx.ul_proto);
  	if (iddst == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to get ID for %s\n",
  			spidx2str(&sp_out->spidx));
  		vfree(idsrc);
  		delph2(iph2[n]);
  		return -1;
  	}
! 	iph2[n]->sainfo = getsainfo(idsrc, iddst);
  	vfree(idsrc);
  	vfree(iddst);
  	if (iph2[n]->sainfo == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to get sainfo.\n");
  		delph2(iph2[n]);
  		return -1;
  		/* XXX should use the algorithm list from register message */
  	}
      }
  
  	if (set_proposal_from_policy(iph2[n], sp_out, sp_in) < 0) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to create saprop.\n");
  		delph2(iph2[n]);
  		return -1;
  	}
  	insph2(iph2[n]);
  
  	/* start isakmp initiation by using ident exchange */
  	/* XXX should be looped if there are multiple phase 2 handler. */
  	if (isakmp_post_acquire(iph2[n]) < 0) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to begin ipsec sa negotication.\n");
  		goto err;
--- 1610,1660 ----
  		"new acquire %s\n", spidx2str(&sp_out->spidx));
  
  	/* get sainfo */
      {
  	vchar_t *idsrc, *iddst;
  
  	idsrc = ipsecdoi_sockaddr2id((struct sockaddr *)&sp_out->spidx.src,
  				sp_out->spidx.prefs, sp_out->spidx.ul_proto);
  	if (idsrc == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to get ID for %s\n",
  			spidx2str(&sp_out->spidx));
  		delph2(iph2[n]);
  		return -1;
  	}
  	iddst = ipsecdoi_sockaddr2id((struct sockaddr *)&sp_out->spidx.dst,
  				sp_out->spidx.prefd, sp_out->spidx.ul_proto);
  	if (iddst == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to get ID for %s\n",
  			spidx2str(&sp_out->spidx));
  		vfree(idsrc);
  		delph2(iph2[n]);
  		return -1;
  	}
! 	iph2[n]->sainfo = getsainfo(idsrc, iddst, NULL);
  	vfree(idsrc);
  	vfree(iddst);
  	if (iph2[n]->sainfo == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to get sainfo.\n");
  		delph2(iph2[n]);
  		return -1;
  		/* XXX should use the algorithm list from register message */
  	}
      }
  
  	if (set_proposal_from_policy(iph2[n], sp_out, sp_in) < 0) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to create saprop.\n");
  		delph2(iph2[n]);
  		return -1;
  	}
  	insph2(iph2[n]);
  
  	/* start isakmp initiation by using ident exchange */
  	/* XXX should be looped if there are multiple phase 2 handler. */
  	if (isakmp_post_acquire(iph2[n]) < 0) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to begin ipsec sa negotication.\n");
  		goto err;
***************
*** 1861,1916 ****
  			(struct sockaddr *)&spidx->src,
  			spidx->prefs,
  			(struct sockaddr *)&spidx->dst,
  			spidx->prefd,
  			spidx->ul_proto,
  			ltime, vtime,
  			policy, policylen, 0) < 0) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"libipsec failed send spdupdate2 (%s)\n",
  			ipsec_strerror());
  		goto end;
  	}
  	plog(LLV_DEBUG, LOCATION, NULL, "call pfkey_send_spdupdate2\n");
  
  end:
  	if (policy)
  		racoon_free(policy);
  
  	return 0;
  }
  
  static int
  pk_recvspdupdate(mhp)
  	caddr_t *mhp;
  {
  	/* sanity check */
! 	if (mhp[0] == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"inappropriate sadb spdupdate message passed.\n");
  		return -1;
  	}
  
  	return 0;
  }
  
  /*
   * this function has to be used by responder side.
   */
  int
  pk_sendspdadd2(iph2)
  	struct ph2handle *iph2;
  {
  	struct policyindex *spidx = (struct policyindex *)iph2->spidx_gen;
  	caddr_t policy = NULL;
  	int policylen = 0;
  	u_int64_t ltime, vtime;
  
  	ltime = iph2->approval->lifetime;
  	vtime = 0;
  
  	if (getsadbpolicy(&policy, &policylen, SADB_X_SPDADD, iph2)) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"getting sadb policy failed.\n");
  		return -1;
  	}
  
--- 1894,1981 ----
  			(struct sockaddr *)&spidx->src,
  			spidx->prefs,
  			(struct sockaddr *)&spidx->dst,
  			spidx->prefd,
  			spidx->ul_proto,
  			ltime, vtime,
  			policy, policylen, 0) < 0) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"libipsec failed send spdupdate2 (%s)\n",
  			ipsec_strerror());
  		goto end;
  	}
  	plog(LLV_DEBUG, LOCATION, NULL, "call pfkey_send_spdupdate2\n");
  
  end:
  	if (policy)
  		racoon_free(policy);
  
  	return 0;
  }
  
  static int
  pk_recvspdupdate(mhp)
  	caddr_t *mhp;
  {
+ 	struct sadb_address *saddr, *daddr;
+ 	struct sadb_x_policy *xpl;
+ 	struct policyindex spidx;
+ 	struct secpolicy *sp;
+ 
  	/* sanity check */
! 	if (mhp[0] == NULL
! 	 || mhp[SADB_EXT_ADDRESS_SRC] == NULL
! 	 || mhp[SADB_EXT_ADDRESS_DST] == NULL
! 	 || mhp[SADB_X_EXT_POLICY] == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"inappropriate sadb spdupdate message passed.\n");
  		return -1;
  	}
+ 	saddr = (struct sadb_address *)mhp[SADB_EXT_ADDRESS_SRC];
+ 	daddr = (struct sadb_address *)mhp[SADB_EXT_ADDRESS_DST];
+ 	xpl = (struct sadb_x_policy *)mhp[SADB_X_EXT_POLICY];
+ 
+ 	KEY_SETSECSPIDX(xpl->sadb_x_policy_dir,
+ 			saddr + 1,
+ 			daddr + 1,
+ 			saddr->sadb_address_prefixlen,
+ 			daddr->sadb_address_prefixlen,
+ 			saddr->sadb_address_proto,
+ 			&spidx);
+ 
+ 	sp = getsp(&spidx);
+ 	if (sp == NULL) {
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"such policy does not already exist: %s\n",
+ 			spidx2str(&spidx));
+ 	} else {
+ 		remsp(sp);
+ 		delsp(sp);
+ 	}
+ 
+ 	if (addnewsp(mhp) < 0)
+ 		return -1;
  
  	return 0;
  }
  
  /*
   * this function has to be used by responder side.
   */
  int
  pk_sendspdadd2(iph2)
  	struct ph2handle *iph2;
  {
  	struct policyindex *spidx = (struct policyindex *)iph2->spidx_gen;
  	caddr_t policy = NULL;
  	int policylen = 0;
  	u_int64_t ltime, vtime;
  
  	ltime = iph2->approval->lifetime;
  	vtime = 0;
  
  	if (getsadbpolicy(&policy, &policylen, SADB_X_SPDADD, iph2)) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"getting sadb policy failed.\n");
  		return -1;
  	}
  
diff -Nr -c25 ac_am/src/racoon/proposal.c ac_am_fixed/src/racoon/proposal.c
*** ac_am/src/racoon/proposal.c	2003-02-28 05:06:40.000000000 +0100
--- ac_am_fixed/src/racoon/proposal.c	2003-12-11 18:19:59.218045608 +0100
***************
*** 318,404 ****
  			switch (side) {
  			case RESPONDER:
  				if (!pr2)
  					break;
  				for (pr1 = pp1->head; pr1; pr1 = pr1->next) {
  					if (pr1->proto_id == pr2->proto_id)
  						break;
  				}
  				break;
  			case INITIATOR:
  				if (!pr1)
  					break;
  				for (pr2 = pp2->head; pr2; pr2 = pr2->next) {
  					if (pr2->proto_id == pr1->proto_id)
  						break;
  				}
  				break;
  			}
  		}
  		if (!pr1 || !pr2)
  			break;
  
  		if (pr1->proto_id != pr2->proto_id) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"proto_id mismatched: "
! 				"my:%d peer:%d\n",
! 				pr2->proto_id, pr1->proto_id);
  			goto err;
  		}
  		spisizematch = 0;
  		if (pr1->spisize == pr2->spisize)
  			spisizematch = 1;
  		else if (pr1->proto_id == IPSECDOI_PROTO_IPCOMP) {
  			/*
  			 * draft-shacham-ippcp-rfc2393bis-05.txt:
  			 * need to accept 16bit and 32bit SPI (CPI) for IPComp.
  			 */
  			if (pr1->spisize == sizeof(u_int16_t) &&
  			    pr2->spisize == sizeof(u_int32_t)) {
  				spisizematch = 1;
  			} else if (pr1->spisize == sizeof(u_int16_t) &&
  				 pr2->spisize == sizeof(u_int32_t)) {
  				spisizematch = 1;
  			}
  			if (spisizematch) {
  				plog(LLV_ERROR, LOCATION, NULL,
  				    "IPComp SPI size promoted "
  				    "from 16bit to 32bit\n");
  			}
  		}
  		if (!spisizematch) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"spisize mismatched: "
  				"my:%d peer:%d\n",
  				pr2->spisize, pr1->spisize);
  			goto err;
  		}
  		if (pr1->encmode != pr2->encmode) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"encmode mismatched: "
! 				"my:%d peer:%d\n",
! 				pr2->encmode, pr1->encmode);
  			goto err;
  		}
  
  		for (tr1 = pr1->head; tr1; tr1 = tr1->next) {
  			for (tr2 = pr2->head; tr2; tr2 = tr2->next) {
  				if (cmpsatrns(tr1, tr2) == 0)
  					goto found;
  			}
  		}
  
  		goto err;
  
  	    found:
  		newpr = newsaproto();
  		if (newpr == NULL) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"failed to allocate saproto.\n");
  			goto err;
  		}
  		newpr->proto_id = pr1->proto_id;
  		newpr->spisize = pr1->spisize;
  		newpr->encmode = pr1->encmode;
  		newpr->spi = pr2->spi;		/* copy my SPI */
  		newpr->spi_p = pr1->spi;	/* copy peer's SPI */
  		newpr->reqid_in = pr2->reqid_in;
--- 318,406 ----
  			switch (side) {
  			case RESPONDER:
  				if (!pr2)
  					break;
  				for (pr1 = pp1->head; pr1; pr1 = pr1->next) {
  					if (pr1->proto_id == pr2->proto_id)
  						break;
  				}
  				break;
  			case INITIATOR:
  				if (!pr1)
  					break;
  				for (pr2 = pp2->head; pr2; pr2 = pr2->next) {
  					if (pr2->proto_id == pr1->proto_id)
  						break;
  				}
  				break;
  			}
  		}
  		if (!pr1 || !pr2)
  			break;
  
  		if (pr1->proto_id != pr2->proto_id) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"proto_id mismatched: "
! 				"my:%s peer:%s\n",
! 				s_ipsecdoi_proto(pr2->proto_id),
! 				s_ipsecdoi_proto(pr1->proto_id));
  			goto err;
  		}
  		spisizematch = 0;
  		if (pr1->spisize == pr2->spisize)
  			spisizematch = 1;
  		else if (pr1->proto_id == IPSECDOI_PROTO_IPCOMP) {
  			/*
  			 * draft-shacham-ippcp-rfc2393bis-05.txt:
  			 * need to accept 16bit and 32bit SPI (CPI) for IPComp.
  			 */
  			if (pr1->spisize == sizeof(u_int16_t) &&
  			    pr2->spisize == sizeof(u_int32_t)) {
  				spisizematch = 1;
  			} else if (pr1->spisize == sizeof(u_int16_t) &&
  				 pr2->spisize == sizeof(u_int32_t)) {
  				spisizematch = 1;
  			}
  			if (spisizematch) {
  				plog(LLV_ERROR, LOCATION, NULL,
  				    "IPComp SPI size promoted "
  				    "from 16bit to 32bit\n");
  			}
  		}
  		if (!spisizematch) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"spisize mismatched: "
  				"my:%d peer:%d\n",
  				pr2->spisize, pr1->spisize);
  			goto err;
  		}
  		if (pr1->encmode != pr2->encmode) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"encmode mismatched: "
! 				"my:%s peer:%s\n",
! 				s_ipsecdoi_encmode(pr2->encmode),
! 				s_ipsecdoi_encmode(pr1->encmode));
  			goto err;
  		}
  
  		for (tr1 = pr1->head; tr1; tr1 = tr1->next) {
  			for (tr2 = pr2->head; tr2; tr2 = tr2->next) {
  				if (cmpsatrns(tr1, tr2) == 0)
  					goto found;
  			}
  		}
  
  		goto err;
  
  	    found:
  		newpr = newsaproto();
  		if (newpr == NULL) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"failed to allocate saproto.\n");
  			goto err;
  		}
  		newpr->proto_id = pr1->proto_id;
  		newpr->spisize = pr1->spisize;
  		newpr->encmode = pr1->encmode;
  		newpr->spi = pr2->spi;		/* copy my SPI */
  		newpr->spi_p = pr1->spi;	/* copy peer's SPI */
  		newpr->reqid_in = pr2->reqid_in;
***************
*** 472,523 ****
  		/* FALLTHRU */
  	}
  
  	return 0;
  }
  
  /*
   * take a single match between satrns.  returns 0 if tr1 equals to tr2.
   * tr1: peer's satrns
   * tr2: my satrns
   */
  int
  cmpsatrns(tr1, tr2)
  	const struct satrns *tr1, *tr2;
  {
  	if (tr1->trns_id != tr2->trns_id) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"trns_id mismatched: "
  			"my:%d peer:%d\n",
  			tr2->trns_id, tr1->trns_id);
  		return 1;
  	}
  	if (tr1->authtype != tr2->authtype) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"authtype mismatched: "
! 			"my:%d peer:%d\n",
! 			tr2->authtype, tr1->authtype);
  		return 1;
  	}
  
  	/* XXX
  	 * At this moment for interoperability, the responder obey
  	 * the initiator.  It should be defined a notify message.
  	 */
  	if (tr1->encklen > tr2->encklen) {
  		plog(LLV_WARNING, LOCATION, NULL,
  			"less key length proposed, "
  			"mine:%d peer:%d.  Use initiaotr's one.\n",
  			tr2->encklen, tr1->encklen);
  		/* FALLTHRU */
  	}
  
  	return 0;
  }
  
  int
  set_satrnsbysainfo(pr, sainfo)
  	struct saproto *pr;
  	struct sainfo *sainfo;
  {
  	struct sainfoalg *a, *b;
  	struct satrns *newtr;
--- 474,526 ----
  		/* FALLTHRU */
  	}
  
  	return 0;
  }
  
  /*
   * take a single match between satrns.  returns 0 if tr1 equals to tr2.
   * tr1: peer's satrns
   * tr2: my satrns
   */
  int
  cmpsatrns(tr1, tr2)
  	const struct satrns *tr1, *tr2;
  {
  	if (tr1->trns_id != tr2->trns_id) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"trns_id mismatched: "
  			"my:%d peer:%d\n",
  			tr2->trns_id, tr1->trns_id);
  		return 1;
  	}
  	if (tr1->authtype != tr2->authtype) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"authtype mismatched: "
! 			"my:%s peer:%s\n",
! 			s_ipsecdoi_attr_v(IPSECDOI_ATTR_AUTH, tr2->authtype),
! 			s_ipsecdoi_attr_v(IPSECDOI_ATTR_AUTH, tr1->authtype));
  		return 1;
  	}
  
  	/* XXX
  	 * At this moment for interoperability, the responder obey
  	 * the initiator.  It should be defined a notify message.
  	 */
  	if (tr1->encklen > tr2->encklen) {
  		plog(LLV_WARNING, LOCATION, NULL,
  			"less key length proposed, "
  			"mine:%d peer:%d.  Use initiaotr's one.\n",
  			tr2->encklen, tr1->encklen);
  		/* FALLTHRU */
  	}
  
  	return 0;
  }
  
  int
  set_satrnsbysainfo(pr, sainfo)
  	struct saproto *pr;
  	struct sainfo *sainfo;
  {
  	struct sainfoalg *a, *b;
  	struct satrns *newtr;
diff -Nr -c25 ac_am/src/racoon/racoon.8 ac_am_fixed/src/racoon/racoon.8
*** ac_am/src/racoon/racoon.8	2003-02-26 22:31:24.000000000 +0100
--- ac_am_fixed/src/racoon/racoon.8	2003-12-11 18:19:59.220045304 +0100
***************
*** 115,140 ****
  if you want to see them in a logging file.
  .\"
  .Sh RETURN VALUES
  The command exits with 0 on success, and non-zero on errors.
  .\"
  .Sh FILES
  .Bl -tag -width /usr/local/v6/etc/racoon.conf -compact
  .It Pa /usr/local/v6/etc/racoon.conf
  default configuration file.
  .El
  .\"
  .Sh SEE ALSO
  .Xr ipsec 4 ,
  .Xr racoon.conf 5 ,
  .Xr syslog.conf 5 ,
  .Xr setkey 8 ,
  .Xr syslogd 8
  .\"
  .Sh HISTORY
  The
  .Nm
  command first appeared in
  .Dq YIPS
  Yokogawa IPsec implementation.
  .\"
! .\".Sh BUGS
--- 115,143 ----
  if you want to see them in a logging file.
  .\"
  .Sh RETURN VALUES
  The command exits with 0 on success, and non-zero on errors.
  .\"
  .Sh FILES
  .Bl -tag -width /usr/local/v6/etc/racoon.conf -compact
  .It Pa /usr/local/v6/etc/racoon.conf
  default configuration file.
  .El
  .\"
  .Sh SEE ALSO
  .Xr ipsec 4 ,
  .Xr racoon.conf 5 ,
  .Xr syslog.conf 5 ,
  .Xr setkey 8 ,
  .Xr syslogd 8
  .\"
  .Sh HISTORY
  The
  .Nm
  command first appeared in
  .Dq YIPS
  Yokogawa IPsec implementation.
  .\"
! .Sh SECURITY CONSIDERATIONS
! The use of IKE phase 1 aggressive mode is not recommended,
! as describved in
! .Li http://www.kb.cert.org/vuls/id/886601 .
diff -Nr -c25 ac_am/src/racoon/racoon.conf.5 ac_am_fixed/src/racoon/racoon.conf.5
*** ac_am/src/racoon/racoon.conf.5	2003-03-04 00:30:53.000000000 +0100
--- ac_am_fixed/src/racoon/racoon.conf.5	2003-12-11 18:19:59.225044544 +0100
***************
*** 42,144 ****
  is the configuration file for the
  .Xr racoon 8
  ISAKMP daemon.
  .Xr racoon 8
  negotiates security associations for itself (ISAKMP SA, or phase 1 SA)
  and for kernel IPsec (IPsec SA, or phase 2 SA).
  The file consists of a sequence of directives and statements.
  Each directive is composed by a tag, and statements are enclosed by
  .Ql {
  and
  .Ql } .
  Lines beginning with
  .Ql #
  are comments.
  .\"
  .Ss Meta Syntax
  Keywords and special characters that the parser expects exactly are
  displayed using
  .Ic this
  font.
  Parameters are specified with
  .Ar this
  font.
  Square brackets
  .Po
! .Ql \*(lB
  and
! .Ql \*(rB
  .Pc
  are used to show optional keywords and parameters.
  Note that
  you have to pay attention when this manual is describing
  .Ar port
  numbers.
  The
  .Ar port
  number is always enclosed by
! .Ql \*(lB
  and
! .Ql \*(rB .
  In this case, the port number is not an optional keyword.
  If it is possible to omit
  .Ar port
  number,
  the expression becomes
! .Bq Ic Bq Ar port .
  The vertical bar
  .Pq Ql \*(Ba
  is used to indicate
  a choice between optional parameters.
  Parentheses
  .Po
! .Ql \*(lP
  and
! .Ql \*(rP
  .Pc
  are used to group keywords and parameters when necessary.
  Major parameters are listed below.
  .Pp
  .Bl -tag -width addressx -compact
  .It Ar number
  means a hexadecimal or a decimal number.
  The former must be prefixed with
  .Ql Li 0x .
  .It Ar string
  .It Ar path
  .It Ar file
  means any string enclosed in
  .Ql \&"
  .Pq double quote .
  .It Ar address
  means IPv6 and/or IPv4 address.
  .It Ar port
  means a TCP/UDP port number.
  The port number is always enclosed by
! .Ql \*(lB
  and
! .Ql \*(rB .
  .It Ar timeunit
  is one of following:
  .Ic sec , secs , second , seconds ,
  .Ic min , mins , minute , minutes ,
  .Ic hour , hours .
  .El
  .\"
  .Ss Path Specification
  .Bl -tag -width Ds -compact
  .It Ic path include Ar path ;
  specifies a path to include a file.
  See
  .Sx File Inclusion .
  .It Ic path pre_shared_key Ar file ;
  specifies a file containing pre-shared key(s) for various ID(s).
  See
  .Sx Pre-shared key File .
  .It Ic path certificate Ar path ;
  .Xr racoon 8
  will search this directory if a certificate or certificate request is received.
  .It Ic path backupsa Ar file ;
  specifies a file to be stored a SA information which is negotiated by racoon.
  .Xr racoon 8
  will install SA(s) from the file with a boot option
  .Fl B .
--- 42,144 ----
  is the configuration file for the
  .Xr racoon 8
  ISAKMP daemon.
  .Xr racoon 8
  negotiates security associations for itself (ISAKMP SA, or phase 1 SA)
  and for kernel IPsec (IPsec SA, or phase 2 SA).
  The file consists of a sequence of directives and statements.
  Each directive is composed by a tag, and statements are enclosed by
  .Ql {
  and
  .Ql } .
  Lines beginning with
  .Ql #
  are comments.
  .\"
  .Ss Meta Syntax
  Keywords and special characters that the parser expects exactly are
  displayed using
  .Ic this
  font.
  Parameters are specified with
  .Ar this
  font.
  Square brackets
  .Po
! .Ql \&[
  and
! .Ql \&]
  .Pc
  are used to show optional keywords and parameters.
  Note that
  you have to pay attention when this manual is describing
  .Ar port
  numbers.
  The
  .Ar port
  number is always enclosed by
! .Ql \&[
  and
! .Ql \&] .
  In this case, the port number is not an optional keyword.
  If it is possible to omit
  .Ar port
  number,
  the expression becomes
! .Bq Bq Ar port .
  The vertical bar
  .Pq Ql \*(Ba
  is used to indicate
  a choice between optional parameters.
  Parentheses
  .Po
! .Ql \&(
  and
! .Ql \&)
  .Pc
  are used to group keywords and parameters when necessary.
  Major parameters are listed below.
  .Pp
  .Bl -tag -width addressx -compact
  .It Ar number
  means a hexadecimal or a decimal number.
  The former must be prefixed with
  .Ql Li 0x .
  .It Ar string
  .It Ar path
  .It Ar file
  means any string enclosed in
  .Ql \&"
  .Pq double quote .
  .It Ar address
  means IPv6 and/or IPv4 address.
  .It Ar port
  means a TCP/UDP port number.
  The port number is always enclosed by
! .Ql \&[
  and
! .Ql \&] .
  .It Ar timeunit
  is one of following:
  .Ic sec , secs , second , seconds ,
  .Ic min , mins , minute , minutes ,
  .Ic hour , hours .
  .El
  .\"
  .Ss Path Specification
  .Bl -tag -width Ds -compact
  .It Ic path include Ar path ;
  specifies a path to include a file.
  See
  .Sx File Inclusion .
  .It Ic path pre_shared_key Ar file ;
  specifies a file containing pre-shared key(s) for various ID(s).
  See
  .Sx Pre-shared key File .
  .It Ic path certificate Ar path ;
  .Xr racoon 8
  will search this directory if a certificate or certificate request is received.
  .It Ic path backupsa Ar file ;
  specifies a file to be stored a SA information which is negotiated by racoon.
  .Xr racoon 8
  will install SA(s) from the file with a boot option
  .Fl B .
***************
*** 216,266 ****
  .Ic remote ( Ar address \*(Ba Ic anonymous )
  .Bq Bq Ar port
  .Ic { Ar statements Ic }
  .Xc
  specifies the parameters for IKE phase 1 for each remote node.
  The default port is 500.
  If
  .Ic anonymous
  is specified, the statements apply to all peers which do not match
  any other
  .Ic remote
  directive.
  .Pp
  The following are valid statements.
  .Pp
  .Bl -tag -width Ds -compact
  .\"
  .It Ic exchange_mode ( main \*(Ba aggressive \*(Ba base ) ;
  defines the exchange mode for phase 1 when racoon is the initiator.
  Also it means the acceptable exchange mode when racoon is responder.
  More than one mode can be specified by separating them with a comma.
  All of the modes are acceptable.
  The first exchange mode is what racoon uses when it is the initiator.
  .\"
  .It Ic doi Ic ipsec_doi ;
! means to use IPSEC-DOI as specified RFC 2407.
  You can omit this statement.
  .\"
  .It Ic situation Ic identity_only ;
  means to use SIT_IDENTITY_ONLY as specified RFC 2407.
  You can omit this statement.
  .\"
  .It Ic identifier Ar idtype ;
  is obsolete.
  Instead, use
  .Ic my_identifier .
  .\"
  .It Ic my_identifier Ar idtype ... ;
  specifies the identifier sent to the remote host
  and the type to use in the phase 1 negotiation.
  .Ic address, fqdn , user_fqdn , keyid and asn1dn
  can be used as an
  .Ar idtype .
  they are used like:
  .Bl -tag -width Ds -compact
  .It Ic my_identifier Ic address Bq Ar address ;
  the type is the IP address.
  This is the default type if you do not specify an identifier to use.
  .It Ic my_identifier Ic user_fqdn Ar string ;
  the type is a USER_FQDN (user fully-qualified domain name).
  .It Ic my_identifier Ic fqdn Ar string ;
--- 216,266 ----
  .Ic remote ( Ar address \*(Ba Ic anonymous )
  .Bq Bq Ar port
  .Ic { Ar statements Ic }
  .Xc
  specifies the parameters for IKE phase 1 for each remote node.
  The default port is 500.
  If
  .Ic anonymous
  is specified, the statements apply to all peers which do not match
  any other
  .Ic remote
  directive.
  .Pp
  The following are valid statements.
  .Pp
  .Bl -tag -width Ds -compact
  .\"
  .It Ic exchange_mode ( main \*(Ba aggressive \*(Ba base ) ;
  defines the exchange mode for phase 1 when racoon is the initiator.
  Also it means the acceptable exchange mode when racoon is responder.
  More than one mode can be specified by separating them with a comma.
  All of the modes are acceptable.
  The first exchange mode is what racoon uses when it is the initiator.
  .\"
  .It Ic doi Ic ipsec_doi ;
! means to use IPsec DOI as specified RFC 2407.
  You can omit this statement.
  .\"
  .It Ic situation Ic identity_only ;
  means to use SIT_IDENTITY_ONLY as specified RFC 2407.
  You can omit this statement.
  .\"
  .It Ic identifier Ar idtype ;
  is obsolete.
  Instead, use
  .Ic my_identifier .
  .\"
  .It Ic my_identifier Ar idtype ... ;
  specifies the identifier sent to the remote host
  and the type to use in the phase 1 negotiation.
  .Ic address, fqdn , user_fqdn , keyid and asn1dn
  can be used as an
  .Ar idtype .
  they are used like:
  .Bl -tag -width Ds -compact
  .It Ic my_identifier Ic address Bq Ar address ;
  the type is the IP address.
  This is the default type if you do not specify an identifier to use.
  .It Ic my_identifier Ic user_fqdn Ar string ;
  the type is a USER_FQDN (user fully-qualified domain name).
  .It Ic my_identifier Ic fqdn Ar string ;
***************
*** 280,330 ****
  specifies the peer's identifier to be received.
  If it is not defined then
  .Xr racoon 8
  will not verify the peer's identifier in ID payload transmitted from the peer.
  If it is defined, the behavior of the verification depends on the flag of
  .Ic verify_identifier .
  The usage of
  .Ar idtype
  is same to
  .Ic my_identifier .
  .\"
  .It Ic verify_identifier (on \(ba off) ;
  If you want to verify the peer's identifier,
  set this to on.
  In this case, if the value defined by
  .Ic peers_identifier
  is not same to the peer's identifier in the ID payload,
  the negotiation will failed.
  The default is off.
  .\"
  .It Ic certificate_type Ar certspec ;
  specifies a certificate specification.
  .Ar certspec
  is one of followings:
  .Bl -tag -width Ds -compact
! .It Ic x509 Ar certfile Ar privkeyfile;
  .Ar certfile
  means a file name of certificate.
  .Ar privkeyfile
  means a file name of secret key.
  .El
  .\"
  .It Ic peers_certfile ( dnssec \*(Ba Ar certfile ) ;
  If
  .Ic dnssec
  is defined,
  .Xr racoon 8
  will ignore the CERT payload from the peer,
  and try to get the peer's certificate from DNS instead.
  If
  .Ar certfile
  is defined,
  .Xr racoon 8
  will ignore the CERT payload from the peer,
  and will use this certificate as the peer's certificate.
  .\"
  .It Ic send_cert (on \(ba off) ;
  If you do not want to send a certificate for some reason, set this to off.
  The default is on.
  .\"
  .It Ic send_cr (on \(ba off) ;
--- 280,330 ----
  specifies the peer's identifier to be received.
  If it is not defined then
  .Xr racoon 8
  will not verify the peer's identifier in ID payload transmitted from the peer.
  If it is defined, the behavior of the verification depends on the flag of
  .Ic verify_identifier .
  The usage of
  .Ar idtype
  is same to
  .Ic my_identifier .
  .\"
  .It Ic verify_identifier (on \(ba off) ;
  If you want to verify the peer's identifier,
  set this to on.
  In this case, if the value defined by
  .Ic peers_identifier
  is not same to the peer's identifier in the ID payload,
  the negotiation will failed.
  The default is off.
  .\"
  .It Ic certificate_type Ar certspec ;
  specifies a certificate specification.
  .Ar certspec
  is one of followings:
  .Bl -tag -width Ds -compact
! .It Ic x509 Ar certfile Ar privkeyfile ;
  .Ar certfile
  means a file name of certificate.
  .Ar privkeyfile
  means a file name of secret key.
  .El
  .\"
  .It Ic peers_certfile ( dnssec \*(Ba Ar certfile ) ;
  If
  .Ic dnssec
  is defined,
  .Xr racoon 8
  will ignore the CERT payload from the peer,
  and try to get the peer's certificate from DNS instead.
  If
  .Ar certfile
  is defined,
  .Xr racoon 8
  will ignore the CERT payload from the peer,
  and will use this certificate as the peer's certificate.
  .\"
  .It Ic send_cert (on \(ba off) ;
  If you do not want to send a certificate for some reason, set this to off.
  The default is on.
  .\"
  .It Ic send_cr (on \(ba off) ;
***************
*** 374,472 ****
  .It Ic obey
  the responder will obey the initiator anytime.
  .It Ic strict
  If the responder's length is longer than the initiator's one, the
  responder uses the initiator's one.
  Otherwise it rejects the proposal.
  If PFS is not required by the responder, the responder will obey the proposal.
  If PFS is required by both sides and if the responder's group is not equal to
  the initiator's one, then the responder will reject the proposal.
  .It Ic claim
  If the responder's length is longer than the initiator's one, the
  responder will use the initiator's one.
  If the responder's length is
  shorter than the initiator's one, the responder uses its own length
  AND sends a RESPONDER-LIFETIME notify message to an initiator in the
  case of lifetime.
  About PFS, this directive is same as
  .Ic strict .
  .It Ic exact
  If the initiator's length is not equal to the responder's one, the
  responder will reject the proposal.
  If PFS is required by both sides and if the responder's group is not equal to
  the initiator's one, then the responder will reject the proposal.
  .El
  .\"
! .It Ic support_mip6 (on \(ba off) ;
  If this value is set on then both values of ID payloads in phase 2 exchange
  are always used as the addresses of end-point of IPsec-SAs.
  The default is off.
  .\"
  .It Ic generate_policy (on \(ba off) ;
  This directive is for the responder.
  Therefore you should set
  .Ic passive
  on in order that
  .Xr racoon 8
  only becomes a responder.
  If the responder does not have any policy in SPD during phase 2 negotiation,
  and the directive is set on, then
  .Xr racoon 8
  will choice the first proposal in the
  SA payload from the initiator, and generate policy entries from the proposal.
  It is useful to negotiate with the client which is allocated IP address
  dynamically.
  Note that inappropriate policy might be installed into the responder's SPD
  by the initiator.
  So that other communication might fail if such policies installed
  due to some policy mismatches between the initiator and the responder.
  This directive is ignored in the initiator case.
  The default value is
  .Ic off .
  .\"
  .It Ic nonce_size Ar number ;
  define the byte size of nonce value.
  Racoon can send any value although
  RFC2409 specifies that the value MUST be between 8 and 256 bytes.
  The default size is 16 bytes.
  .\"
  .It Xo
  .Ic proposal { Ar sub-substatements Ic }
  .Xc
  .Bl -tag -width Ds -compact
  .\"
  .It Ic encryption_algorithm Ar algorithm ;
  specify the encryption algorithm used for the phase 1 negotiation.
  This directive must be defined.
  .Ar algorithm
  is one of following:
  .Ic des , 3des , blowfish , cast128
  .\".Ic rc5 , idea
  for oakley.
  For other transforms, this statement should not be used.
  .\"
! .It Ic hash_algorithm Ar algorithm;
  define the hash algorithm used for the phase 1 negotiation.
  This directive must be defined.
  .Ar algorithm
  is one of following:
  .Ic md5, sha1
  for oakley.
  .\"
  .It Ic authentication_method Ar type ;
  defines the authentication method used for the phase 1 negotiation.
  This directive must be defined.
  .Ar type
  is one of:
  .Ic pre_shared_key, rsasig , gssapi_krb .
  .\"
  .It Ic dh_group Ar group ;
  define the group used for the Diffie-Hellman exponentiations.
  This directive must be defined.
  .Ar group
  is one of following:
  .Ic modp768 , modp1024 , modp1536 .
  Or you can define 1, 2, or 5 as the DH group number.
  When you want to use aggressive mode,
  you must define same DH group in each proposal.
  .It Ic lifetime time Ar number Ar timeunit ;
  define lifetime of the phase 1 SA proposal.
--- 374,472 ----
  .It Ic obey
  the responder will obey the initiator anytime.
  .It Ic strict
  If the responder's length is longer than the initiator's one, the
  responder uses the initiator's one.
  Otherwise it rejects the proposal.
  If PFS is not required by the responder, the responder will obey the proposal.
  If PFS is required by both sides and if the responder's group is not equal to
  the initiator's one, then the responder will reject the proposal.
  .It Ic claim
  If the responder's length is longer than the initiator's one, the
  responder will use the initiator's one.
  If the responder's length is
  shorter than the initiator's one, the responder uses its own length
  AND sends a RESPONDER-LIFETIME notify message to an initiator in the
  case of lifetime.
  About PFS, this directive is same as
  .Ic strict .
  .It Ic exact
  If the initiator's length is not equal to the responder's one, the
  responder will reject the proposal.
  If PFS is required by both sides and if the responder's group is not equal to
  the initiator's one, then the responder will reject the proposal.
  .El
  .\"
! .It Ic support_proxy (on \(ba off) ;
  If this value is set on then both values of ID payloads in phase 2 exchange
  are always used as the addresses of end-point of IPsec-SAs.
  The default is off.
  .\"
  .It Ic generate_policy (on \(ba off) ;
  This directive is for the responder.
  Therefore you should set
  .Ic passive
  on in order that
  .Xr racoon 8
  only becomes a responder.
  If the responder does not have any policy in SPD during phase 2 negotiation,
  and the directive is set on, then
  .Xr racoon 8
  will choice the first proposal in the
  SA payload from the initiator, and generate policy entries from the proposal.
  It is useful to negotiate with the client which is allocated IP address
  dynamically.
  Note that inappropriate policy might be installed into the responder's SPD
  by the initiator.
  So that other communication might fail if such policies installed
  due to some policy mismatches between the initiator and the responder.
  This directive is ignored in the initiator case.
  The default value is
  .Ic off .
  .\"
  .It Ic nonce_size Ar number ;
  define the byte size of nonce value.
  Racoon can send any value although
  RFC2409 specifies that the value MUST be between 8 and 256 bytes.
  The default size is 16 bytes.
  .\"
  .It Xo
  .Ic proposal { Ar sub-substatements Ic }
  .Xc
  .Bl -tag -width Ds -compact
  .\"
  .It Ic encryption_algorithm Ar algorithm ;
  specify the encryption algorithm used for the phase 1 negotiation.
  This directive must be defined.
  .Ar algorithm
  is one of following:
  .Ic des , 3des , blowfish , cast128
  .\".Ic rc5 , idea
  for oakley.
  For other transforms, this statement should not be used.
  .\"
! .It Ic hash_algorithm Ar algorithm ;
  define the hash algorithm used for the phase 1 negotiation.
  This directive must be defined.
  .Ar algorithm
  is one of following:
  .Ic md5, sha1
  for oakley.
  .\"
  .It Ic authentication_method Ar type ;
  defines the authentication method used for the phase 1 negotiation.
  This directive must be defined.
  .Ar type
  is one of:
  .Ic pre_shared_key, rsasig , gssapi_krb .
  .\"
  .It Ic dh_group Ar group ;
  define the group used for the Diffie-Hellman exponentiations.
  This directive must be defined.
  .Ar group
  is one of following:
  .Ic modp768 , modp1024 , modp1536 .
  Or you can define 1, 2, or 5 as the DH group number.
  When you want to use aggressive mode,
  you must define same DH group in each proposal.
  .It Ic lifetime time Ar number Ar timeunit ;
  define lifetime of the phase 1 SA proposal.
***************
*** 543,593 ****
  See the
  .Ic proposal_check
  directive.
  .\"
  .It Ic my_identifier Ar idtype ... ;
  is obsolete.
  It does not make sense to specify a identifier in the phase 2.
  .El
  .\"
  .Pp
  .Xr racoon 8
  does not have the list of security protocols to be negotiated.
  The list of security protocols are passed by SPD in the kernel.
  Therefore you have to define all of the potential algorithms
  in the phase 2 proposals even if there is a algorithm which will not be used.
  These algorithms are define by using the following three directives,
  and they are lined with single comma as the separator.
  For algorithms that can take variable-length keys, algorithm names
  can be followed by a key length, like
  .Dq Li blowfish 448 .
  .Xr racoon 8
  will compute the actual phase 2 proposals by computing
  the permutation of the specified algorithms,
  and then combining them with the security protocol specified by the SPD.
  For example, if
! .Ic des, 3des, hmac_md5,
  and
  .Ic hmac_sha1
  are specified as algorithms, we have four combinations for use with ESP,
  and two for AH.
  Then, based on the SPD settings,
  .Xr racoon 8
  will construct the actual proposals.
  If the SPD entry asks for ESP only, there will be 4 proposals.
  If it asks for both AH and ESP, there will be 8 proposals.
  Note that the kernel may not support the algorithm you have specified.
  .\"
  .Bl -tag -width Ds -compact
  .It Ic encryption_algorithm Ar algorithms ;
  .Ic des , 3des , des_iv64 , des_iv32 ,
  .Ic rc5 , rc4 , idea , 3idea ,
  .Ic cast128 , blowfish , null_enc ,
  .Ic twofish , rijndael
  .Pq used with ESP
  .\"
  .It Ic authentication_algorithm Ar algorithms ;
  .Ic des , 3des , des_iv64 , des_iv32 ,
  .Ic hmac_md5 , hmac_sha1 , non_auth
  .Pq used with ESP authentication and AH
  .\"
  .It Ic compression_algorithm Ar algorithms ;
--- 543,593 ----
  See the
  .Ic proposal_check
  directive.
  .\"
  .It Ic my_identifier Ar idtype ... ;
  is obsolete.
  It does not make sense to specify a identifier in the phase 2.
  .El
  .\"
  .Pp
  .Xr racoon 8
  does not have the list of security protocols to be negotiated.
  The list of security protocols are passed by SPD in the kernel.
  Therefore you have to define all of the potential algorithms
  in the phase 2 proposals even if there is a algorithm which will not be used.
  These algorithms are define by using the following three directives,
  and they are lined with single comma as the separator.
  For algorithms that can take variable-length keys, algorithm names
  can be followed by a key length, like
  .Dq Li blowfish 448 .
  .Xr racoon 8
  will compute the actual phase 2 proposals by computing
  the permutation of the specified algorithms,
  and then combining them with the security protocol specified by the SPD.
  For example, if
! .Ic des , 3des , hmac_md5 ,
  and
  .Ic hmac_sha1
  are specified as algorithms, we have four combinations for use with ESP,
  and two for AH.
  Then, based on the SPD settings,
  .Xr racoon 8
  will construct the actual proposals.
  If the SPD entry asks for ESP only, there will be 4 proposals.
  If it asks for both AH and ESP, there will be 8 proposals.
  Note that the kernel may not support the algorithm you have specified.
  .\"
  .Bl -tag -width Ds -compact
  .It Ic encryption_algorithm Ar algorithms ;
  .Ic des , 3des , des_iv64 , des_iv32 ,
  .Ic rc5 , rc4 , idea , 3idea ,
  .Ic cast128 , blowfish , null_enc ,
  .Ic twofish , rijndael
  .Pq used with ESP
  .\"
  .It Ic authentication_algorithm Ar algorithms ;
  .Ic des , 3des , des_iv64 , des_iv32 ,
  .Ic hmac_md5 , hmac_sha1 , non_auth
  .Pq used with ESP authentication and AH
  .\"
  .It Ic compression_algorithm Ar algorithms ;
***************
*** 604,654 ****
  is one of following:
  .Ic notify , debug
  and
  .Ic debug2 .
  The default is
  .Ic notify .
  If you put too high logging level on slower machines,
  IKE negotiation can fail due to timing constraint changes.
  .El
  .\"
  .Ss Specifying the way to pad
  .Bl -tag -width Ds -compact
  .It Ic padding { Ar statements Ic }
  specified padding format.
  The following are valid statements:
  .Bl -tag -width Ds -compact
  .It Ic randomize (on \(ba off) ;
  enable using a randomized value for padding.
  The default is on.
  .It Ic randomize_length (on \(ba off) ;
  the pad length is random.
  The default is off.
  .It Ic maximum_length Ar number ;
  define a maximum padding length.
  If
! .Ic randomize_length is off, this is ignored.
  The default is 20 bytes.
  .It Ic exclusive_tail (on \(ba off) ;
  means to put the number of pad bytes minus one into last part of the padding.
  The default is on.
  .It Ic strict_check (on \(ba off) ;
  means to be constrained the peer to set the number of pad bytes.
  The default is off.
  .El
  .El
  .Ss Special directives
  .Bl -tag -width Ds -compact
  .It Ic complex_bundle (on \(ba off) ;
  defines the interpretation of proposal in the case of SA bundle.
  Normally
  .Dq IP AH ESP IP payload
  is proposed as
  .Dq AH tunnel and ESP tunnel .
  The interpretation is more common to other IKE implementations, however,
  it allows very limited set of combinations for proposals.
  With the option enabled, it will be proposed as
  .Dq AH transport and ESP tunnel .
  The default value is
  .Ic off .
  .El
  .\"
--- 604,655 ----
  is one of following:
  .Ic notify , debug
  and
  .Ic debug2 .
  The default is
  .Ic notify .
  If you put too high logging level on slower machines,
  IKE negotiation can fail due to timing constraint changes.
  .El
  .\"
  .Ss Specifying the way to pad
  .Bl -tag -width Ds -compact
  .It Ic padding { Ar statements Ic }
  specified padding format.
  The following are valid statements:
  .Bl -tag -width Ds -compact
  .It Ic randomize (on \(ba off) ;
  enable using a randomized value for padding.
  The default is on.
  .It Ic randomize_length (on \(ba off) ;
  the pad length is random.
  The default is off.
  .It Ic maximum_length Ar number ;
  define a maximum padding length.
  If
! .Ic randomize_length
! is off, this is ignored.
  The default is 20 bytes.
  .It Ic exclusive_tail (on \(ba off) ;
  means to put the number of pad bytes minus one into last part of the padding.
  The default is on.
  .It Ic strict_check (on \(ba off) ;
  means to be constrained the peer to set the number of pad bytes.
  The default is off.
  .El
  .El
  .Ss Special directives
  .Bl -tag -width Ds -compact
  .It Ic complex_bundle (on \(ba off) ;
  defines the interpretation of proposal in the case of SA bundle.
  Normally
  .Dq IP AH ESP IP payload
  is proposed as
  .Dq AH tunnel and ESP tunnel .
  The interpretation is more common to other IKE implementations, however,
  it allows very limited set of combinations for proposals.
  With the option enabled, it will be proposed as
  .Dq AH transport and ESP tunnel .
  The default value is
  .Ic off .
  .El
  .\"
***************
*** 702,726 ****
--- 703,732 ----
  10.160.94.3     mekmitasdigoat
  172.16.1.133    0x12345678
  194.100.55.1    whatcertificatereally
  3ffe:501:410:ffff:200:86ff:fe05:80fa    mekmitasdigoat
  3ffe:501:410:ffff:210:4bff:fea2:8baa    mekmitasdigoat
  foo@kame.net    mekmitasdigoat
  foo.kame.net    hoge
  .Ed
  .\"
  .Sh SEE ALSO
  .\".Xr racoonctl 8 ,
  .Xr racoon 8 ,
  .Xr setkey 8
  .\"
  .Sh HISTORY
  The
  .Nm
  configuration file first appeared in
  .Dq YIPS
  Yokogawa IPsec implementation.
  .\"
  .Sh BUGS
  Some statements may not be handled by
  .Xr racoon 8
  yet.
+ .\"
+ .Sh SECURITY CONSIDERATIONS
+ The use of IKE phase 1 aggressive mode is not recommended,
+ as describved in
+ .Li http://www.kb.cert.org/vuls/id/886601 .
diff -Nr -c25 ac_am/src/racoon/remoteconf.c ac_am_fixed/src/racoon/remoteconf.c
*** ac_am/src/racoon/remoteconf.c	2003-02-28 05:06:40.000000000 +0100
--- ac_am_fixed/src/racoon/remoteconf.c	2003-12-11 18:19:59.227044240 +0100
***************
*** 139,189 ****
  newrmconf()
  {
  	struct remoteconf *new;
  
  	new = racoon_calloc(1, sizeof(*new));
  	if (new == NULL)
  		return NULL;
  
  	new->proposal = NULL;
  
  	/* set default */
  	new->doitype = IPSEC_DOI;
  	new->sittype = IPSECDOI_SIT_IDENTITY_ONLY;
  	new->idvtype = IDTYPE_ADDRESS;
  	new->idvtype_p = IDTYPE_ADDRESS;
  	new->nonce_size = DEFAULT_NONCE_SIZE;
  	new->keepalive = FALSE;
  	new->passive = FALSE;
  	new->ini_contact = TRUE;
  	new->pcheck_level = PROP_CHECK_STRICT;
  	new->verify_identifier = FALSE;
  	new->verify_cert = TRUE;
  	new->getcert_method = ISAKMP_GETCERT_PAYLOAD;
  	new->send_cert = TRUE;
  	new->send_cr = TRUE;
! 	new->support_mip6 = FALSE;
  	new->gen_policy = FALSE;
  	new->retry_counter = lcconf->retry_counter;
  	new->retry_interval = lcconf->retry_interval;
  
  	return new;
  }
  
  void
  delrmconf(rmconf)
  	struct remoteconf *rmconf;
  {
  	if (rmconf->etypes)
  		deletypes(rmconf->etypes);
  	if (rmconf->dhgrp)
  		oakley_dhgrp_free(rmconf->dhgrp);
  	if (rmconf->proposal)
  		delisakmpsa(rmconf->proposal);
  	racoon_free(rmconf);
  }
  
  void
  delisakmpsa(sa)
  	struct isakmpsa *sa;
  {
  	if (sa->dhgrp)
--- 139,189 ----
  newrmconf()
  {
  	struct remoteconf *new;
  
  	new = racoon_calloc(1, sizeof(*new));
  	if (new == NULL)
  		return NULL;
  
  	new->proposal = NULL;
  
  	/* set default */
  	new->doitype = IPSEC_DOI;
  	new->sittype = IPSECDOI_SIT_IDENTITY_ONLY;
  	new->idvtype = IDTYPE_ADDRESS;
  	new->idvtype_p = IDTYPE_ADDRESS;
  	new->nonce_size = DEFAULT_NONCE_SIZE;
  	new->keepalive = FALSE;
  	new->passive = FALSE;
  	new->ini_contact = TRUE;
  	new->pcheck_level = PROP_CHECK_STRICT;
  	new->verify_identifier = FALSE;
  	new->verify_cert = TRUE;
  	new->getcert_method = ISAKMP_GETCERT_PAYLOAD;
  	new->send_cert = TRUE;
  	new->send_cr = TRUE;
! 	new->support_proxy = FALSE;
  	new->gen_policy = FALSE;
  	new->retry_counter = lcconf->retry_counter;
  	new->retry_interval = lcconf->retry_interval;
  
  	return new;
  }
  
  void
  delrmconf(rmconf)
  	struct remoteconf *rmconf;
  {
  	if (rmconf->etypes)
  		deletypes(rmconf->etypes);
  	if (rmconf->dhgrp)
  		oakley_dhgrp_free(rmconf->dhgrp);
  	if (rmconf->proposal)
  		delisakmpsa(rmconf->proposal);
  	racoon_free(rmconf);
  }
  
  void
  delisakmpsa(sa)
  	struct isakmpsa *sa;
  {
  	if (sa->dhgrp)
diff -Nr -c25 ac_am/src/racoon/remoteconf.h ac_am_fixed/src/racoon/remoteconf.h
*** ac_am/src/racoon/remoteconf.h	2003-02-26 22:31:25.000000000 +0100
--- ac_am_fixed/src/racoon/remoteconf.h	2003-12-11 18:19:59.229043936 +0100
***************
*** 43,93 ****
  					/* if family is AF_UNSPEC, that is
  					 * for anonymous configuration. */
  
  	struct etypes *etypes;		/* exchange type list. the head
  					 * is a type to be sent first. */
  	int doitype;			/* doi type */
  	int sittype;			/* situation type */
  
  	int idvtype;			/* my identifier type */
  	vchar_t *idv;			/* my identifier */
  	int idvtype_p;			/* peer's identifier type */
  	vchar_t *idv_p;			/* peer's identifier */
  
  	int certtype;			/* certificate type if need */
  	char *mycertfile;		/* file name of my certificate */
  	char *myprivfile;		/* file name of my private key file */
  	char *peerscertfile;		/* file name of peer's certifcate */
  	int getcert_method;		/* the way to get peer's certificate */
  	int send_cert;			/* send to CERT or not */
  	int send_cr;			/* send to CR or not */
  	int verify_cert;		/* verify a CERT strictly */
  	int verify_identifier;		/* vefify the peer's identifier */
  	int nonce_size;			/* the number of bytes of nonce */
  	int keepalive;			/* XXX may not use */
  	int passive;			/* never initiate */
! 	int support_mip6;		/* support mip6 */
  	int gen_policy;			/* generate policy if no policy found */
  	int ini_contact;		/* initial contact */
  	int pcheck_level;		/* level of propocl checking */
  
  	int dh_group;			/* use it when only aggressive mode */
  	struct dhgroup *dhgrp;		/* use it when only aggressive mode */
  					/* avobe two cann't be defined by user*/
  
  	int retry_counter;		/* times to retry. */
  	int retry_interval;		/* interval each retry. */
  				/* above 2 values are copied from localconf. */
  
  	struct isakmpsa *proposal;	/* proposal list */
  	LIST_ENTRY(remoteconf) chain;	/* next remote conf */
  };
  
  struct dhgroup;
  
  /* ISAKMP SA specification */
  struct isakmpsa {
  	int prop_no;
  	int trns_no;
  	time_t lifetime;
  	int lifebyte;
  	int enctype;
--- 43,93 ----
  					/* if family is AF_UNSPEC, that is
  					 * for anonymous configuration. */
  
  	struct etypes *etypes;		/* exchange type list. the head
  					 * is a type to be sent first. */
  	int doitype;			/* doi type */
  	int sittype;			/* situation type */
  
  	int idvtype;			/* my identifier type */
  	vchar_t *idv;			/* my identifier */
  	int idvtype_p;			/* peer's identifier type */
  	vchar_t *idv_p;			/* peer's identifier */
  
  	int certtype;			/* certificate type if need */
  	char *mycertfile;		/* file name of my certificate */
  	char *myprivfile;		/* file name of my private key file */
  	char *peerscertfile;		/* file name of peer's certifcate */
  	int getcert_method;		/* the way to get peer's certificate */
  	int send_cert;			/* send to CERT or not */
  	int send_cr;			/* send to CR or not */
  	int verify_cert;		/* verify a CERT strictly */
  	int verify_identifier;		/* vefify the peer's identifier */
  	int nonce_size;			/* the number of bytes of nonce */
  	int keepalive;			/* XXX may not use */
  	int passive;			/* never initiate */
! 	int support_proxy;		/* support mip6/proxy */
  	int gen_policy;			/* generate policy if no policy found */
  	int ini_contact;		/* initial contact */
  	int pcheck_level;		/* level of propocl checking */
  
  	int dh_group;			/* use it when only aggressive mode */
  	struct dhgroup *dhgrp;		/* use it when only aggressive mode */
  					/* avobe two cann't be defined by user*/
  
  	int retry_counter;		/* times to retry. */
  	int retry_interval;		/* interval each retry. */
  				/* above 2 values are copied from localconf. */
  
  	struct isakmpsa *proposal;	/* proposal list */
  	LIST_ENTRY(remoteconf) chain;	/* next remote conf */
  };
  
  struct dhgroup;
  
  /* ISAKMP SA specification */
  struct isakmpsa {
  	int prop_no;
  	int trns_no;
  	time_t lifetime;
  	int lifebyte;
  	int enctype;
diff -Nr -c25 ac_am/src/racoon/sainfo.c ac_am_fixed/src/racoon/sainfo.c
*** ac_am/src/racoon/sainfo.c	2003-02-28 05:06:40.000000000 +0100
--- ac_am_fixed/src/racoon/sainfo.c	2003-12-11 18:19:59.231043632 +0100
***************
*** 47,139 ****
  #include "vmbuf.h"
  #include "plog.h"
  #include "sockmisc.h"
  #include "debug.h"
  
  #include "localconf.h"
  #include "isakmp_var.h"
  #include "isakmp.h"
  #include "ipsec_doi.h"
  #include "oakley.h"
  #include "handler.h"
  #include "algorithm.h"
  #include "sainfo.h"
  #include "gcmalloc.h"
  
  static LIST_HEAD(_sitree, sainfo) sitree;
  
  /* %%%
   * modules for ipsec sa info
   */
  /*
   * return matching entry.
   * no matching entry found and if there is anonymous entry, return it.
   * else return NULL.
   * XXX by each data type, should be changed to compare the buffer.
   */
  struct sainfo *
! getsainfo(src, dst)
! 	const vchar_t *src, *dst;
  {
  	struct sainfo *s = NULL;
  	struct sainfo *anonymous = NULL;
  
  	LIST_FOREACH(s, &sitree, chain) {
  		if (s->idsrc == NULL) {
  			anonymous = s;
  			continue;
  		}
  
  		/* anonymous ? */
  		if (src == NULL) {
  			if (anonymous != NULL)
  				break;
  			continue;
  		}
  
  		if (memcmp(src->v, s->idsrc->v, s->idsrc->l) == 0
  		 && memcmp(dst->v, s->iddst->v, s->iddst->l) == 0)
  			return s;
  	}
  
  	if (anonymous) {
  		plog(LLV_DEBUG, LOCATION, NULL,
  			"anonymous sainfo selected.\n");
  	}
  	return anonymous;
  }
  
  struct sainfo *
  newsainfo()
  {
  	struct sainfo *new;
  
  	new = racoon_calloc(1, sizeof(*new));
  	if (new == NULL)
  		return NULL;
  
! 	new->idvtype = IDTYPE_ADDRESS;
  	new->lifetime = IPSECDOI_ATTR_SA_LD_SEC_DEFAULT;
  	new->lifebyte = IPSECDOI_ATTR_SA_LD_KB_MAX;
  
  	return new;
  }
  
  void
  delsainfo(si)
  	struct sainfo *si;
  {
  	int i;
  
  	for (i = 0; i < MAXALGCLASS; i++)
  		delsainfoalg(si->algs[i]);
  
  	if (si->idsrc)
  		vfree(si->idsrc);
  	if (si->iddst)
  		vfree(si->iddst);
  
  	racoon_free(si);
  }
  
  void
  inssainfo(new)
--- 47,155 ----
  #include "vmbuf.h"
  #include "plog.h"
  #include "sockmisc.h"
  #include "debug.h"
  
  #include "localconf.h"
  #include "isakmp_var.h"
  #include "isakmp.h"
  #include "ipsec_doi.h"
  #include "oakley.h"
  #include "handler.h"
  #include "algorithm.h"
  #include "sainfo.h"
  #include "gcmalloc.h"
  
  static LIST_HEAD(_sitree, sainfo) sitree;
  
  /* %%%
   * modules for ipsec sa info
   */
  /*
   * return matching entry.
   * no matching entry found and if there is anonymous entry, return it.
   * else return NULL.
   * XXX by each data type, should be changed to compare the buffer.
+  * First pass is for sainfo from a specified peer, second for others.
   */
  struct sainfo *
! getsainfo(src, dst, peer)
! 	const vchar_t *src, *dst, *peer;
  {
  	struct sainfo *s = NULL;
  	struct sainfo *anonymous = NULL;
+ 	int pass = 1;
  
+ 	if (peer == NULL)
+ 		pass = 2;
+     again:
  	LIST_FOREACH(s, &sitree, chain) {
+ 		if (s->id_i != NULL) {
+ 			if (pass == 2)
+ 				continue;
+ 			if (memcmp(peer->v, s->id_i->v, s->id_i->l) != 0)
+ 				continue;
+ 		} else if (pass == 1)
+ 			continue;
  		if (s->idsrc == NULL) {
  			anonymous = s;
  			continue;
  		}
  
  		/* anonymous ? */
  		if (src == NULL) {
  			if (anonymous != NULL)
  				break;
  			continue;
  		}
  
  		if (memcmp(src->v, s->idsrc->v, s->idsrc->l) == 0
  		 && memcmp(dst->v, s->iddst->v, s->iddst->l) == 0)
  			return s;
  	}
  
  	if (anonymous) {
  		plog(LLV_DEBUG, LOCATION, NULL,
  			"anonymous sainfo selected.\n");
+ 	} else if (pass == 1) {
+ 		pass = 2;
+ 		goto again;
  	}
+ 
  	return anonymous;
  }
  
  struct sainfo *
  newsainfo()
  {
  	struct sainfo *new;
  
  	new = racoon_calloc(1, sizeof(*new));
  	if (new == NULL)
  		return NULL;
  
! 	new->id_i = NULL;
  	new->lifetime = IPSECDOI_ATTR_SA_LD_SEC_DEFAULT;
  	new->lifebyte = IPSECDOI_ATTR_SA_LD_KB_MAX;
  
  	return new;
  }
  
  void
  delsainfo(si)
  	struct sainfo *si;
  {
  	int i;
  
  	for (i = 0; i < MAXALGCLASS; i++)
  		delsainfoalg(si->algs[i]);
  
  	if (si->idsrc)
  		vfree(si->idsrc);
  	if (si->iddst)
  		vfree(si->iddst);
  
  	racoon_free(si);
  }
  
  void
  inssainfo(new)
***************
*** 191,223 ****
  	}
  }
  
  void
  inssainfoalg(head, new)
  	struct sainfoalg **head;
  	struct sainfoalg *new;
  {
  	struct sainfoalg *a;
  
  	for (a = *head; a && a->next; a = a->next)
  		;
  	if (a)
  		a->next = new;
  	else
  		*head = new;
  }
  
  const char *
  sainfo2str(si)
  	const struct sainfo *si;
  {
  	static char buf[256];
  
  	if (si->idsrc == NULL)
! 		return "anonymous";
  
! 	snprintf(buf, sizeof(buf), "%s", ipsecdoi_id2str(si->idsrc));
! 	snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
! 		" %s", ipsecdoi_id2str(si->iddst));
  
  	return buf;
  }
--- 207,244 ----
  	}
  }
  
  void
  inssainfoalg(head, new)
  	struct sainfoalg **head;
  	struct sainfoalg *new;
  {
  	struct sainfoalg *a;
  
  	for (a = *head; a && a->next; a = a->next)
  		;
  	if (a)
  		a->next = new;
  	else
  		*head = new;
  }
  
  const char *
  sainfo2str(si)
  	const struct sainfo *si;
  {
  	static char buf[256];
  
  	if (si->idsrc == NULL)
! 		snprintf(buf, sizeof(buf), "anonymous");
! 	else {
! 		snprintf(buf, sizeof(buf), "%s", ipsecdoi_id2str(si->idsrc));
! 		snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
! 			" %s", ipsecdoi_id2str(si->iddst));
! 	}
  
! 	if (si->id_i != NULL)
! 		snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
! 			" from %s", ipsecdoi_id2str(si->id_i));
  
  	return buf;
  }
diff -Nr -c25 ac_am/src/racoon/sainfo.h ac_am_fixed/src/racoon/sainfo.h
*** ac_am/src/racoon/sainfo.h	2003-02-26 22:31:25.000000000 +0100
--- ac_am_fixed/src/racoon/sainfo.h	2003-12-11 18:19:59.233043328 +0100
***************
*** 22,71 ****
   * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
   * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
   * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
   * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
   * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
   * SUCH DAMAGE.
   */
  
  #include <sys/queue.h>
  
  /* SA info */
  struct sainfo {
  	vchar_t *idsrc;
  	vchar_t *iddst;
  		/*
  		 * idsrc and iddst are constructed body of ID payload.
  		 * that is (struct ipsecdoi_id_b) + ID value.
  		 * If idsrc == NULL, that is anonymous entry.
  		 */
  
  	time_t lifetime;
  	int lifebyte;
  	int pfs_group;		/* only use when pfs is required. */
! 	int idvtype;		/* my identifier type */
! 	vchar_t *idv;		/* my identifier */
  	struct sainfoalg *algs[MAXALGCLASS];
  
  	LIST_ENTRY(sainfo) chain;
  };
  
  /* algorithm type */
  struct sainfoalg {
  	int alg;
  	int encklen;			/* key length if encryption algorithm */
  	struct sainfoalg *next;
  };
  
! extern struct sainfo *getsainfo __P((const vchar_t *, const vchar_t *));
  extern struct sainfo *newsainfo __P((void));
  extern void delsainfo __P((struct sainfo *));
  extern void inssainfo __P((struct sainfo *));
  extern void remsainfo __P((struct sainfo *));
  extern void flushsainfo __P((void));
  extern void initsainfo __P((void));
  extern struct sainfoalg *newsainfoalg __P((void));
  extern void delsainfoalg __P((struct sainfoalg *));
  extern void inssainfoalg __P((struct sainfoalg **, struct sainfoalg *));
  extern const char * sainfo2str __P((const struct sainfo *));
--- 22,71 ----
   * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
   * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
   * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
   * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
   * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
   * SUCH DAMAGE.
   */
  
  #include <sys/queue.h>
  
  /* SA info */
  struct sainfo {
  	vchar_t *idsrc;
  	vchar_t *iddst;
  		/*
  		 * idsrc and iddst are constructed body of ID payload.
  		 * that is (struct ipsecdoi_id_b) + ID value.
  		 * If idsrc == NULL, that is anonymous entry.
  		 */
  
  	time_t lifetime;
  	int lifebyte;
  	int pfs_group;		/* only use when pfs is required. */
! 	vchar_t *id_i;		/* identifier of the authorized initiator */
  	struct sainfoalg *algs[MAXALGCLASS];
  
  	LIST_ENTRY(sainfo) chain;
  };
  
  /* algorithm type */
  struct sainfoalg {
  	int alg;
  	int encklen;			/* key length if encryption algorithm */
  	struct sainfoalg *next;
  };
  
! extern struct sainfo *getsainfo __P((const vchar_t *,
! 	const vchar_t *, const vchar_t *));
  extern struct sainfo *newsainfo __P((void));
  extern void delsainfo __P((struct sainfo *));
  extern void inssainfo __P((struct sainfo *));
  extern void remsainfo __P((struct sainfo *));
  extern void flushsainfo __P((void));
  extern void initsainfo __P((void));
  extern struct sainfoalg *newsainfoalg __P((void));
  extern void delsainfoalg __P((struct sainfoalg *));
  extern void inssainfoalg __P((struct sainfoalg **, struct sainfoalg *));
  extern const char * sainfo2str __P((const struct sainfo *));
diff -Nr -c25 ac_am/src/racoon/session.c ac_am_fixed/src/racoon/session.c
*** ac_am/src/racoon/session.c	2003-03-04 00:30:53.000000000 +0100
--- ac_am_fixed/src/racoon/session.c	2003-12-11 18:19:59.235043024 +0100
***************
*** 304,353 ****
--- 304,358 ----
  	}
  }
  
  /*
   * waiting the termination of processing until sending DELETE message
   * for all inbound SA will complete.
   */
  static void
  check_flushsa_stub(p)
  	void *p;
  {
  
  	check_flushsa();
  }
  
  static void
  check_flushsa()
  {
  	vchar_t *buf;
  	struct sadb_msg *msg, *end, *next;
  	struct sadb_sa *sa;
  	caddr_t mhp[SADB_EXT_MAX + 1];
  	int n;
  
  	buf = pfkey_dump_sadb(SADB_SATYPE_UNSPEC);
+ 	if (buf == NULL) {
+ 		plog(LLV_DEBUG, LOCATION, NULL,
+ 		    "pfkey_dump_sadb: returned nothing.\n");
+ 		return;
+ 	}
  
  	msg = (struct sadb_msg *)buf->v;
  	end = (struct sadb_msg *)(buf->v + buf->l);
  
  	/* counting SA except of dead one. */
  	n = 0;
  	while (msg < end) {
  		if (PFKEY_UNUNIT64(msg->sadb_msg_len) < sizeof(*msg))
  			break;
  		next = (struct sadb_msg *)((caddr_t)msg + PFKEY_UNUNIT64(msg->sadb_msg_len));
  		if (msg->sadb_msg_type != SADB_DUMP) {
  			msg = next;
  			continue;
  		}
  
  		if (pfkey_align(msg, mhp) || pfkey_check(mhp)) {
  			plog(LLV_ERROR, LOCATION, NULL,
  				"pfkey_check (%s)\n", ipsec_strerror());
  			msg = next;
  			continue;
  		}
  
  		sa = (struct sadb_sa *)(mhp[SADB_EXT_SA]);
  		if (!sa) {
  			msg = next;
diff -Nr -c25 ac_am/src/racoon/sockmisc.c ac_am_fixed/src/racoon/sockmisc.c
*** ac_am/src/racoon/sockmisc.c	2003-02-28 05:43:00.000000000 +0100
--- ac_am_fixed/src/racoon/sockmisc.c	2003-12-11 18:19:59.238042568 +0100
***************
*** 523,573 ****
  		cm->cmsg_level = IPPROTO_IPV6;
  		cm->cmsg_type = IPV6_PKTINFO;
  		pi = (struct in6_pktinfo *)CMSG_DATA(cm);
  		memcpy(&pi->ipi6_addr, &src6.sin6_addr, sizeof(src6.sin6_addr));
  		pi->ipi6_ifindex = ifindex;
  
  		plog(LLV_DEBUG, LOCATION, NULL,
  			"src6 %s %d\n",
  			saddr2str((struct sockaddr *)&src6),
  			src6.sin6_scope_id);
  		plog(LLV_DEBUG, LOCATION, NULL,
  			"dst6 %s %d\n",
  			saddr2str((struct sockaddr *)&dst6),
  			dst6.sin6_scope_id);
  
  		for (i = 0; i < cnt; i++) {
  			len = sendmsg(s, &m, 0 /*MSG_DONTROUTE*/);
  			if (len < 0) {
  				plog(LLV_ERROR, LOCATION, NULL,
  					"sendmsg (%s)\n", strerror(errno));
  				return -1;
  			}
  			plog(LLV_DEBUG, LOCATION, NULL,
  				"%d times of %d bytes message will be sent "
  				"to %s\n",
! 				i + 1, len, saddr2str(src));
  		}
  		plogdump(LLV_DEBUG, (char *)buf, buflen);
  
  		return len;
  	    }
  #endif
  	case AF_INET:
  	    {
  		struct msghdr m;
  		struct cmsghdr *cm;
  		struct iovec iov[2];
  		u_char cmsgbuf[256];
  		struct in_pktinfo *pi;
  		int ifindex = 0;
  		struct sockaddr_in src6, dst6;
  
  		memcpy(&src6, src, sizeof(src6));
  		memcpy(&dst6, dst, sizeof(dst6));
  
  		memset(&m, 0, sizeof(m));
  		m.msg_name = (caddr_t)&dst6;
  		m.msg_namelen = sizeof(dst6);
  		iov[0].iov_base = (char *)buf;
  		iov[0].iov_len = buflen;
  		m.msg_iov = iov;
--- 523,573 ----
  		cm->cmsg_level = IPPROTO_IPV6;
  		cm->cmsg_type = IPV6_PKTINFO;
  		pi = (struct in6_pktinfo *)CMSG_DATA(cm);
  		memcpy(&pi->ipi6_addr, &src6.sin6_addr, sizeof(src6.sin6_addr));
  		pi->ipi6_ifindex = ifindex;
  
  		plog(LLV_DEBUG, LOCATION, NULL,
  			"src6 %s %d\n",
  			saddr2str((struct sockaddr *)&src6),
  			src6.sin6_scope_id);
  		plog(LLV_DEBUG, LOCATION, NULL,
  			"dst6 %s %d\n",
  			saddr2str((struct sockaddr *)&dst6),
  			dst6.sin6_scope_id);
  
  		for (i = 0; i < cnt; i++) {
  			len = sendmsg(s, &m, 0 /*MSG_DONTROUTE*/);
  			if (len < 0) {
  				plog(LLV_ERROR, LOCATION, NULL,
  					"sendmsg (%s)\n", strerror(errno));
  				return -1;
  			}
  			plog(LLV_DEBUG, LOCATION, NULL,
  				"%d times of %d bytes message will be sent "
  				"to %s\n",
! 				i + 1, len, saddr2str(dst));
  		}
  		plogdump(LLV_DEBUG, (char *)buf, buflen);
  
  		return len;
  	    }
  #endif
  	case AF_INET:
  	    {
  		struct msghdr m;
  		struct cmsghdr *cm;
  		struct iovec iov[2];
  		u_char cmsgbuf[256];
  		struct in_pktinfo *pi;
  		int ifindex = 0;
  		struct sockaddr_in src6, dst6;
  
  		memcpy(&src6, src, sizeof(src6));
  		memcpy(&dst6, dst, sizeof(dst6));
  
  		memset(&m, 0, sizeof(m));
  		m.msg_name = (caddr_t)&dst6;
  		m.msg_namelen = sizeof(dst6);
  		iov[0].iov_base = (char *)buf;
  		iov[0].iov_len = buflen;
  		m.msg_iov = iov;
***************
*** 657,707 ****
  				close(sendsock);
  				return -1;
  			}
  
  			if (bind(sendsock, (struct sockaddr *)src, sysdep_sa_len(src)) < 0) {
  				plog(LLV_ERROR, LOCATION, NULL,
  					"bind 1 (%s)\n", strerror(errno));
  				close(sendsock);
  				return -1;
  			}
  			needclose = 1;
  		}
  
  		for (i = 0; i < cnt; i++) {
  			len = sendto(sendsock, buf, buflen, 0, dst, sysdep_sa_len(dst));
  			if (len < 0) {
  				plog(LLV_ERROR, LOCATION, NULL,
  					"sendto (%s)\n", strerror(errno));
  				if (needclose)
  					close(sendsock);
  				return len;
  			}
  			plog(LLV_DEBUG, LOCATION, NULL,
  				"%d times of %d bytes message will be sent "
  				"to %s\n",
! 				i + 1, len, saddr2str(src));
  		}
  		plogdump(LLV_DEBUG, (char *)buf, buflen);
  
  		if (needclose)
  			close(sendsock);
  
  		return len;
  	    }
  	}
  }
  
  int
  setsockopt_bypass(so, family)
  	int so, family;
  {
  	int level;
  	char *buf;
  	char *policy;
  
  	switch (family) {
  	case AF_INET:
  		level = IPPROTO_IP;
  		break;
  #ifdef INET6
  	case AF_INET6:
--- 657,707 ----
  				close(sendsock);
  				return -1;
  			}
  
  			if (bind(sendsock, (struct sockaddr *)src, sysdep_sa_len(src)) < 0) {
  				plog(LLV_ERROR, LOCATION, NULL,
  					"bind 1 (%s)\n", strerror(errno));
  				close(sendsock);
  				return -1;
  			}
  			needclose = 1;
  		}
  
  		for (i = 0; i < cnt; i++) {
  			len = sendto(sendsock, buf, buflen, 0, dst, sysdep_sa_len(dst));
  			if (len < 0) {
  				plog(LLV_ERROR, LOCATION, NULL,
  					"sendto (%s)\n", strerror(errno));
  				if (needclose)
  					close(sendsock);
  				return len;
  			}
  			plog(LLV_DEBUG, LOCATION, NULL,
  				"%d times of %d bytes message will be sent "
  				"to %s\n",
! 				i + 1, len, saddr2str(dst));
  		}
  		plogdump(LLV_DEBUG, (char *)buf, buflen);
  
  		if (needclose)
  			close(sendsock);
  
  		return len;
  	    }
  	}
  }
  
  int
  setsockopt_bypass(so, family)
  	int so, family;
  {
  	int level;
  	char *buf;
  	char *policy;
  
  	switch (family) {
  	case AF_INET:
  		level = IPPROTO_IP;
  		break;
  #ifdef INET6
  	case AF_INET6:
***************
*** 847,896 ****
--- 847,897 ----
  	hints.ai_socktype = SOCK_DGRAM;
  	hints.ai_flags = AI_NUMERICHOST;
  	error = getaddrinfo(host, port, &hints, &res);
  	if (error != 0) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"getaddrinfo(%s%s%s): %s",
  			host, port ? "," : "", port ? port : "",
  			gai_strerror(error));
  		return NULL;
  	}
  	if (res->ai_next != NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"getaddrinfo(%s%s%s): "
  			"resolved to multiple address, "
  			"taking the first one",
  			host, port ? "," : "", port ? port : "");
  	}
  	saddr = racoon_malloc(res->ai_addrlen);
  	if (saddr == NULL) {
  		plog(LLV_ERROR, LOCATION, NULL,
  			"failed to allocate buffer.\n");
  		freeaddrinfo(res);
  		return NULL;
  	}
  	memcpy(saddr, res->ai_addr, res->ai_addrlen);
+ 	freeaddrinfo(res);
  
  	return saddr;
  }
  
  void
  mask_sockaddr(a, b, l)
  	struct sockaddr *a;
  	const struct sockaddr *b;
  	size_t l;
  {
  	size_t i;
  	u_int8_t *p, alen;
  
  	switch (b->sa_family) {
  	case AF_INET:
  		alen = sizeof(struct in_addr);
  		p = (u_int8_t *)&((struct sockaddr_in *)a)->sin_addr;
  		break;
  #ifdef INET6
  	case AF_INET6:
  		alen = sizeof(struct in6_addr);
  		p = (u_int8_t *)&((struct sockaddr_in6 *)a)->sin6_addr;
  		break;
  #endif
  	default:
diff -Nr -c25 ac_am/src/racoon/sockmisc.c.orig ac_am_fixed/src/racoon/sockmisc.c.orig
*** ac_am/src/racoon/sockmisc.c.orig	1970-01-01 01:00:00.000000000 +0100
--- ac_am_fixed/src/racoon/sockmisc.c.orig	2003-12-11 18:19:59.247041200 +0100
***************
*** 0 ****
--- 1,912 ----
+ /*	$KAME: sockmisc.c,v 1.36 2002/04/15 06:20:08 sakane Exp $	*/
+ 
+ /*
+  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
+  * All rights reserved.
+  * 
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions
+  * are met:
+  * 1. Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  * 2. Redistributions in binary form must reproduce the above copyright
+  *    notice, this list of conditions and the following disclaimer in the
+  *    documentation and/or other materials provided with the distribution.
+  * 3. Neither the name of the project nor the names of its contributors
+  *    may be used to endorse or promote products derived from this software
+  *    without specific prior written permission.
+  * 
+  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+  * SUCH DAMAGE.
+  */
+ 
+ #include <sys/types.h>
+ #include <sys/param.h>
+ #include <sys/socket.h>
+ #include <sys/uio.h>
+ 
+ #include <netinet/in.h>
+ #ifdef IPV6_INRIA_VERSION
+ #include <netinet/ipsec.h>
+ #if defined(IP_RECVDSTADDR) && !defined(IPV6_RECVDSTADDR)
+ #define IPV6_RECVDSTADDR IP_RECVDSTADDR
+ #endif
+ #else
+ #include <netinet6/ipsec.h>
+ #endif
+ 
+ #include <stdlib.h>
+ #include <stdio.h>
+ #include <string.h>
+ #include <errno.h>
+ #ifdef HAVE_UNISTD_H
+ #include <unistd.h>
+ #endif
+ 
+ #include "var.h"
+ #include "misc.h"
+ #include "plog.h"
+ #include "sockmisc.h"
+ #include "debug.h"
+ #include "gcmalloc.h"
+ #include "libpfkey.h"
+ 
+ #ifndef IP_IPSEC_POLICY
+ #define IP_IPSEC_POLICY 16	/* XXX: from linux/in.h */
+ #endif
+ 
+ const int niflags = 0;
+ 
+ /*
+  * compare two sockaddr without port number.
+  * OUT:	0: equal.
+  *	1: not equal.
+  */
+ int
+ cmpsaddrwop(addr1, addr2)
+ 	struct sockaddr *addr1;
+ 	struct sockaddr *addr2;
+ {
+ 	caddr_t sa1, sa2;
+ 
+ 	if (addr1 == 0 && addr2 == 0)
+ 		return 0;
+ 	if (addr1 == 0 || addr2 == 0)
+ 		return 1;
+ 
+ #ifdef __linux__
+ 	if (addr1->sa_family != addr2->sa_family)
+ 		return 1;
+ #else
+ 	if (addr1->sa_len != addr2->sa_len
+ 	 || addr1->sa_family != addr2->sa_family)
+ 		return 1;
+ 
+ #endif /* __linux__ */
+ 
+ 	switch (addr1->sa_family) {
+ 	case AF_INET:
+ 		sa1 = (caddr_t)&((struct sockaddr_in *)addr1)->sin_addr;
+ 		sa2 = (caddr_t)&((struct sockaddr_in *)addr2)->sin_addr;
+ 		if (memcmp(sa1, sa2, sizeof(struct in_addr)) != 0)
+ 			return 1;
+ 		break;
+ #ifdef INET6
+ 	case AF_INET6:
+ 		sa1 = (caddr_t)&((struct sockaddr_in6 *)addr1)->sin6_addr;
+ 		sa2 = (caddr_t)&((struct sockaddr_in6 *)addr2)->sin6_addr;
+ 		if (memcmp(sa1, sa2, sizeof(struct in6_addr)) != 0)
+ 			return 1;
+ 		if (((struct sockaddr_in6 *)addr1)->sin6_scope_id !=
+ 		    ((struct sockaddr_in6 *)addr2)->sin6_scope_id)
+ 			return 1;
+ 		break;
+ #endif
+ 	default:
+ 		return 1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * compare two sockaddr with port, taking care wildcard.
+  * addr1 is a subject address, addr2 is in a database entry.
+  * OUT:	0: equal.
+  *	1: not equal.
+  */
+ int
+ cmpsaddrwild(addr1, addr2)
+ 	struct sockaddr *addr1;
+ 	struct sockaddr *addr2;
+ {
+ 	caddr_t sa1, sa2;
+ 	u_short port1, port2;
+ 
+ 	if (addr1 == 0 && addr2 == 0)
+ 		return 0;
+ 	if (addr1 == 0 || addr2 == 0)
+ 		return 1;
+ 
+ #ifdef __linux__
+ 	if (addr1->sa_family != addr2->sa_family)
+ 		return 1;
+ #else
+ 	if (addr1->sa_len != addr2->sa_len
+ 	 || addr1->sa_family != addr2->sa_family)
+ 		return 1;
+ 
+ #endif /* __linux__ */
+ 
+ 	switch (addr1->sa_family) {
+ 	case AF_INET:
+ 		sa1 = (caddr_t)&((struct sockaddr_in *)addr1)->sin_addr;
+ 		sa2 = (caddr_t)&((struct sockaddr_in *)addr2)->sin_addr;
+ 		port1 = ((struct sockaddr_in *)addr1)->sin_port;
+ 		port2 = ((struct sockaddr_in *)addr2)->sin_port;
+ 		if (!(port1 == IPSEC_PORT_ANY ||
+ 		      port2 == IPSEC_PORT_ANY ||
+ 		      port1 == port2))
+ 			return 1;
+ 		if (memcmp(sa1, sa2, sizeof(struct in_addr)) != 0)
+ 			return 1;
+ 		break;
+ #ifdef INET6
+ 	case AF_INET6:
+ 		sa1 = (caddr_t)&((struct sockaddr_in6 *)addr1)->sin6_addr;
+ 		sa2 = (caddr_t)&((struct sockaddr_in6 *)addr2)->sin6_addr;
+ 		port1 = ((struct sockaddr_in6 *)addr1)->sin6_port;
+ 		port2 = ((struct sockaddr_in6 *)addr2)->sin6_port;
+ 		if (!(port1 == IPSEC_PORT_ANY ||
+ 		      port2 == IPSEC_PORT_ANY ||
+ 		      port1 == port2))
+ 			return 1;
+ 		if (memcmp(sa1, sa2, sizeof(struct in6_addr)) != 0)
+ 			return 1;
+ 		if (((struct sockaddr_in6 *)addr1)->sin6_scope_id !=
+ 		    ((struct sockaddr_in6 *)addr2)->sin6_scope_id)
+ 			return 1;
+ 		break;
+ #endif
+ 	default:
+ 		return 1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * compare two sockaddr with strict match on port.
+  * OUT:	0: equal.
+  *	1: not equal.
+  */
+ int
+ cmpsaddrstrict(addr1, addr2)
+ 	struct sockaddr *addr1;
+ 	struct sockaddr *addr2;
+ {
+ 	caddr_t sa1, sa2;
+ 	u_short port1, port2;
+ 
+ 	if (addr1 == 0 && addr2 == 0)
+ 		return 0;
+ 	if (addr1 == 0 || addr2 == 0)
+ 		return 1;
+ 
+ #ifdef __linux__
+ 	if (addr1->sa_family != addr2->sa_family)
+ 		return 1;
+ #else
+ 	if (addr1->sa_len != addr2->sa_len
+ 	 || addr1->sa_family != addr2->sa_family)
+ 		return 1;
+ 
+ #endif /* __linux__ */
+ 
+ 	switch (addr1->sa_family) {
+ 	case AF_INET:
+ 		sa1 = (caddr_t)&((struct sockaddr_in *)addr1)->sin_addr;
+ 		sa2 = (caddr_t)&((struct sockaddr_in *)addr2)->sin_addr;
+ 		port1 = ((struct sockaddr_in *)addr1)->sin_port;
+ 		port2 = ((struct sockaddr_in *)addr2)->sin_port;
+ 		if (port1 != port2)
+ 			return 1;
+ 		if (memcmp(sa1, sa2, sizeof(struct in_addr)) != 0)
+ 			return 1;
+ 		break;
+ #ifdef INET6
+ 	case AF_INET6:
+ 		sa1 = (caddr_t)&((struct sockaddr_in6 *)addr1)->sin6_addr;
+ 		sa2 = (caddr_t)&((struct sockaddr_in6 *)addr2)->sin6_addr;
+ 		port1 = ((struct sockaddr_in6 *)addr1)->sin6_port;
+ 		port2 = ((struct sockaddr_in6 *)addr2)->sin6_port;
+ 		if (port1 != port2)
+ 			return 1;
+ 		if (memcmp(sa1, sa2, sizeof(struct in6_addr)) != 0)
+ 			return 1;
+ 		if (((struct sockaddr_in6 *)addr1)->sin6_scope_id !=
+ 		    ((struct sockaddr_in6 *)addr2)->sin6_scope_id)
+ 			return 1;
+ 		break;
+ #endif
+ 	default:
+ 		return 1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /* get local address against the destination. */
+ struct sockaddr *
+ getlocaladdr(remote)
+ 	struct sockaddr *remote;
+ {
+ 	struct sockaddr *local;
+ 	int local_len = sizeof(struct sockaddr_storage);
+ 	int s;	/* for dummy connection */
+ 
+ 	/* allocate buffer */
+ 	if ((local = racoon_calloc(1, local_len)) == NULL) {
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"failed to get address buffer.\n");
+ 		goto err;
+ 	}
+ 	
+ 	/* get real interface received packet */
+ 	if ((s = socket(remote->sa_family, SOCK_DGRAM, 0)) < 0) {
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"socket (%s)\n", strerror(errno));
+ 		goto err;
+ 	}
+ 
+ 	setsockopt_bypass(s, remote->sa_family);
+ 	
+ 	if (connect(s, remote, sysdep_sa_len(remote)) < 0) {
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"connect (%s)\n", strerror(errno));
+ 		close(s);
+ 		goto err;
+ 	}
+ 
+ 	if (getsockname(s, local, &local_len) < 0) {
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"getsockname (%s)\n", strerror(errno));
+ 		close(s);
+ 		return NULL;
+ 	}
+ 
+ 	close(s);
+ 	return local;
+ 
+     err:
+ 	if (local != NULL)
+ 		racoon_free(local);
+ 	return NULL;
+ }
+ 
+ /*
+  * Receive packet, with src/dst information.  It is assumed that necessary
+  * setsockopt() have already performed on socket.
+  */
+ int
+ recvfromto(s, buf, buflen, flags, from, fromlen, to, tolen)
+ 	int s;
+ 	void *buf;
+ 	size_t buflen;
+ 	int flags;
+ 	struct sockaddr *from;
+ 	int *fromlen;
+ 	struct sockaddr *to;
+ 	int *tolen;
+ {
+ 	int otolen;
+ 	int len;
+ 	struct sockaddr_storage ss;
+ 	struct msghdr m;
+ 	struct cmsghdr *cm;
+ 	struct iovec iov[2];
+ 	u_char cmsgbuf[256];
+ #if defined(INET6) && defined(ADVAPI)
+ 	struct in6_pktinfo *pi;
+ #endif /*ADVAPI*/
+ 	struct sockaddr_in *sin;
+ #ifdef INET6
+ 	struct sockaddr_in6 *sin6;
+ #endif
+ 
+ 	len = sizeof(ss);
+ 	if (getsockname(s, (struct sockaddr *)&ss, &len) < 0) {
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"getsockname (%s)\n", strerror(errno));
+ 		return -1;
+ 	}
+ 
+ 	m.msg_name = (caddr_t)from;
+ 	m.msg_namelen = *fromlen;
+ 	iov[0].iov_base = (caddr_t)buf;
+ 	iov[0].iov_len = buflen;
+ 	m.msg_iov = iov;
+ 	m.msg_iovlen = 1;
+ 	memset(cmsgbuf, 0, sizeof(cmsgbuf));
+ 	cm = (struct cmsghdr *)cmsgbuf;
+ 	m.msg_control = (caddr_t)cm;
+ 	m.msg_controllen = sizeof(cmsgbuf);
+ 	if ((len = recvmsg(s, &m, flags)) < 0) {
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"recvmsg (%s)\n", strerror(errno));
+ 		return -1;
+ 	}
+ 	*fromlen = m.msg_namelen;
+ 
+ 	otolen = *tolen;
+ 	*tolen = 0;
+ 	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(&m);
+ 	     m.msg_controllen != 0 && cm;
+ 	     cm = (struct cmsghdr *)CMSG_NXTHDR(&m, cm)) {
+ #if 0
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"cmsg %d %d\n", cm->cmsg_level, cm->cmsg_type);)
+ #endif
+ #if defined(INET6) && defined(ADVAPI)
+ 		if (ss.ss_family == AF_INET6
+ 		 && cm->cmsg_level == IPPROTO_IPV6
+ 		 && cm->cmsg_type == IPV6_PKTINFO
+ 		 && otolen >= sizeof(*sin6)) {
+ 			pi = (struct in6_pktinfo *)(CMSG_DATA(cm));
+ 			*tolen = sizeof(*sin6);
+ 			sin6 = (struct sockaddr_in6 *)to;
+ 			memset(sin6, 0, sizeof(*sin6));
+ 			sin6->sin6_family = AF_INET6;
+ #ifndef __linux__
+ 			sin6->sin6_len = sizeof(*sin6);
+ #endif
+ 			memcpy(&sin6->sin6_addr, &pi->ipi6_addr,
+ 				sizeof(sin6->sin6_addr));
+ 			/* XXX other cases, such as site-local? */
+ 			if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr))
+ 				sin6->sin6_scope_id = pi->ipi6_ifindex;
+ 			else
+ 				sin6->sin6_scope_id = 0;
+ 			sin6->sin6_port =
+ 				((struct sockaddr_in6 *)&ss)->sin6_port;
+ 			otolen = -1;	/* "to" already set */
+ 			continue;
+ 		}
+ #endif
+ #ifdef __linux__
+ 		if (ss.ss_family == AF_INET
+ 		 && cm->cmsg_level == IPPROTO_IP
+ 		 && cm->cmsg_type == IP_PKTINFO
+ 		 && otolen >= sizeof(sin)) {
+ 			struct in_pktinfo *pi = (struct in_pktinfo *)(CMSG_DATA(cm));
+ 			*tolen = sizeof(*sin);
+ 			sin = (struct sockaddr_in *)to;
+ 			memset(sin, 0, sizeof(*sin));
+ 			sin->sin_family = AF_INET;
+ 			memcpy(&sin->sin_addr, &pi->ipi_addr,
+ 				sizeof(sin->sin_addr));
+ 			sin->sin_port =
+ 				((struct sockaddr_in *)&ss)->sin_port;
+ 			otolen = -1;	/* "to" already set */
+ 			continue;
+ 		}
+ #endif
+ #if defined(INET6) && defined(IPV6_RECVDSTADDR)
+ 		if (ss.ss_family == AF_INET6
+ 		      && cm->cmsg_level == IPPROTO_IPV6
+ 		      && cm->cmsg_type == IPV6_RECVDSTADDR
+ 		      && otolen >= sizeof(*sin6)) {
+ 			*tolen = sizeof(*sin6);
+ 			sin6 = (struct sockaddr_in6 *)to;
+ 			memset(sin6, 0, sizeof(*sin6));
+ 			sin6->sin6_family = AF_INET6;
+ 			sin6->sin6_len = sizeof(*sin6);
+ 			memcpy(&sin6->sin6_addr, CMSG_DATA(cm),
+ 				sizeof(sin6->sin6_addr));
+ 			sin6->sin6_port =
+ 				((struct sockaddr_in6 *)&ss)->sin6_port;
+ 			otolen = -1;	/* "to" already set */
+ 			continue;
+ 		}
+ #endif
+ #ifndef __linux__
+ 		if (ss.ss_family == AF_INET
+ 		 && cm->cmsg_level == IPPROTO_IP
+ 		 && cm->cmsg_type == IP_RECVDSTADDR
+ 		 && otolen >= sizeof(*sin)) {
+ 			*tolen = sizeof(*sin);
+ 			sin = (struct sockaddr_in *)to;
+ 			memset(sin, 0, sizeof(*sin));
+ 			sin->sin_family = AF_INET;
+ 			sin->sin_len = sizeof(*sin);
+ 			memcpy(&sin->sin_addr, CMSG_DATA(cm),
+ 				sizeof(sin->sin_addr));
+ 			sin->sin_port = ((struct sockaddr_in *)&ss)->sin_port;
+ 			otolen = -1;	/* "to" already set */
+ 			continue;
+ 		}
+ #endif
+ 	}
+ 
+ 	return len;
+ }
+ 
+ /* send packet, with fixing src/dst address pair. */
+ int
+ sendfromto(s, buf, buflen, src, dst, cnt)
+ 	int s, cnt;
+ 	const void *buf;
+ 	size_t buflen;
+ 	struct sockaddr *src;
+ 	struct sockaddr *dst;
+ {
+ 	struct sockaddr_storage ss;
+ 	int len;
+ 	int i;
+ 
+ 	if (src->sa_family != dst->sa_family) {
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"address family mismatch\n");
+ 		return -1;
+ 	}
+ 
+ 	len = sizeof(ss);
+ 	if (getsockname(s, (struct sockaddr *)&ss, &len) < 0) {
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"getsockname (%s)\n", strerror(errno));
+ 		return -1;
+ 	}
+ 
+ 	plog(LLV_DEBUG, LOCATION, NULL,
+ 		"sockname %s\n", saddr2str((struct sockaddr *)&ss));
+ 	plog(LLV_DEBUG, LOCATION, NULL,
+ 		"send packet from %s\n", saddr2str(src));
+ 	plog(LLV_DEBUG, LOCATION, NULL,
+ 		"send packet to %s\n", saddr2str(dst));
+ 
+ 	if (src->sa_family != ss.ss_family) {
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"address family mismatch\n");
+ 		return -1;
+ 	}
+ 
+ 	switch (src->sa_family) {
+ #if defined(INET6) && defined(ADVAPI) && !defined(IPV6_INRIA_VERSION)
+ 	case AF_INET6:
+ 	    {
+ 		struct msghdr m;
+ 		struct cmsghdr *cm;
+ 		struct iovec iov[2];
+ 		u_char cmsgbuf[256];
+ 		struct in6_pktinfo *pi;
+ 		int ifindex;
+ 		struct sockaddr_in6 src6, dst6;
+ 
+ 		memcpy(&src6, src, sizeof(src6));
+ 		memcpy(&dst6, dst, sizeof(dst6));
+ 
+ 		/* XXX take care of other cases, such as site-local */
+ 		ifindex = 0;
+ 		if (IN6_IS_ADDR_LINKLOCAL(&src6.sin6_addr)
+ 		 || IN6_IS_ADDR_MULTICAST(&src6.sin6_addr)) {
+ 			ifindex = src6.sin6_scope_id;	/*???*/
+ 		}
+ 
+ 		/* XXX some sanity check on dst6.sin6_scope_id */
+ 
+ 		/* flowinfo for IKE?  mmm, maybe useful but for now make it 0 */
+ 		src6.sin6_flowinfo = dst6.sin6_flowinfo = 0;
+ 
+ 		memset(&m, 0, sizeof(m));
+ 		m.msg_name = (caddr_t)&dst6;
+ 		m.msg_namelen = sizeof(dst6);
+ 		iov[0].iov_base = (char *)buf;
+ 		iov[0].iov_len = buflen;
+ 		m.msg_iov = iov;
+ 		m.msg_iovlen = 1;
+ 
+ 		memset(cmsgbuf, 0, sizeof(cmsgbuf));
+ 		cm = (struct cmsghdr *)cmsgbuf;
+ 		m.msg_control = (caddr_t)cm;
+ 		m.msg_controllen = CMSG_SPACE(sizeof(struct in6_pktinfo));
+ 
+ 		cm->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));
+ 		cm->cmsg_level = IPPROTO_IPV6;
+ 		cm->cmsg_type = IPV6_PKTINFO;
+ 		pi = (struct in6_pktinfo *)CMSG_DATA(cm);
+ 		memcpy(&pi->ipi6_addr, &src6.sin6_addr, sizeof(src6.sin6_addr));
+ 		pi->ipi6_ifindex = ifindex;
+ 
+ 		plog(LLV_DEBUG, LOCATION, NULL,
+ 			"src6 %s %d\n",
+ 			saddr2str((struct sockaddr *)&src6),
+ 			src6.sin6_scope_id);
+ 		plog(LLV_DEBUG, LOCATION, NULL,
+ 			"dst6 %s %d\n",
+ 			saddr2str((struct sockaddr *)&dst6),
+ 			dst6.sin6_scope_id);
+ 
+ 		for (i = 0; i < cnt; i++) {
+ 			len = sendmsg(s, &m, 0 /*MSG_DONTROUTE*/);
+ 			if (len < 0) {
+ 				plog(LLV_ERROR, LOCATION, NULL,
+ 					"sendmsg (%s)\n", strerror(errno));
+ 				return -1;
+ 			}
+ 			plog(LLV_DEBUG, LOCATION, NULL,
+ 				"%d times of %d bytes message will be sent "
+ 				"to %s\n",
+ 				i + 1, len, saddr2str(src));
+ 		}
+ 		plogdump(LLV_DEBUG, (char *)buf, buflen);
+ 
+ 		return len;
+ 	    }
+ #endif
+ 	case AF_INET:
+ 	    {
+ 		struct msghdr m;
+ 		struct cmsghdr *cm;
+ 		struct iovec iov[2];
+ 		u_char cmsgbuf[256];
+ 		struct in_pktinfo *pi;
+ 		int ifindex = 0;
+ 		struct sockaddr_in src6, dst6;
+ 
+ 		memcpy(&src6, src, sizeof(src6));
+ 		memcpy(&dst6, dst, sizeof(dst6));
+ 
+ 		memset(&m, 0, sizeof(m));
+ 		m.msg_name = (caddr_t)&dst6;
+ 		m.msg_namelen = sizeof(dst6);
+ 		iov[0].iov_base = (char *)buf;
+ 		iov[0].iov_len = buflen;
+ 		m.msg_iov = iov;
+ 		m.msg_iovlen = 1;
+ 
+ 		memset(cmsgbuf, 0, sizeof(cmsgbuf));
+ 		cm = (struct cmsghdr *)cmsgbuf;
+ 		m.msg_control = (caddr_t)cm;
+ 		m.msg_controllen = CMSG_SPACE(sizeof(struct in_pktinfo));
+ 
+ 		cm->cmsg_len = CMSG_LEN(sizeof(struct in_pktinfo));
+ 		cm->cmsg_level = IPPROTO_IP;
+ 		cm->cmsg_type = IP_PKTINFO;
+ 		pi = (struct in_pktinfo *)CMSG_DATA(cm);
+ 		memcpy(&pi->ipi_addr, &src6.sin_addr, sizeof(src6.sin_addr));
+ 		pi->ipi_ifindex = ifindex;
+ 
+ 		plog(LLV_DEBUG, LOCATION, NULL,
+ 			"src4 %s\n",
+ 			saddr2str((struct sockaddr *)&src6));
+ 		plog(LLV_DEBUG, LOCATION, NULL,
+ 			"dst4 %s\n",
+ 			saddr2str((struct sockaddr *)&dst6));
+ 
+ 		for (i = 0; i < cnt; i++) {
+ 			len = sendmsg(s, &m, 0 /*MSG_DONTROUTE*/);
+ 			if (len < 0) {
+ 				plog(LLV_ERROR, LOCATION, NULL,
+ 					"sendmsg (%s)\n", strerror(errno));
+ 				return -1;
+ 			}
+ 			plog(LLV_DEBUG, LOCATION, NULL,
+ 				"%d times of %d bytes message will be sent "
+ 				"to %s\n",
+ 				i + 1, len, saddr2str(src));
+ 		}
+ 		plogdump(LLV_DEBUG, (char *)buf, buflen);
+ 
+ 		return len;
+ 	    }
+ 	default:
+ 	    {
+ 		int needclose = 0;
+ 		int sendsock;
+ 
+ 		if (ss.ss_family == src->sa_family && memcmp(&ss, src, sysdep_sa_len(src)) == 0) {
+ 			sendsock = s;
+ 			needclose = 0;
+ 		} else {
+ 			int yes = 1;
+ 			/*
+ 			 * Use newly opened socket for sending packets.
+ 			 * NOTE: this is unsafe, because if the peer is quick enough
+ 			 * the packet from the peer may be queued into sendsock.
+ 			 * Better approach is to prepare bind'ed udp sockets for
+ 			 * each of the interface addresses.
+ 			 */
+ 			sendsock = socket(src->sa_family, SOCK_DGRAM, 0);
+ 			if (sendsock < 0) {
+ 				plog(LLV_ERROR, LOCATION, NULL,
+ 					"socket (%s)\n", strerror(errno));
+ 				return -1;
+ 			}
+ 			if (setsockopt(sendsock, SOL_SOCKET,
+ #ifdef __linux__
+ 				       SO_REUSEADDR,
+ #else
+ 				       SO_REUSEPORT,
+ #endif
+ 				       (void *)&yes, sizeof(yes)) < 0) {
+ 				plog(LLV_ERROR, LOCATION, NULL,
+ 					"setsockopt (%s)\n", strerror(errno));
+ 				close(sendsock);
+ 				return -1;
+ 			}
+ #ifdef IPV6_USE_MIN_MTU
+ 			if (src->sa_family == AF_INET6 &&
+ 			    setsockopt(sendsock, IPPROTO_IPV6, IPV6_USE_MIN_MTU,
+ 			    (void *)&yes, sizeof(yes)) < 0) {
+ 				plog(LLV_ERROR, LOCATION, NULL,
+ 					"setsockopt (%s)\n", strerror(errno));
+ 				close(sendsock);
+ 				return -1;
+ 			}
+ #endif
+ 			if (setsockopt_bypass(sendsock, src->sa_family) < 0) {
+ 				close(sendsock);
+ 				return -1;
+ 			}
+ 
+ 			if (bind(sendsock, (struct sockaddr *)src, sysdep_sa_len(src)) < 0) {
+ 				plog(LLV_ERROR, LOCATION, NULL,
+ 					"bind 1 (%s)\n", strerror(errno));
+ 				close(sendsock);
+ 				return -1;
+ 			}
+ 			needclose = 1;
+ 		}
+ 
+ 		for (i = 0; i < cnt; i++) {
+ 			len = sendto(sendsock, buf, buflen, 0, dst, sysdep_sa_len(dst));
+ 			if (len < 0) {
+ 				plog(LLV_ERROR, LOCATION, NULL,
+ 					"sendto (%s)\n", strerror(errno));
+ 				if (needclose)
+ 					close(sendsock);
+ 				return len;
+ 			}
+ 			plog(LLV_DEBUG, LOCATION, NULL,
+ 				"%d times of %d bytes message will be sent "
+ 				"to %s\n",
+ 				i + 1, len, saddr2str(src));
+ 		}
+ 		plogdump(LLV_DEBUG, (char *)buf, buflen);
+ 
+ 		if (needclose)
+ 			close(sendsock);
+ 
+ 		return len;
+ 	    }
+ 	}
+ }
+ 
+ int
+ setsockopt_bypass(so, family)
+ 	int so, family;
+ {
+ 	int level;
+ 	char *buf;
+ 	char *policy;
+ 
+ 	switch (family) {
+ 	case AF_INET:
+ 		level = IPPROTO_IP;
+ 		break;
+ #ifdef INET6
+ 	case AF_INET6:
+ 		level = IPPROTO_IPV6;
+ 		break;
+ #endif
+ 	default:
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"unsupported address family %d\n", family);
+ 		return -1;
+ 	}
+ 
+ #ifndef IPV6_IPSEC_POLICY
+ #define IPV6_IPSEC_POLICY IP_IPSEC_POLICY
+ #endif
+ 
+ 	policy = "in bypass";
+ 	buf = ipsec_set_policy(policy, strlen(policy));
+ 	if (buf == NULL) {
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"ipsec_set_policy (%s)\n",
+ 			ipsec_strerror());
+ 		return -1;
+ 	}
+ 	if (setsockopt(so, level,
+ 	               (level == IPPROTO_IP ?
+ 	                         IP_IPSEC_POLICY : IPV6_IPSEC_POLICY),
+ 	               buf, ipsec_get_policylen(buf)) < 0) {
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"setsockopt (%s)\n",
+ 			strerror(errno));
+ 		return -1;
+ 	}
+ 	racoon_free(buf);
+ 
+ 	policy = "out bypass";
+ 	buf = ipsec_set_policy(policy, strlen(policy));
+ 	if (buf == NULL) {
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"ipsec_set_policy (%s)\n",
+ 			ipsec_strerror());
+ 		return -1;
+ 	}
+ 	if (setsockopt(so, level,
+ 	               (level == IPPROTO_IP ?
+ 	                         IP_IPSEC_POLICY : IPV6_IPSEC_POLICY),
+ 	               buf, ipsec_get_policylen(buf)) < 0) {
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"setsockopt (%s)\n",
+ 			strerror(errno));
+ 		return -1;
+ 	}
+ 	racoon_free(buf);
+ 
+ 	return 0;
+ }
+ 
+ struct sockaddr *
+ newsaddr(len)
+ 	int len;
+ {
+ 	struct sockaddr *new;
+ 
+ 	new = racoon_calloc(1, len);
+ 	if (new == NULL)
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"%s\n", strerror(errno)); 
+ 
+ #ifdef __linux__
+ 	if (len == sizeof (struct sockaddr_in6))
+ 		new->sa_family = AF_INET6;
+ 	else
+ 		new->sa_family = AF_INET;
+ #else
+ 	/* initial */
+ 	new->sa_len = len;
+ #endif
+ 
+ 	return new;
+ }
+ 
+ struct sockaddr *
+ dupsaddr(src)
+ 	struct sockaddr *src;
+ {
+ 	struct sockaddr *dst;
+ 
+ 	dst = racoon_calloc(1, sysdep_sa_len(src));
+ 	if (dst == NULL) {
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"%s\n", strerror(errno)); 
+ 		return NULL;
+ 	}
+ 
+ 	memcpy(dst, src, sysdep_sa_len(src));
+ 
+ 	return dst;
+ }
+ 
+ char *
+ saddr2str(saddr)
+ 	const struct sockaddr *saddr;
+ {
+ 	static char buf[NI_MAXHOST + NI_MAXSERV + 10];
+ 	char addr[NI_MAXHOST], port[NI_MAXSERV];
+ 
+ 	if (saddr == NULL)
+ 		return NULL;
+ 
+ 	GETNAMEINFO(saddr, addr, port);
+ 	snprintf(buf, sizeof(buf), "%s[%s]", addr, port);
+ 
+ 	return buf;
+ }
+ 
+ char *
+ saddrwop2str(saddr)
+ 	struct sockaddr *saddr;
+ {
+ 	static char buf[NI_MAXHOST + NI_MAXSERV + 10];
+ 	char addr[NI_MAXHOST];
+ 
+ 	if (saddr == NULL)
+ 		return NULL;
+ 
+ 	GETNAMEINFO(saddr, addr, NULL);
+ 	snprintf(buf, sizeof(buf), "%s", addr);
+ 
+ 	return buf;
+ }
+ 
+ struct sockaddr *
+ str2saddr(host, port)
+ 	char *host;
+ 	char *port;
+ {
+ 	struct addrinfo hints, *res;
+ 	struct sockaddr *saddr;
+ 	int error;
+ 
+ 	memset(&hints, 0, sizeof(hints));
+ 	hints.ai_family = PF_UNSPEC;
+ 	hints.ai_socktype = SOCK_DGRAM;
+ 	hints.ai_flags = AI_NUMERICHOST;
+ 	error = getaddrinfo(host, port, &hints, &res);
+ 	if (error != 0) {
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"getaddrinfo(%s%s%s): %s",
+ 			host, port ? "," : "", port ? port : "",
+ 			gai_strerror(error));
+ 		return NULL;
+ 	}
+ 	if (res->ai_next != NULL) {
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"getaddrinfo(%s%s%s): "
+ 			"resolved to multiple address, "
+ 			"taking the first one",
+ 			host, port ? "," : "", port ? port : "");
+ 	}
+ 	saddr = racoon_malloc(res->ai_addrlen);
+ 	if (saddr == NULL) {
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"failed to allocate buffer.\n");
+ 		freeaddrinfo(res);
+ 		return NULL;
+ 	}
+ 	memcpy(saddr, res->ai_addr, res->ai_addrlen);
+ 
+ 	return saddr;
+ }
+ 
+ void
+ mask_sockaddr(a, b, l)
+ 	struct sockaddr *a;
+ 	const struct sockaddr *b;
+ 	size_t l;
+ {
+ 	size_t i;
+ 	u_int8_t *p, alen;
+ 
+ 	switch (b->sa_family) {
+ 	case AF_INET:
+ 		alen = sizeof(struct in_addr);
+ 		p = (u_int8_t *)&((struct sockaddr_in *)a)->sin_addr;
+ 		break;
+ #ifdef INET6
+ 	case AF_INET6:
+ 		alen = sizeof(struct in6_addr);
+ 		p = (u_int8_t *)&((struct sockaddr_in6 *)a)->sin6_addr;
+ 		break;
+ #endif
+ 	default:
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"invalid family: %d\n", b->sa_family);
+ 		exit(1);
+ 	}
+ 
+ 	if ((alen << 3) < l) {
+ 		plog(LLV_ERROR, LOCATION, NULL,
+ 			"unexpected inconsistency: %d %d\n", b->sa_family, l);
+ 		exit(1);
+ 	}
+ 
+ 	memcpy(a, b, sysdep_sa_len(b));
+ 	p[l / 8] &= (0xff00 >> (l % 8)) & 0xff;
+ 	for (i = l / 8 + 1; i < alen; i++)
+ 		p[i] = 0x00;
+ }
diff -Nr -c25 ac_am/src/racoon/strnames.c ac_am_fixed/src/racoon/strnames.c
*** ac_am/src/racoon/strnames.c	2003-02-28 05:06:40.000000000 +0100
--- ac_am_fixed/src/racoon/strnames.c	2003-12-11 18:19:59.250040744 +0100
***************
*** 395,445 ****
  	int k;
  {
  	int i;
  	for (i = 0; i < ARRAYLEN(name_ipsecdoi_trns_ipcomp); i++)
  		if (name_ipsecdoi_trns_ipcomp[i].key == k)
  			return name_ipsecdoi_trns_ipcomp[i].str;
  	return num2str(k);
  }
  
  char *
  s_ipsecdoi_trns(proto, trns)
  	int proto, trns;
  {
  	int i;
  	for (i = 0; i < ARRAYLEN(name_ipsecdoi_proto); i++)
  		if (name_ipsecdoi_proto[i].key == proto
  		 && name_ipsecdoi_proto[i].f)
  			return (name_ipsecdoi_proto[i].f)(trns);
  	return num2str(trns);
  }
  
  static struct ksmap name_attr_ipsec[] = {
  { IPSECDOI_ATTR_SA_LD_TYPE,	"SA Life Type",		s_ipsecdoi_ltype },
  { IPSECDOI_ATTR_SA_LD,		"SA Life Duration",	NULL },
  { IPSECDOI_ATTR_GRP_DESC,	"Group Description",	NULL },
! { IPSECDOI_ATTR_ENC_MODE,	"Encription Mode",	s_ipsecdoi_encmode },
  { IPSECDOI_ATTR_AUTH,		"Authentication Algorithm", s_ipsecdoi_auth },
  { IPSECDOI_ATTR_KEY_LENGTH,	"Key Length",		NULL },
  { IPSECDOI_ATTR_KEY_ROUNDS,	"Key Rounds",		NULL },
  { IPSECDOI_ATTR_COMP_DICT_SIZE,	"Compression Dictionary Size",	NULL },
  { IPSECDOI_ATTR_COMP_PRIVALG,	"Compression Private Algorithm", NULL },
  };
  
  char *
  s_ipsecdoi_attr(k)
  	int k;
  {
  	int i;
  	for (i = 0; i < ARRAYLEN(name_attr_ipsec); i++)
  		if (name_attr_ipsec[i].key == k)
  			return name_attr_ipsec[i].str;
  	return num2str(k);
  }
  
  static struct ksmap name_attr_ipsec_ltype[] = {
  { IPSECDOI_ATTR_SA_LD_TYPE_SEC,	"seconds",	NULL },
  { IPSECDOI_ATTR_SA_LD_TYPE_KB,	"kilobytes",	NULL },
  };
  
  char *
  s_ipsecdoi_ltype(k)
--- 395,445 ----
  	int k;
  {
  	int i;
  	for (i = 0; i < ARRAYLEN(name_ipsecdoi_trns_ipcomp); i++)
  		if (name_ipsecdoi_trns_ipcomp[i].key == k)
  			return name_ipsecdoi_trns_ipcomp[i].str;
  	return num2str(k);
  }
  
  char *
  s_ipsecdoi_trns(proto, trns)
  	int proto, trns;
  {
  	int i;
  	for (i = 0; i < ARRAYLEN(name_ipsecdoi_proto); i++)
  		if (name_ipsecdoi_proto[i].key == proto
  		 && name_ipsecdoi_proto[i].f)
  			return (name_ipsecdoi_proto[i].f)(trns);
  	return num2str(trns);
  }
  
  static struct ksmap name_attr_ipsec[] = {
  { IPSECDOI_ATTR_SA_LD_TYPE,	"SA Life Type",		s_ipsecdoi_ltype },
  { IPSECDOI_ATTR_SA_LD,		"SA Life Duration",	NULL },
  { IPSECDOI_ATTR_GRP_DESC,	"Group Description",	NULL },
! { IPSECDOI_ATTR_ENC_MODE,	"Encryption Mode",	s_ipsecdoi_encmode },
  { IPSECDOI_ATTR_AUTH,		"Authentication Algorithm", s_ipsecdoi_auth },
  { IPSECDOI_ATTR_KEY_LENGTH,	"Key Length",		NULL },
  { IPSECDOI_ATTR_KEY_ROUNDS,	"Key Rounds",		NULL },
  { IPSECDOI_ATTR_COMP_DICT_SIZE,	"Compression Dictionary Size",	NULL },
  { IPSECDOI_ATTR_COMP_PRIVALG,	"Compression Private Algorithm", NULL },
  };
  
  char *
  s_ipsecdoi_attr(k)
  	int k;
  {
  	int i;
  	for (i = 0; i < ARRAYLEN(name_attr_ipsec); i++)
  		if (name_attr_ipsec[i].key == k)
  			return name_attr_ipsec[i].str;
  	return num2str(k);
  }
  
  static struct ksmap name_attr_ipsec_ltype[] = {
  { IPSECDOI_ATTR_SA_LD_TYPE_SEC,	"seconds",	NULL },
  { IPSECDOI_ATTR_SA_LD_TYPE_KB,	"kilobytes",	NULL },
  };
  
  char *
  s_ipsecdoi_ltype(k)
diff -Nr -c25 ac_am/src/setkey/parse.y ac_am_fixed/src/setkey/parse.y
*** ac_am/src/setkey/parse.y	2003-03-04 00:56:57.000000000 +0100
--- ac_am_fixed/src/setkey/parse.y	2003-12-11 18:19:59.257039680 +0100
***************
*** 74,133 ****
  static int setkeymsg_addr __P((unsigned int, unsigned int,
  	struct addrinfo *, struct addrinfo *, int));
  static int setkeymsg_add __P((unsigned int, unsigned int,
  	struct addrinfo *, struct addrinfo *));
  extern int setkeymsg __P((char *, size_t *));
  extern int sendkeymsg __P((char *, size_t));
  
  extern int yylex __P((void));
  extern void yyfatal __P((const char *));
  extern void yyerror __P((const char *));
  %}
  
  %union {
  	int num;
  	unsigned long ulnum;
  	vchar_t val;
  	struct addrinfo *res;
  }
  
  %token EOT SLASH BLCL ELCL
  %token ADD GET DELETE DELETEALL FLUSH DUMP
  %token PR_ESP PR_AH PR_IPCOMP
  %token F_PROTOCOL F_AUTH F_ENC F_REPLAY F_COMP F_RAWCPI
  %token F_MODE MODE F_REQID
  %token F_EXT EXTENSION NOCYCLICSEQ
! %token ALG_AUTH ALG_ENC ALG_ENC_DESDERIV ALG_ENC_DES32IV ALG_COMP
  %token F_LIFETIME_HARD F_LIFETIME_SOFT
  %token DECSTRING QUOTEDSTRING HEXSTRING STRING ANY
  	/* SPD management */
  %token SPDADD SPDDELETE SPDDUMP SPDFLUSH
  %token F_POLICY PL_REQUESTS
  %token F_AIFLAGS
  
  %type <num> prefix protocol_spec upper_spec
! %type <num> ALG_AUTH ALG_ENC ALG_ENC_DESDERIV ALG_ENC_DES32IV ALG_COMP
  %type <num> PR_ESP PR_AH PR_IPCOMP
  %type <num> EXTENSION MODE
  %type <ulnum> DECSTRING
  %type <val> PL_REQUESTS portstr key_string
  %type <val> policy_requests
  %type <val> QUOTEDSTRING HEXSTRING STRING
  %type <val> F_AIFLAGS
  %type <val> upper_misc_spec policy_spec
  %type <res> ipaddr
  
  %%
  commands
  	:	/*NOTHING*/
  	|	commands command
  		{
  			free_buffer();
  			parse_init();
  		}
  	;
  
  command
  	:	add_command
  	|	get_command
  	|	delete_command
  	|	deleteall_command
--- 74,138 ----
  static int setkeymsg_addr __P((unsigned int, unsigned int,
  	struct addrinfo *, struct addrinfo *, int));
  static int setkeymsg_add __P((unsigned int, unsigned int,
  	struct addrinfo *, struct addrinfo *));
  extern int setkeymsg __P((char *, size_t *));
  extern int sendkeymsg __P((char *, size_t));
  
  extern int yylex __P((void));
  extern void yyfatal __P((const char *));
  extern void yyerror __P((const char *));
  %}
  
  %union {
  	int num;
  	unsigned long ulnum;
  	vchar_t val;
  	struct addrinfo *res;
  }
  
  %token EOT SLASH BLCL ELCL
  %token ADD GET DELETE DELETEALL FLUSH DUMP
  %token PR_ESP PR_AH PR_IPCOMP
  %token F_PROTOCOL F_AUTH F_ENC F_REPLAY F_COMP F_RAWCPI
  %token F_MODE MODE F_REQID
  %token F_EXT EXTENSION NOCYCLICSEQ
! %token ALG_AUTH ALG_AUTH_NOKEY
! %token ALG_ENC ALG_ENC_NOKEY ALG_ENC_DESDERIV ALG_ENC_DES32IV ALG_ENC_OLD
! %token ALG_COMP
  %token F_LIFETIME_HARD F_LIFETIME_SOFT
  %token DECSTRING QUOTEDSTRING HEXSTRING STRING ANY
  	/* SPD management */
  %token SPDADD SPDDELETE SPDDUMP SPDFLUSH
  %token F_POLICY PL_REQUESTS
  %token F_AIFLAGS
+ %token TAGGED
  
  %type <num> prefix protocol_spec upper_spec
! %type <num> ALG_ENC ALG_ENC_DESDERIV ALG_ENC_DES32IV ALG_ENC_OLD ALG_ENC_NOKEY
! %type <num> ALG_AUTH ALG_AUTH_NOKEY
! %type <num> ALG_COMP
  %type <num> PR_ESP PR_AH PR_IPCOMP
  %type <num> EXTENSION MODE
  %type <ulnum> DECSTRING
  %type <val> PL_REQUESTS portstr key_string
  %type <val> policy_requests
  %type <val> QUOTEDSTRING HEXSTRING STRING
  %type <val> F_AIFLAGS
  %type <val> upper_misc_spec policy_spec
  %type <res> ipaddr
  
  %%
  commands
  	:	/*NOTHING*/
  	|	commands command
  		{
  			free_buffer();
  			parse_init();
  		}
  	;
  
  command
  	:	add_command
  	|	get_command
  	|	delete_command
  	|	deleteall_command
***************
*** 141,218 ****
  	/* commands concerned with management, there is in tail of this file. */
  
  	/* add command */
  add_command
  	:	ADD ipaddropts ipaddr ipaddr protocol_spec spi extension_spec algorithm_spec EOT
  		{
  			int status;
  
  			status = setkeymsg_add(SADB_ADD, $5, $3, $4);
  			if (status < 0)
  				return -1;
  		}
  	;
  
  	/* delete */
  delete_command
  	:	DELETE ipaddropts ipaddr ipaddr protocol_spec spi extension_spec EOT
  		{
  			int status;
  
  			if ($3->ai_next || $4->ai_next) {
  				yyerror("multiple address specified");
  				return -1;
  			}
  			if (p_mode != IPSEC_MODE_ANY)
! 				yyerror("WARNING: mode is obsoleted.");
  
  			status = setkeymsg_addr(SADB_DELETE, $5, $3, $4, 0);
  			if (status < 0)
  				return -1;
  		}
  	;
  
  	/* deleteall command */
  deleteall_command
  	:	DELETEALL ipaddropts ipaddr ipaddr protocol_spec EOT
  		{
  			int status;
  
  			status = setkeymsg_addr(SADB_DELETE, $5, $3, $4, 1);
  			if (status < 0)
  				return -1;
  		}
  	;
  
  	/* get command */
  get_command
  	:	GET ipaddropts ipaddr ipaddr protocol_spec spi extension_spec EOT
  		{
  			int status;
  
  			if (p_mode != IPSEC_MODE_ANY)
! 				yyerror("WARNING: mode is obsoleted.");
  
  			status = setkeymsg_addr(SADB_GET, $5, $3, $4, 0);
  			if (status < 0)
  				return -1;
  		}
  	;
  
  	/* flush */
  flush_command
  	:	FLUSH protocol_spec EOT
  		{
  			struct sadb_msg msg;
  			setkeymsg0(&msg, SADB_FLUSH, $2, sizeof(msg));
  			sendkeymsg((char *)&msg, sizeof(msg));
  		}
  	;
  
  	/* dump */
  dump_command
  	:	DUMP protocol_spec EOT
  		{
  			struct sadb_msg msg;
  			setkeymsg0(&msg, SADB_DUMP, $2, sizeof(msg));
  			sendkeymsg((char *)&msg, sizeof(msg));
  		}
--- 146,223 ----
  	/* commands concerned with management, there is in tail of this file. */
  
  	/* add command */
  add_command
  	:	ADD ipaddropts ipaddr ipaddr protocol_spec spi extension_spec algorithm_spec EOT
  		{
  			int status;
  
  			status = setkeymsg_add(SADB_ADD, $5, $3, $4);
  			if (status < 0)
  				return -1;
  		}
  	;
  
  	/* delete */
  delete_command
  	:	DELETE ipaddropts ipaddr ipaddr protocol_spec spi extension_spec EOT
  		{
  			int status;
  
  			if ($3->ai_next || $4->ai_next) {
  				yyerror("multiple address specified");
  				return -1;
  			}
  			if (p_mode != IPSEC_MODE_ANY)
! 				yyerror("WARNING: mode is obsolete");
  
  			status = setkeymsg_addr(SADB_DELETE, $5, $3, $4, 0);
  			if (status < 0)
  				return -1;
  		}
  	;
  
  	/* deleteall command */
  deleteall_command
  	:	DELETEALL ipaddropts ipaddr ipaddr protocol_spec EOT
  		{
  			int status;
  
  			status = setkeymsg_addr(SADB_DELETE, $5, $3, $4, 1);
  			if (status < 0)
  				return -1;
  		}
  	;
  
  	/* get command */
  get_command
  	:	GET ipaddropts ipaddr ipaddr protocol_spec spi extension_spec EOT
  		{
  			int status;
  
  			if (p_mode != IPSEC_MODE_ANY)
! 				yyerror("WARNING: mode is obsolete");
  
  			status = setkeymsg_addr(SADB_GET, $5, $3, $4, 0);
  			if (status < 0)
  				return -1;
  		}
  	;
  
  	/* flush */
  flush_command
  	:	FLUSH protocol_spec EOT
  		{
  			struct sadb_msg msg;
  			setkeymsg0(&msg, SADB_FLUSH, $2, sizeof(msg));
  			sendkeymsg((char *)&msg, sizeof(msg));
  		}
  	;
  
  	/* dump */
  dump_command
  	:	DUMP protocol_spec EOT
  		{
  			struct sadb_msg msg;
  			setkeymsg0(&msg, SADB_DUMP, $2, sizeof(msg));
  			sendkeymsg((char *)&msg, sizeof(msg));
  		}
***************
*** 252,416 ****
  			char *ep;
  			unsigned long v;
  
  			ep = NULL;
  			v = strtoul($1.buf, &ep, 16);
  			if (!ep || *ep) {
  				yyerror("invalid SPI");
  				return -1;
  			}
  			if (v & ~0xffffffff) {
  				yyerror("SPI too big.");
  				return -1;
  			}
  
  			p_spi = v;
  		}
  	;
  
  algorithm_spec
  	:	esp_spec
  	|	ah_spec
  	|	ipcomp_spec
  	;
  
  esp_spec
! 	:	F_ENC enc_alg enc_key F_AUTH auth_alg auth_key
! 	|	F_ENC enc_alg enc_key
  	;
  
  ah_spec
! 	:	F_AUTH auth_alg auth_key
  	;
  
  ipcomp_spec
  	:	F_COMP ALG_COMP
  		{
  			if ($2 < 0) {
  				yyerror("unsupported algorithm");
  				return -1;
  			}
  			p_alg_enc = $2;
  		}
  	|	F_COMP ALG_COMP F_RAWCPI
  		{
  			if ($2 < 0) {
  				yyerror("unsupported algorithm");
  				return -1;
  			}
  			p_alg_enc = $2;
  			p_ext |= SADB_X_EXT_RAWCPI;
  		}
  	;
  
  enc_alg
! 	:	ALG_ENC {
  			if ($1 < 0) {
  				yyerror("unsupported algorithm");
  				return -1;
  			}
  			p_alg_enc = $1;
  		}
! 	|	ALG_ENC_DESDERIV
! 		{
  			if ($1 < 0) {
  				yyerror("unsupported algorithm");
  				return -1;
  			}
  			p_alg_enc = $1;
! 			if (p_ext & SADB_X_EXT_OLD) {
! 				yyerror("algorithm mismatched.");
  				return -1;
  			}
- 			p_ext |= SADB_X_EXT_DERIV;
  		}
! 	|	ALG_ENC_DES32IV
  		{
  			if ($1 < 0) {
  				yyerror("unsupported algorithm");
  				return -1;
  			}
  			p_alg_enc = $1;
! 			if (!(p_ext & SADB_X_EXT_OLD)) {
! 				yyerror("algorithm mismatched.");
  				return -1;
  			}
! 			p_ext |= SADB_X_EXT_IV4B;
! 		}
! 	;
  
! enc_key
! 	:	/*NOTHING*/
! 		{
! 			if (p_alg_enc != SADB_EALG_NULL) {
! 				yyerror("no key found.");
  				return -1;
  			}
  		}
! 	|	key_string
  		{
! 			p_key_enc_len = $1.len;
! 			p_key_enc = $1.buf;
  
  			if (ipsec_check_keylen(SADB_EXT_SUPPORTED_ENCRYPT,
! 					p_alg_enc,
! 					PFKEY_UNUNIT64(p_key_enc_len)) < 0) {
  				yyerror(ipsec_strerror());
  				return -1;
  			}
  		}
  	;
  
  auth_alg
! 	:	ALG_AUTH {
  			if ($1 < 0) {
  				yyerror("unsupported algorithm");
  				return -1;
  			}
  			p_alg_auth = $1;
- 		}
- 	;
  
! auth_key
! 	:	/*NOTHING*/
! 		{
! 			if (p_alg_auth != SADB_X_AALG_NULL) {
! 				yyerror("no key found.");
  				return -1;
  			}
  		}
! 	|	key_string
! 		{
! 			p_key_auth_len = $1.len;
! 			p_key_auth = $1.buf;
! 
! 			if (ipsec_check_keylen(SADB_EXT_SUPPORTED_AUTH,
! 					p_alg_auth,
! 					PFKEY_UNUNIT64(p_key_auth_len)) < 0) {
! 				yyerror(ipsec_strerror());
  				return -1;
  			}
  		}
  	;
  
  key_string
  	:	QUOTEDSTRING
  		{
  			$$ = $1;
  		}
  	|	HEXSTRING
  		{
  			caddr_t pp_key;
  			caddr_t bp;
  			caddr_t yp = $1.buf;
  			int l;
  
  			l = strlen(yp) % 2 + strlen(yp) / 2;
  			if ((pp_key = malloc(l)) == 0) {
  				yyerror("not enough core");
  				return -1;
  			}
  			memset(pp_key, 0, l);
  
  			bp = pp_key;
  			if (strlen(yp) % 2) {
  				*bp = ATOX(yp[0]);
--- 257,440 ----
  			char *ep;
  			unsigned long v;
  
  			ep = NULL;
  			v = strtoul($1.buf, &ep, 16);
  			if (!ep || *ep) {
  				yyerror("invalid SPI");
  				return -1;
  			}
  			if (v & ~0xffffffff) {
  				yyerror("SPI too big.");
  				return -1;
  			}
  
  			p_spi = v;
  		}
  	;
  
  algorithm_spec
  	:	esp_spec
  	|	ah_spec
  	|	ipcomp_spec
  	;
  
  esp_spec
! 	:	F_ENC enc_alg F_AUTH auth_alg
! 	|	F_ENC enc_alg
  	;
  
  ah_spec
! 	:	F_AUTH auth_alg
  	;
  
  ipcomp_spec
  	:	F_COMP ALG_COMP
  		{
  			if ($2 < 0) {
  				yyerror("unsupported algorithm");
  				return -1;
  			}
  			p_alg_enc = $2;
  		}
  	|	F_COMP ALG_COMP F_RAWCPI
  		{
  			if ($2 < 0) {
  				yyerror("unsupported algorithm");
  				return -1;
  			}
  			p_alg_enc = $2;
  			p_ext |= SADB_X_EXT_RAWCPI;
  		}
  	;
  
  enc_alg
! 	:	ALG_ENC_NOKEY {
  			if ($1 < 0) {
  				yyerror("unsupported algorithm");
  				return -1;
  			}
  			p_alg_enc = $1;
+ 
+ 			p_key_enc_len = 0;
+ 			p_key_enc = NULL;
  		}
! 	|	ALG_ENC key_string {
  			if ($1 < 0) {
  				yyerror("unsupported algorithm");
  				return -1;
  			}
  			p_alg_enc = $1;
! 
! 			p_key_enc_len = $2.len;
! 			p_key_enc = $2.buf;
! 			if (ipsec_check_keylen(SADB_EXT_SUPPORTED_ENCRYPT,
! 			    p_alg_enc, PFKEY_UNUNIT64(p_key_enc_len)) < 0) {
! 				yyerror(ipsec_strerror());
  				return -1;
  			}
  		}
! 	|	ALG_ENC_OLD {
! 			if ($1 < 0) {
! 				yyerror("unsupported algorithm");
! 				return -1;
! 			}
! 			yyerror("WARNING: obsolete algorithm");
! 			p_alg_enc = $1;
! 
! 			p_key_enc_len = 0;
! 			p_key_enc = NULL;
! 		}
! 	|	ALG_ENC_DESDERIV key_string
  		{
  			if ($1 < 0) {
  				yyerror("unsupported algorithm");
  				return -1;
  			}
  			p_alg_enc = $1;
! 			if (p_ext & SADB_X_EXT_OLD) {
! 				yyerror("algorithm mismatched");
  				return -1;
  			}
! 			p_ext |= SADB_X_EXT_DERIV;
  
! 			p_key_enc_len = $2.len;
! 			p_key_enc = $2.buf;
! 			if (ipsec_check_keylen(SADB_EXT_SUPPORTED_ENCRYPT,
! 			    p_alg_enc, PFKEY_UNUNIT64(p_key_enc_len)) < 0) {
! 				yyerror(ipsec_strerror());
  				return -1;
  			}
  		}
! 	|	ALG_ENC_DES32IV key_string
  		{
! 			if ($1 < 0) {
! 				yyerror("unsupported algorithm");
! 				return -1;
! 			}
! 			p_alg_enc = $1;
! 			if (!(p_ext & SADB_X_EXT_OLD)) {
! 				yyerror("algorithm mismatched");
! 				return -1;
! 			}
! 			p_ext |= SADB_X_EXT_IV4B;
  
+ 			p_key_enc_len = $2.len;
+ 			p_key_enc = $2.buf;
  			if (ipsec_check_keylen(SADB_EXT_SUPPORTED_ENCRYPT,
! 			    p_alg_enc, PFKEY_UNUNIT64(p_key_enc_len)) < 0) {
  				yyerror(ipsec_strerror());
  				return -1;
  			}
  		}
  	;
  
  auth_alg
! 	:	ALG_AUTH key_string {
  			if ($1 < 0) {
  				yyerror("unsupported algorithm");
  				return -1;
  			}
  			p_alg_auth = $1;
  
! 			p_key_auth_len = $2.len;
! 			p_key_auth = $2.buf;
! 			if (ipsec_check_keylen(SADB_EXT_SUPPORTED_AUTH,
! 			    p_alg_auth, PFKEY_UNUNIT64(p_key_auth_len)) < 0) {
! 				yyerror(ipsec_strerror());
  				return -1;
  			}
  		}
! 	|	ALG_AUTH_NOKEY {
! 			if ($1 < 0) {
! 				yyerror("unsupported algorithm");
  				return -1;
  			}
+ 			p_alg_auth = $1;
+ 
+ 			p_key_auth_len = 0;
+ 			p_key_auth = NULL;
  		}
  	;
  
  key_string
  	:	QUOTEDSTRING
  		{
  			$$ = $1;
  		}
  	|	HEXSTRING
  		{
  			caddr_t pp_key;
  			caddr_t bp;
  			caddr_t yp = $1.buf;
  			int l;
  
  			l = strlen(yp) % 2 + strlen(yp) / 2;
  			if ((pp_key = malloc(l)) == 0) {
  				yyerror("not enough core");
  				return -1;
  			}
  			memset(pp_key, 0, l);
  
  			bp = pp_key;
  			if (strlen(yp) % 2) {
  				*bp = ATOX(yp[0]);
***************
*** 419,515 ****
  			while (*yp) {
  				*bp = (ATOX(yp[0]) << 4) | ATOX(yp[1]);
  				yp += 2, bp++;
  			}
  
  			$$.len = l;
  			$$.buf = pp_key;
  		}
  	;
  
  extension_spec
  	:	/*NOTHING*/
  	|	extension_spec extension
  	;
  
  extension
  	:	F_EXT EXTENSION { p_ext |= $2; }
  	|	F_EXT NOCYCLICSEQ { p_ext &= ~SADB_X_EXT_CYCSEQ; }
  	|	F_MODE MODE { p_mode = $2; }
  	|	F_MODE ANY { p_mode = IPSEC_MODE_ANY; }
  	|	F_REQID DECSTRING { p_reqid = $2; }
  	|	F_REPLAY DECSTRING
  		{
  			if ((p_ext & SADB_X_EXT_OLD) != 0) {
  				yyerror("replay prevention cannot be used with "
! 				    "ah/esp-old.");
  				return -1;
  			}
  			p_replay = $2;
  		}
  	|	F_LIFETIME_HARD DECSTRING { p_lt_hard = $2; }
  	|	F_LIFETIME_SOFT DECSTRING { p_lt_soft = $2; }
  	;
  
  	/* definition about command for SPD management */
  	/* spdadd */
  spdadd_command
  	:	SPDADD ipaddropts STRING prefix portstr STRING prefix portstr upper_spec upper_misc_spec policy_spec EOT
  		{
  			int status;
  			struct addrinfo *src, *dst;
  
  			/* fixed port fields if ulp is icmpv6 */
  			if ($10.buf != NULL) {
  				if ($9 != IPPROTO_ICMPV6)
  					return -1;
  				free($5.buf);
  				free($8.buf);
  				if (fix_portstr(&$10, &$5, &$8))
  					return -1;
  			}
  
  			src = parse_addr($3.buf, $5.buf);
  			dst = parse_addr($6.buf, $8.buf);
  			if (!src || !dst) {
  				/* yyerror is already called */
  				return -1;
  			}
  			if (src->ai_next || dst->ai_next) {
  				yyerror("multiple address specified");
  				freeaddrinfo(src);
  				freeaddrinfo(dst);
  				return -1;
  			}
  
  			status = setkeymsg_spdaddr(SADB_X_SPDADD, $9, &$11,
  			    src, $4, dst, $7);
  			freeaddrinfo(src);
  			freeaddrinfo(dst);
  			if (status < 0)
  				return -1;
  		}
  	;
  
  spddelete_command
  	:	SPDDELETE ipaddropts STRING prefix portstr STRING prefix portstr upper_spec upper_misc_spec policy_spec EOT
  		{
  			int status;
  			struct addrinfo *src, *dst;
  
  			/* fixed port fields if ulp is icmpv6 */
  			if ($10.buf != NULL) {
  				if ($9 != IPPROTO_ICMPV6)
  					return -1;
  				free($5.buf);
  				free($8.buf);
  				if (fix_portstr(&$10, &$5, &$8))
  					return -1;
  			}
  
  			src = parse_addr($3.buf, $5.buf);
  			dst = parse_addr($6.buf, $8.buf);
  			if (!src || !dst) {
  				/* yyerror is already called */
  				return -1;
  			}
  			if (src->ai_next || dst->ai_next) {
--- 443,552 ----
  			while (*yp) {
  				*bp = (ATOX(yp[0]) << 4) | ATOX(yp[1]);
  				yp += 2, bp++;
  			}
  
  			$$.len = l;
  			$$.buf = pp_key;
  		}
  	;
  
  extension_spec
  	:	/*NOTHING*/
  	|	extension_spec extension
  	;
  
  extension
  	:	F_EXT EXTENSION { p_ext |= $2; }
  	|	F_EXT NOCYCLICSEQ { p_ext &= ~SADB_X_EXT_CYCSEQ; }
  	|	F_MODE MODE { p_mode = $2; }
  	|	F_MODE ANY { p_mode = IPSEC_MODE_ANY; }
  	|	F_REQID DECSTRING { p_reqid = $2; }
  	|	F_REPLAY DECSTRING
  		{
  			if ((p_ext & SADB_X_EXT_OLD) != 0) {
  				yyerror("replay prevention cannot be used with "
! 				    "ah/esp-old");
  				return -1;
  			}
  			p_replay = $2;
  		}
  	|	F_LIFETIME_HARD DECSTRING { p_lt_hard = $2; }
  	|	F_LIFETIME_SOFT DECSTRING { p_lt_soft = $2; }
  	;
  
  	/* definition about command for SPD management */
  	/* spdadd */
  spdadd_command
  	:	SPDADD ipaddropts STRING prefix portstr STRING prefix portstr upper_spec upper_misc_spec policy_spec EOT
  		{
  			int status;
  			struct addrinfo *src, *dst;
  
  			/* fixed port fields if ulp is icmpv6 */
  			if ($10.buf != NULL) {
  				if ($9 != IPPROTO_ICMPV6)
  					return -1;
  				free($5.buf);
  				free($8.buf);
  				if (fix_portstr(&$10, &$5, &$8))
  					return -1;
  			}
  
  			src = parse_addr($3.buf, $5.buf);
  			dst = parse_addr($6.buf, $8.buf);
  			if (!src || !dst) {
  				/* yyerror is already called */
  				return -1;
  			}
  			if (src->ai_next || dst->ai_next) {
  				yyerror("multiple address specified");
  				freeaddrinfo(src);
  				freeaddrinfo(dst);
  				return -1;
  			}
  
  			status = setkeymsg_spdaddr(SADB_X_SPDADD, $9, &$11,
  			    src, $4, dst, $7);
  			freeaddrinfo(src);
  			freeaddrinfo(dst);
  			if (status < 0)
  				return -1;
  		}
+ 	|	SPDADD TAGGED QUOTEDSTRING policy_spec EOT
+ 		{
+ #ifdef SADB_X_EXT_TAG
+ 			int status;
+ 
+ 			status = setkeymsg_spdaddr_tag(SADB_X_SPDADD,
+ 			    $3.buf, &$4);
+ 			if (status < 0)
+ 				return -1;
+ #else
+ 			yywarn("\"tagged\" was not supported during compilation.");
+ #endif
+ 		}
  	;
  
  spddelete_command
  	:	SPDDELETE ipaddropts STRING prefix portstr STRING prefix portstr upper_spec upper_misc_spec policy_spec EOT
  		{
  			int status;
  			struct addrinfo *src, *dst;
  
  			/* fixed port fields if ulp is icmpv6 */
  			if ($10.buf != NULL) {
  				if ($9 != IPPROTO_ICMPV6)
  					return -1;
  				free($5.buf);
  				free($8.buf);
  				if (fix_portstr(&$10, &$5, &$8))
  					return -1;
  			}
  
  			src = parse_addr($3.buf, $5.buf);
  			dst = parse_addr($6.buf, $8.buf);
  			if (!src || !dst) {
  				/* yyerror is already called */
  				return -1;
  			}
  			if (src->ai_next || dst->ai_next) {
***************
*** 576,678 ****
--- 613,731 ----
  					return -1;
  				}
  		}
  	;
  
  ipaddr
  	:	STRING
  		{
  			$$ = parse_addr($1.buf, NULL);
  			if ($$ == NULL) {
  				/* yyerror already called by parse_addr */
  				return -1;
  			}
  		}
  	;
  
  prefix
  	:	/*NOTHING*/ { $$ = -1; }
  	|	SLASH DECSTRING { $$ = $2; }
  	;
  
  portstr
  	:	/*NOTHING*/
  		{
  			$$.buf = strdup("0");
+ 			if (!$$.buf) {
+ 				yyerror("insufficient memory");
+ 				return -1;
+ 			}
  			$$.len = strlen($$.buf);
  		}
  	|	BLCL ANY ELCL
  		{
  			$$.buf = strdup("0");
+ 			if (!$$.buf) {
+ 				yyerror("insufficient memory");
+ 				return -1;
+ 			}
  			$$.len = strlen($$.buf);
  		}
  	|	BLCL DECSTRING ELCL
  		{
  			char buf[20];
  			snprintf(buf, sizeof(buf), "%lu", $2);
  			$$.buf = strdup(buf);
+ 			if (!$$.buf) {
+ 				yyerror("insufficient memory");
+ 				return -1;
+ 			}
  			$$.len = strlen($$.buf);
  		}
  	|	BLCL STRING ELCL
  		{
  			$$ = $2;
  		}
  	;
  
  upper_spec
  	:	DECSTRING { $$ = $1; }
  	|	ANY { $$ = IPSEC_ULPROTO_ANY; }
  	|	STRING
  		{
  			struct protoent *ent;
  
  			ent = getprotobyname($1.buf);
  			if (ent)
  				$$ = ent->p_proto;
  			else {
  				if (strcmp("icmp6", $1.buf) == 0) {
  					$$ = IPPROTO_ICMPV6;
  				} else if(strcmp("ip4", $1.buf) == 0) {
  					$$ = IPPROTO_IPV4;
  				} else {
  					yyerror("invalid upper layer protocol");
  					return -1;
  				}
  			}
  			endprotoent();
  		}
  	;
  
  upper_misc_spec
  	:	/*NOTHING*/
  		{
  			$$.buf = NULL;
  			$$.len = 0;
  		}
  	|	STRING
  		{
  			$$.buf = strdup($1.buf);
+ 			if (!$$.buf) {
+ 				yyerror("insufficient memory");
+ 				return -1;
+ 			}
  			$$.len = strlen($$.buf);
  		}
  	;
  
  policy_spec
  	:	F_POLICY policy_requests
  		{
  			char *policy;
  
  			policy = ipsec_set_policy($2.buf, $2.len);
  			if (policy == NULL) {
  				yyerror(ipsec_strerror());
  				return -1;
  			}
  
  			$$.buf = policy;
  			$$.len = ipsec_get_policylen(policy);
  		}
  	;
  
  policy_requests
  	:	PL_REQUESTS { $$ = $1; }
  	;
  
  %%
***************
*** 773,822 ****
--- 826,917 ----
  			m_addr.sadb_address_len = PFKEY_UNIT64(sizeof(m_addr) +
  			    PFKEY_ALIGN8(salen));
  			m_addr.sadb_address_exttype = SADB_EXT_ADDRESS_DST;
  			m_addr.sadb_address_proto = upper;
  			m_addr.sadb_address_prefixlen =
  			    (dplen >= 0 ? dplen : plen);
  			m_addr.sadb_address_reserved = 0;
  
  			setvarbuf(buf, &l, (struct sadb_ext *)&m_addr,
  			    sizeof(m_addr), (caddr_t)sa, salen);
  
  			msg->sadb_msg_len = PFKEY_UNIT64(l);
  
  			sendkeymsg(buf, l);
  
  			n++;
  		}
  	}
  
  	if (n == 0)
  		return -1;
  	else
  		return 0;
  }
  
+ #ifdef SADB_X_EXT_TAG
+ static int
+ setkeymsg_spdaddr_tag(type, tag, policy)
+ 	unsigned int type;
+ 	char *tag;
+ 	vchar_t *policy;
+ {
+ 	struct sadb_msg *msg;
+ 	char buf[BUFSIZ];
+ 	int l, l0;
+ 	struct sadb_x_tag m_tag;
+ 	int n;
+ 
+ 	msg = (struct sadb_msg *)buf;
+ 
+ 	/* fix up length afterwards */
+ 	setkeymsg0(msg, type, SADB_SATYPE_UNSPEC, 0);
+ 	l = sizeof(struct sadb_msg);
+ 
+ 	memcpy(buf + l, policy->buf, policy->len);
+ 	l += policy->len;
+ 
+ 	l0 = l;
+ 	n = 0;
+ 
+ 	memset(&m_tag, 0, sizeof(m_tag));
+ 	m_tag.sadb_x_tag_len = PFKEY_UNIT64(sizeof(m_tag));
+ 	m_tag.sadb_x_tag_exttype = SADB_X_EXT_TAG;
+ 	if (strlcpy(m_tag.sadb_x_tag_name, tag,
+ 	    sizeof(m_tag.sadb_x_tag_name)) >= sizeof(m_tag.sadb_x_tag_name))
+ 		return -1;
+ 	memcpy(buf + l, &m_tag, sizeof(m_tag));
+ 	l += sizeof(m_tag);
+ 
+ 	msg->sadb_msg_len = PFKEY_UNIT64(l);
+ 
+ 	sendkeymsg(buf, l);
+ 
+ 	return 0;
+ }
+ #endif
+ 
  /* XXX NO BUFFER OVERRUN CHECK! BAD BAD! */
  static int
  setkeymsg_addr(type, satype, srcs, dsts, no_spi)
  	unsigned int type;
  	unsigned int satype;
  	struct addrinfo *srcs;
  	struct addrinfo *dsts;
  	int no_spi;
  {
  	struct sadb_msg *msg;
  	char buf[BUFSIZ];
  	int l, l0, len;
  	struct sadb_sa m_sa;
  	struct sadb_x_sa2 m_sa2;
  	struct sadb_address m_addr;
  	struct addrinfo *s, *d;
  	int n;
  	int plen;
  	struct sockaddr *sa;
  	int salen;
  
  	msg = (struct sadb_msg *)buf;
  
  	if (!srcs || !dsts)
  		return -1;
***************
*** 921,1030 ****
  	struct addrinfo *srcs;
  	struct addrinfo *dsts;
  {
  	struct sadb_msg *msg;
  	char buf[BUFSIZ];
  	int l, l0, len;
  	struct sadb_sa m_sa;
  	struct sadb_x_sa2 m_sa2;
  	struct sadb_address m_addr;
  	struct addrinfo *s, *d;
  	int n;
  	int plen;
  	struct sockaddr *sa;
  	int salen;
  
  	msg = (struct sadb_msg *)buf;
  
  	if (!srcs || !dsts)
  		return -1;
  
  	/* fix up length afterwards */
  	setkeymsg0(msg, type, satype, 0);
  	l = sizeof(struct sadb_msg);
  
  	/* set encryption algorithm, if present. */
! 	if (satype != SADB_X_SATYPE_IPCOMP && p_alg_enc != SADB_EALG_NONE) {
  		struct sadb_key m_key;
  
  		m_key.sadb_key_len =
  			PFKEY_UNIT64(sizeof(m_key)
  				   + PFKEY_ALIGN8(p_key_enc_len));
  		m_key.sadb_key_exttype = SADB_EXT_KEY_ENCRYPT;
  		m_key.sadb_key_bits = p_key_enc_len * 8;
  		m_key.sadb_key_reserved = 0;
  
  		setvarbuf(buf, &l,
  			(struct sadb_ext *)&m_key, sizeof(m_key),
  			(caddr_t)p_key_enc, p_key_enc_len);
  	}
  
  	/* set authentication algorithm, if present. */
! 	if (p_alg_auth != SADB_AALG_NONE) {
  		struct sadb_key m_key;
  
  		m_key.sadb_key_len =
  			PFKEY_UNIT64(sizeof(m_key)
  				   + PFKEY_ALIGN8(p_key_auth_len));
  		m_key.sadb_key_exttype = SADB_EXT_KEY_AUTH;
  		m_key.sadb_key_bits = p_key_auth_len * 8;
  		m_key.sadb_key_reserved = 0;
  
  		setvarbuf(buf, &l,
  			(struct sadb_ext *)&m_key, sizeof(m_key),
  			(caddr_t)p_key_auth, p_key_auth_len);
  	}
  
  	/* set lifetime for HARD */
  	if (p_lt_hard != 0) {
  		struct sadb_lifetime m_lt;
! 		u_int len = sizeof(struct sadb_lifetime);
  
! 		m_lt.sadb_lifetime_len = PFKEY_UNIT64(len);
  		m_lt.sadb_lifetime_exttype = SADB_EXT_LIFETIME_HARD;
  		m_lt.sadb_lifetime_allocations = 0;
  		m_lt.sadb_lifetime_bytes = 0;
  		m_lt.sadb_lifetime_addtime = p_lt_hard;
  		m_lt.sadb_lifetime_usetime = 0;
  
! 		memcpy(buf + l, &m_lt, len);
  		l += len;
  	}
  
  	/* set lifetime for SOFT */
  	if (p_lt_soft != 0) {
  		struct sadb_lifetime m_lt;
! 		u_int len = sizeof(struct sadb_lifetime);
  
! 		m_lt.sadb_lifetime_len = PFKEY_UNIT64(len);
  		m_lt.sadb_lifetime_exttype = SADB_EXT_LIFETIME_SOFT;
  		m_lt.sadb_lifetime_allocations = 0;
  		m_lt.sadb_lifetime_bytes = 0;
  		m_lt.sadb_lifetime_addtime = p_lt_soft;
  		m_lt.sadb_lifetime_usetime = 0;
  
! 		memcpy(buf + l, &m_lt, len);
  		l += len;
  	}
  
  	len = sizeof(struct sadb_sa);
  	m_sa.sadb_sa_len = PFKEY_UNIT64(len);
  	m_sa.sadb_sa_exttype = SADB_EXT_SA;
  	m_sa.sadb_sa_spi = htonl(p_spi);
  	m_sa.sadb_sa_replay = p_replay;
  	m_sa.sadb_sa_state = 0;
  	m_sa.sadb_sa_auth = p_alg_auth;
  	m_sa.sadb_sa_encrypt = p_alg_enc;
  	m_sa.sadb_sa_flags = p_ext;
  
  	memcpy(buf + l, &m_sa, len);
  	l += len;
  
  	len = sizeof(struct sadb_x_sa2);
  	m_sa2.sadb_x_sa2_len = PFKEY_UNIT64(len);
  	m_sa2.sadb_x_sa2_exttype = SADB_X_EXT_SA2;
  	m_sa2.sadb_x_sa2_mode = p_mode;
  	m_sa2.sadb_x_sa2_reqid = p_reqid;
  
  	memcpy(buf + l, &m_sa2, len);
  	l += len;
  
--- 1016,1125 ----
  	struct addrinfo *srcs;
  	struct addrinfo *dsts;
  {
  	struct sadb_msg *msg;
  	char buf[BUFSIZ];
  	int l, l0, len;
  	struct sadb_sa m_sa;
  	struct sadb_x_sa2 m_sa2;
  	struct sadb_address m_addr;
  	struct addrinfo *s, *d;
  	int n;
  	int plen;
  	struct sockaddr *sa;
  	int salen;
  
  	msg = (struct sadb_msg *)buf;
  
  	if (!srcs || !dsts)
  		return -1;
  
  	/* fix up length afterwards */
  	setkeymsg0(msg, type, satype, 0);
  	l = sizeof(struct sadb_msg);
  
  	/* set encryption algorithm, if present. */
! 	if (satype != SADB_X_SATYPE_IPCOMP && p_key_enc) {
  		struct sadb_key m_key;
  
  		m_key.sadb_key_len =
  			PFKEY_UNIT64(sizeof(m_key)
  				   + PFKEY_ALIGN8(p_key_enc_len));
  		m_key.sadb_key_exttype = SADB_EXT_KEY_ENCRYPT;
  		m_key.sadb_key_bits = p_key_enc_len * 8;
  		m_key.sadb_key_reserved = 0;
  
  		setvarbuf(buf, &l,
  			(struct sadb_ext *)&m_key, sizeof(m_key),
  			(caddr_t)p_key_enc, p_key_enc_len);
  	}
  
  	/* set authentication algorithm, if present. */
! 	if (p_key_auth) {
  		struct sadb_key m_key;
  
  		m_key.sadb_key_len =
  			PFKEY_UNIT64(sizeof(m_key)
  				   + PFKEY_ALIGN8(p_key_auth_len));
  		m_key.sadb_key_exttype = SADB_EXT_KEY_AUTH;
  		m_key.sadb_key_bits = p_key_auth_len * 8;
  		m_key.sadb_key_reserved = 0;
  
  		setvarbuf(buf, &l,
  			(struct sadb_ext *)&m_key, sizeof(m_key),
  			(caddr_t)p_key_auth, p_key_auth_len);
  	}
  
  	/* set lifetime for HARD */
  	if (p_lt_hard != 0) {
  		struct sadb_lifetime m_lt;
! 		u_int slen = sizeof(struct sadb_lifetime);
  
! 		m_lt.sadb_lifetime_len = PFKEY_UNIT64(slen);
  		m_lt.sadb_lifetime_exttype = SADB_EXT_LIFETIME_HARD;
  		m_lt.sadb_lifetime_allocations = 0;
  		m_lt.sadb_lifetime_bytes = 0;
  		m_lt.sadb_lifetime_addtime = p_lt_hard;
  		m_lt.sadb_lifetime_usetime = 0;
  
! 		memcpy(buf + l, &m_lt, slen);
  		l += len;
  	}
  
  	/* set lifetime for SOFT */
  	if (p_lt_soft != 0) {
  		struct sadb_lifetime m_lt;
! 		u_int slen = sizeof(struct sadb_lifetime);
  
! 		m_lt.sadb_lifetime_len = PFKEY_UNIT64(slen);
  		m_lt.sadb_lifetime_exttype = SADB_EXT_LIFETIME_SOFT;
  		m_lt.sadb_lifetime_allocations = 0;
  		m_lt.sadb_lifetime_bytes = 0;
  		m_lt.sadb_lifetime_addtime = p_lt_soft;
  		m_lt.sadb_lifetime_usetime = 0;
  
! 		memcpy(buf + l, &m_lt, slen);
  		l += len;
  	}
  
  	len = sizeof(struct sadb_sa);
  	m_sa.sadb_sa_len = PFKEY_UNIT64(len);
  	m_sa.sadb_sa_exttype = SADB_EXT_SA;
  	m_sa.sadb_sa_spi = htonl(p_spi);
  	m_sa.sadb_sa_replay = p_replay;
  	m_sa.sadb_sa_state = 0;
  	m_sa.sadb_sa_auth = p_alg_auth;
  	m_sa.sadb_sa_encrypt = p_alg_enc;
  	m_sa.sadb_sa_flags = p_ext;
  
  	memcpy(buf + l, &m_sa, len);
  	l += len;
  
  	len = sizeof(struct sadb_x_sa2);
  	m_sa2.sadb_x_sa2_len = PFKEY_UNIT64(len);
  	m_sa2.sadb_x_sa2_exttype = SADB_X_EXT_SA2;
  	m_sa2.sadb_x_sa2_mode = p_mode;
  	m_sa2.sadb_x_sa2_reqid = p_reqid;
  
  	memcpy(buf + l, &m_sa2, len);
  	l += len;
  
***************
*** 1080,1167 ****
  
  			msg->sadb_msg_len = PFKEY_UNIT64(l);
  
  			sendkeymsg(buf, l);
  
  			n++;
  		}
  	}
  
  	if (n == 0)
  		return -1;
  	else
  		return 0;
  }
  
  static struct addrinfo *
  parse_addr(host, port)
  	char *host;
  	char *port;
  {
  	struct addrinfo hints, *res = NULL;
  	int error;
  
  	memset(&hints, 0, sizeof(hints));
  	hints.ai_family = p_aifamily;
! 	hints.ai_socktype = SOCK_DGRAM;
  	hints.ai_flags = p_aiflags;
  	error = getaddrinfo(host, port, &hints, &res);
  	if (error != 0) {
  		yyerror(gai_strerror(error));
  		return NULL;
  	}
  	return res;
  }
  
  static int
  fix_portstr(spec, sport, dport)
  	vchar_t *spec, *sport, *dport;
  {
  	char *p, *p2;
  	u_int l;
  
  	l = 0;
  	for (p = spec->buf; *p != ',' && *p != '\0' && l < spec->len; p++, l++)
  		;
  	if (*p == '\0') {
  		p2 = "0";
  	} else {
  		if (*p == ',') {
  			*p = '\0';
  			p2 = ++p;
  		}
  		for (p = p2; *p != '\0' && l < spec->len; p++, l++)
  			;
  		if (*p != '\0' || *p2 == '\0') {
  			yyerror("invalid an upper layer protocol spec");
  			return -1;
  		}
  	}
  
  	sport->buf = strdup(spec->buf);
  	sport->len = strlen(sport->buf);
  	dport->buf = strdup(p2);
  	dport->len = strlen(dport->buf);
  
  	return 0;
  }
  
  static int
  setvarbuf(buf, off, ebuf, elen, vbuf, vlen)
  	char *buf;
  	int *off;
  	struct sadb_ext *ebuf;
  	int elen;
  	caddr_t vbuf;
  	int vlen;
  {
  	memset(buf + *off, 0, PFKEY_UNUNIT64(ebuf->sadb_ext_len));
  	memcpy(buf + *off, (caddr_t)ebuf, elen);
  	memcpy(buf + *off + elen, vbuf, vlen);
  	(*off) += PFKEY_ALIGN8(elen + vlen);
  
  	return 0;
  }
  
  void
  parse_init()
  {
--- 1175,1271 ----
  
  			msg->sadb_msg_len = PFKEY_UNIT64(l);
  
  			sendkeymsg(buf, l);
  
  			n++;
  		}
  	}
  
  	if (n == 0)
  		return -1;
  	else
  		return 0;
  }
  
  static struct addrinfo *
  parse_addr(host, port)
  	char *host;
  	char *port;
  {
  	struct addrinfo hints, *res = NULL;
  	int error;
  
  	memset(&hints, 0, sizeof(hints));
  	hints.ai_family = p_aifamily;
! 	hints.ai_socktype = SOCK_DGRAM;		/*dummy*/
! 	hints.ai_protocol = IPPROTO_UDP;	/*dummy*/
  	hints.ai_flags = p_aiflags;
  	error = getaddrinfo(host, port, &hints, &res);
  	if (error != 0) {
  		yyerror(gai_strerror(error));
  		return NULL;
  	}
  	return res;
  }
  
  static int
  fix_portstr(spec, sport, dport)
  	vchar_t *spec, *sport, *dport;
  {
  	char *p, *p2;
  	u_int l;
  
  	l = 0;
  	for (p = spec->buf; *p != ',' && *p != '\0' && l < spec->len; p++, l++)
  		;
  	if (*p == '\0') {
  		p2 = "0";
  	} else {
  		if (*p == ',') {
  			*p = '\0';
  			p2 = ++p;
  		}
  		for (p = p2; *p != '\0' && l < spec->len; p++, l++)
  			;
  		if (*p != '\0' || *p2 == '\0') {
  			yyerror("invalid an upper layer protocol spec");
  			return -1;
  		}
  	}
  
  	sport->buf = strdup(spec->buf);
+ 	if (!sport->buf) {
+ 		yyerror("insufficient memory");
+ 		return -1;
+ 	}
  	sport->len = strlen(sport->buf);
  	dport->buf = strdup(p2);
+ 	if (!dport->buf) {
+ 		yyerror("insufficient memory");
+ 		return -1;
+ 	}
  	dport->len = strlen(dport->buf);
  
  	return 0;
  }
  
  static int
  setvarbuf(buf, off, ebuf, elen, vbuf, vlen)
  	char *buf;
  	int *off;
  	struct sadb_ext *ebuf;
  	int elen;
  	caddr_t vbuf;
  	int vlen;
  {
  	memset(buf + *off, 0, PFKEY_UNUNIT64(ebuf->sadb_ext_len));
  	memcpy(buf + *off, (caddr_t)ebuf, elen);
  	memcpy(buf + *off + elen, vbuf, vlen);
  	(*off) += PFKEY_ALIGN8(elen + vlen);
  
  	return 0;
  }
  
  void
  parse_init()
  {
diff -Nr -c25 ac_am/src/setkey/parse.y.orig ac_am_fixed/src/setkey/parse.y.orig
*** ac_am/src/setkey/parse.y.orig	1970-01-01 01:00:00.000000000 +0100
--- ac_am_fixed/src/setkey/parse.y.orig	2003-12-11 18:19:59.266038312 +0100
***************
*** 0 ****
--- 1,1192 ----
+ /*	$KAME: parse.y,v 1.71 2002/05/29 10:06:52 sakane Exp $	*/
+ 
+ /*
+  * Copyright (C) 1995, 1996, 1997, 1998, and 1999 WIDE Project.
+  * All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions
+  * are met:
+  * 1. Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  * 2. Redistributions in binary form must reproduce the above copyright
+  *    notice, this list of conditions and the following disclaimer in the
+  *    documentation and/or other materials provided with the distribution.
+  * 3. Neither the name of the project nor the names of its contributors
+  *    may be used to endorse or promote products derived from this software
+  *    without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+  * SUCH DAMAGE.
+  */
+ 
+ %{
+ #include <sys/types.h>
+ #include <sys/param.h>
+ #include <sys/socket.h>
+ 
+ #include <netinet/in.h>
+ #include <net/pfkeyv2.h>
+ #include <netinet/ipsec.h>
+ #include <arpa/inet.h>
+ 
+ #include <string.h>
+ #include <unistd.h>
+ #include <stdio.h>
+ #include <netdb.h>
+ #include <ctype.h>
+ #include <errno.h>
+ #include <stdlib.h>
+ 
+ #include "libpfkey.h"
+ #include "vchar.h"
+ 
+ #define ATOX(c) \
+   (isdigit(c) ? (c - '0') : (isupper(c) ? (c - 'A' + 10) : (c - 'a' + 10)))
+ 
+ u_int32_t p_spi;
+ u_int p_ext, p_alg_enc, p_alg_auth, p_replay, p_mode;
+ u_int32_t p_reqid;
+ u_int p_key_enc_len, p_key_auth_len;
+ caddr_t p_key_enc, p_key_auth;
+ time_t p_lt_hard, p_lt_soft;
+ 
+ static int p_aiflags = 0, p_aifamily = PF_UNSPEC;
+ 
+ static struct addrinfo *parse_addr __P((char *, char *));
+ static int fix_portstr __P((vchar_t *, vchar_t *, vchar_t *));
+ static int setvarbuf __P((char *, int *, struct sadb_ext *, int, caddr_t, int));
+ void parse_init __P((void));
+ void free_buffer __P((void));
+ 
+ int setkeymsg0 __P((struct sadb_msg *, unsigned int, unsigned int, size_t));
+ static int setkeymsg_spdaddr __P((unsigned int, unsigned int, vchar_t *,
+ 	struct addrinfo *, int, struct addrinfo *, int));
+ static int setkeymsg_addr __P((unsigned int, unsigned int,
+ 	struct addrinfo *, struct addrinfo *, int));
+ static int setkeymsg_add __P((unsigned int, unsigned int,
+ 	struct addrinfo *, struct addrinfo *));
+ extern int setkeymsg __P((char *, size_t *));
+ extern int sendkeymsg __P((char *, size_t));
+ 
+ extern int yylex __P((void));
+ extern void yyfatal __P((const char *));
+ extern void yyerror __P((const char *));
+ %}
+ 
+ %union {
+ 	int num;
+ 	unsigned long ulnum;
+ 	vchar_t val;
+ 	struct addrinfo *res;
+ }
+ 
+ %token EOT SLASH BLCL ELCL
+ %token ADD GET DELETE DELETEALL FLUSH DUMP
+ %token PR_ESP PR_AH PR_IPCOMP
+ %token F_PROTOCOL F_AUTH F_ENC F_REPLAY F_COMP F_RAWCPI
+ %token F_MODE MODE F_REQID
+ %token F_EXT EXTENSION NOCYCLICSEQ
+ %token ALG_AUTH ALG_ENC ALG_ENC_DESDERIV ALG_ENC_DES32IV ALG_COMP
+ %token F_LIFETIME_HARD F_LIFETIME_SOFT
+ %token DECSTRING QUOTEDSTRING HEXSTRING STRING ANY
+ 	/* SPD management */
+ %token SPDADD SPDDELETE SPDDUMP SPDFLUSH
+ %token F_POLICY PL_REQUESTS
+ %token F_AIFLAGS
+ 
+ %type <num> prefix protocol_spec upper_spec
+ %type <num> ALG_AUTH ALG_ENC ALG_ENC_DESDERIV ALG_ENC_DES32IV ALG_COMP
+ %type <num> PR_ESP PR_AH PR_IPCOMP
+ %type <num> EXTENSION MODE
+ %type <ulnum> DECSTRING
+ %type <val> PL_REQUESTS portstr key_string
+ %type <val> policy_requests
+ %type <val> QUOTEDSTRING HEXSTRING STRING
+ %type <val> F_AIFLAGS
+ %type <val> upper_misc_spec policy_spec
+ %type <res> ipaddr
+ 
+ %%
+ commands
+ 	:	/*NOTHING*/
+ 	|	commands command
+ 		{
+ 			free_buffer();
+ 			parse_init();
+ 		}
+ 	;
+ 
+ command
+ 	:	add_command
+ 	|	get_command
+ 	|	delete_command
+ 	|	deleteall_command
+ 	|	flush_command
+ 	|	dump_command
+ 	|	spdadd_command
+ 	|	spddelete_command
+ 	|	spddump_command
+ 	|	spdflush_command
+ 	;
+ 	/* commands concerned with management, there is in tail of this file. */
+ 
+ 	/* add command */
+ add_command
+ 	:	ADD ipaddropts ipaddr ipaddr protocol_spec spi extension_spec algorithm_spec EOT
+ 		{
+ 			int status;
+ 
+ 			status = setkeymsg_add(SADB_ADD, $5, $3, $4);
+ 			if (status < 0)
+ 				return -1;
+ 		}
+ 	;
+ 
+ 	/* delete */
+ delete_command
+ 	:	DELETE ipaddropts ipaddr ipaddr protocol_spec spi extension_spec EOT
+ 		{
+ 			int status;
+ 
+ 			if ($3->ai_next || $4->ai_next) {
+ 				yyerror("multiple address specified");
+ 				return -1;
+ 			}
+ 			if (p_mode != IPSEC_MODE_ANY)
+ 				yyerror("WARNING: mode is obsoleted.");
+ 
+ 			status = setkeymsg_addr(SADB_DELETE, $5, $3, $4, 0);
+ 			if (status < 0)
+ 				return -1;
+ 		}
+ 	;
+ 
+ 	/* deleteall command */
+ deleteall_command
+ 	:	DELETEALL ipaddropts ipaddr ipaddr protocol_spec EOT
+ 		{
+ 			int status;
+ 
+ 			status = setkeymsg_addr(SADB_DELETE, $5, $3, $4, 1);
+ 			if (status < 0)
+ 				return -1;
+ 		}
+ 	;
+ 
+ 	/* get command */
+ get_command
+ 	:	GET ipaddropts ipaddr ipaddr protocol_spec spi extension_spec EOT
+ 		{
+ 			int status;
+ 
+ 			if (p_mode != IPSEC_MODE_ANY)
+ 				yyerror("WARNING: mode is obsoleted.");
+ 
+ 			status = setkeymsg_addr(SADB_GET, $5, $3, $4, 0);
+ 			if (status < 0)
+ 				return -1;
+ 		}
+ 	;
+ 
+ 	/* flush */
+ flush_command
+ 	:	FLUSH protocol_spec EOT
+ 		{
+ 			struct sadb_msg msg;
+ 			setkeymsg0(&msg, SADB_FLUSH, $2, sizeof(msg));
+ 			sendkeymsg((char *)&msg, sizeof(msg));
+ 		}
+ 	;
+ 
+ 	/* dump */
+ dump_command
+ 	:	DUMP protocol_spec EOT
+ 		{
+ 			struct sadb_msg msg;
+ 			setkeymsg0(&msg, SADB_DUMP, $2, sizeof(msg));
+ 			sendkeymsg((char *)&msg, sizeof(msg));
+ 		}
+ 	;
+ 
+ protocol_spec
+ 	:	/*NOTHING*/
+ 		{
+ 			$$ = SADB_SATYPE_UNSPEC;
+ 		}
+ 	|	PR_ESP
+ 		{
+ 			$$ = SADB_SATYPE_ESP;
+ 			if ($1 == 1)
+ 				p_ext |= SADB_X_EXT_OLD;
+ 			else
+ 				p_ext &= ~SADB_X_EXT_OLD;
+ 		}
+ 	|	PR_AH
+ 		{
+ 			$$ = SADB_SATYPE_AH;
+ 			if ($1 == 1)
+ 				p_ext |= SADB_X_EXT_OLD;
+ 			else
+ 				p_ext &= ~SADB_X_EXT_OLD;
+ 		}
+ 	|	PR_IPCOMP
+ 		{
+ 			$$ = SADB_X_SATYPE_IPCOMP;
+ 		}
+ 	;
+ 	
+ spi
+ 	:	DECSTRING { p_spi = $1; }
+ 	|	HEXSTRING
+ 		{
+ 			char *ep;
+ 			unsigned long v;
+ 
+ 			ep = NULL;
+ 			v = strtoul($1.buf, &ep, 16);
+ 			if (!ep || *ep) {
+ 				yyerror("invalid SPI");
+ 				return -1;
+ 			}
+ 			if (v & ~0xffffffff) {
+ 				yyerror("SPI too big.");
+ 				return -1;
+ 			}
+ 
+ 			p_spi = v;
+ 		}
+ 	;
+ 
+ algorithm_spec
+ 	:	esp_spec
+ 	|	ah_spec
+ 	|	ipcomp_spec
+ 	;
+ 
+ esp_spec
+ 	:	F_ENC enc_alg enc_key F_AUTH auth_alg auth_key
+ 	|	F_ENC enc_alg enc_key
+ 	;
+ 
+ ah_spec
+ 	:	F_AUTH auth_alg auth_key
+ 	;
+ 
+ ipcomp_spec
+ 	:	F_COMP ALG_COMP
+ 		{
+ 			if ($2 < 0) {
+ 				yyerror("unsupported algorithm");
+ 				return -1;
+ 			}
+ 			p_alg_enc = $2;
+ 		}
+ 	|	F_COMP ALG_COMP F_RAWCPI
+ 		{
+ 			if ($2 < 0) {
+ 				yyerror("unsupported algorithm");
+ 				return -1;
+ 			}
+ 			p_alg_enc = $2;
+ 			p_ext |= SADB_X_EXT_RAWCPI;
+ 		}
+ 	;
+ 
+ enc_alg
+ 	:	ALG_ENC {
+ 			if ($1 < 0) {
+ 				yyerror("unsupported algorithm");
+ 				return -1;
+ 			}
+ 			p_alg_enc = $1;
+ 		}
+ 	|	ALG_ENC_DESDERIV
+ 		{
+ 			if ($1 < 0) {
+ 				yyerror("unsupported algorithm");
+ 				return -1;
+ 			}
+ 			p_alg_enc = $1;
+ 			if (p_ext & SADB_X_EXT_OLD) {
+ 				yyerror("algorithm mismatched.");
+ 				return -1;
+ 			}
+ 			p_ext |= SADB_X_EXT_DERIV;
+ 		}
+ 	|	ALG_ENC_DES32IV
+ 		{
+ 			if ($1 < 0) {
+ 				yyerror("unsupported algorithm");
+ 				return -1;
+ 			}
+ 			p_alg_enc = $1;
+ 			if (!(p_ext & SADB_X_EXT_OLD)) {
+ 				yyerror("algorithm mismatched.");
+ 				return -1;
+ 			}
+ 			p_ext |= SADB_X_EXT_IV4B;
+ 		}
+ 	;
+ 
+ enc_key
+ 	:	/*NOTHING*/
+ 		{
+ 			if (p_alg_enc != SADB_EALG_NULL) {
+ 				yyerror("no key found.");
+ 				return -1;
+ 			}
+ 		}
+ 	|	key_string
+ 		{
+ 			p_key_enc_len = $1.len;
+ 			p_key_enc = $1.buf;
+ 
+ 			if (ipsec_check_keylen(SADB_EXT_SUPPORTED_ENCRYPT,
+ 					p_alg_enc,
+ 					PFKEY_UNUNIT64(p_key_enc_len)) < 0) {
+ 				yyerror(ipsec_strerror());
+ 				return -1;
+ 			}
+ 		}
+ 	;
+ 
+ auth_alg
+ 	:	ALG_AUTH {
+ 			if ($1 < 0) {
+ 				yyerror("unsupported algorithm");
+ 				return -1;
+ 			}
+ 			p_alg_auth = $1;
+ 		}
+ 	;
+ 
+ auth_key
+ 	:	/*NOTHING*/
+ 		{
+ 			if (p_alg_auth != SADB_X_AALG_NULL) {
+ 				yyerror("no key found.");
+ 				return -1;
+ 			}
+ 		}
+ 	|	key_string
+ 		{
+ 			p_key_auth_len = $1.len;
+ 			p_key_auth = $1.buf;
+ 
+ 			if (ipsec_check_keylen(SADB_EXT_SUPPORTED_AUTH,
+ 					p_alg_auth,
+ 					PFKEY_UNUNIT64(p_key_auth_len)) < 0) {
+ 				yyerror(ipsec_strerror());
+ 				return -1;
+ 			}
+ 		}
+ 	;
+ 
+ key_string
+ 	:	QUOTEDSTRING
+ 		{
+ 			$$ = $1;
+ 		}
+ 	|	HEXSTRING
+ 		{
+ 			caddr_t pp_key;
+ 			caddr_t bp;
+ 			caddr_t yp = $1.buf;
+ 			int l;
+ 
+ 			l = strlen(yp) % 2 + strlen(yp) / 2;
+ 			if ((pp_key = malloc(l)) == 0) {
+ 				yyerror("not enough core");
+ 				return -1;
+ 			}
+ 			memset(pp_key, 0, l);
+ 
+ 			bp = pp_key;
+ 			if (strlen(yp) % 2) {
+ 				*bp = ATOX(yp[0]);
+ 				yp++, bp++;
+ 			}
+ 			while (*yp) {
+ 				*bp = (ATOX(yp[0]) << 4) | ATOX(yp[1]);
+ 				yp += 2, bp++;
+ 			}
+ 
+ 			$$.len = l;
+ 			$$.buf = pp_key;
+ 		}
+ 	;
+ 
+ extension_spec
+ 	:	/*NOTHING*/
+ 	|	extension_spec extension
+ 	;
+ 
+ extension
+ 	:	F_EXT EXTENSION { p_ext |= $2; }
+ 	|	F_EXT NOCYCLICSEQ { p_ext &= ~SADB_X_EXT_CYCSEQ; }
+ 	|	F_MODE MODE { p_mode = $2; }
+ 	|	F_MODE ANY { p_mode = IPSEC_MODE_ANY; }
+ 	|	F_REQID DECSTRING { p_reqid = $2; }
+ 	|	F_REPLAY DECSTRING
+ 		{
+ 			if ((p_ext & SADB_X_EXT_OLD) != 0) {
+ 				yyerror("replay prevention cannot be used with "
+ 				    "ah/esp-old.");
+ 				return -1;
+ 			}
+ 			p_replay = $2;
+ 		}
+ 	|	F_LIFETIME_HARD DECSTRING { p_lt_hard = $2; }
+ 	|	F_LIFETIME_SOFT DECSTRING { p_lt_soft = $2; }
+ 	;
+ 
+ 	/* definition about command for SPD management */
+ 	/* spdadd */
+ spdadd_command
+ 	:	SPDADD ipaddropts STRING prefix portstr STRING prefix portstr upper_spec upper_misc_spec policy_spec EOT
+ 		{
+ 			int status;
+ 			struct addrinfo *src, *dst;
+ 
+ 			/* fixed port fields if ulp is icmpv6 */
+ 			if ($10.buf != NULL) {
+ 				if ($9 != IPPROTO_ICMPV6)
+ 					return -1;
+ 				free($5.buf);
+ 				free($8.buf);
+ 				if (fix_portstr(&$10, &$5, &$8))
+ 					return -1;
+ 			}
+ 
+ 			src = parse_addr($3.buf, $5.buf);
+ 			dst = parse_addr($6.buf, $8.buf);
+ 			if (!src || !dst) {
+ 				/* yyerror is already called */
+ 				return -1;
+ 			}
+ 			if (src->ai_next || dst->ai_next) {
+ 				yyerror("multiple address specified");
+ 				freeaddrinfo(src);
+ 				freeaddrinfo(dst);
+ 				return -1;
+ 			}
+ 
+ 			status = setkeymsg_spdaddr(SADB_X_SPDADD, $9, &$11,
+ 			    src, $4, dst, $7);
+ 			freeaddrinfo(src);
+ 			freeaddrinfo(dst);
+ 			if (status < 0)
+ 				return -1;
+ 		}
+ 	;
+ 
+ spddelete_command
+ 	:	SPDDELETE ipaddropts STRING prefix portstr STRING prefix portstr upper_spec upper_misc_spec policy_spec EOT
+ 		{
+ 			int status;
+ 			struct addrinfo *src, *dst;
+ 
+ 			/* fixed port fields if ulp is icmpv6 */
+ 			if ($10.buf != NULL) {
+ 				if ($9 != IPPROTO_ICMPV6)
+ 					return -1;
+ 				free($5.buf);
+ 				free($8.buf);
+ 				if (fix_portstr(&$10, &$5, &$8))
+ 					return -1;
+ 			}
+ 
+ 			src = parse_addr($3.buf, $5.buf);
+ 			dst = parse_addr($6.buf, $8.buf);
+ 			if (!src || !dst) {
+ 				/* yyerror is already called */
+ 				return -1;
+ 			}
+ 			if (src->ai_next || dst->ai_next) {
+ 				yyerror("multiple address specified");
+ 				freeaddrinfo(src);
+ 				freeaddrinfo(dst);
+ 				return -1;
+ 			}
+ 
+ 			status = setkeymsg_spdaddr(SADB_X_SPDDELETE, $9, &$11,
+ 			    src, $4, dst, $7);
+ 			freeaddrinfo(src);
+ 			freeaddrinfo(dst);
+ 			if (status < 0)
+ 				return -1;
+ 		}
+ 	;
+ 
+ spddump_command:
+ 		SPDDUMP EOT
+ 		{
+ 			struct sadb_msg msg;
+ 			setkeymsg0(&msg, SADB_X_SPDDUMP, SADB_SATYPE_UNSPEC,
+ 			    sizeof(msg));
+ 			sendkeymsg((char *)&msg, sizeof(msg));
+ 		}
+ 	;
+ 
+ spdflush_command:
+ 		SPDFLUSH EOT
+ 		{
+ 			struct sadb_msg msg;
+ 			setkeymsg0(&msg, SADB_X_SPDFLUSH, SADB_SATYPE_UNSPEC,
+ 			    sizeof(msg));
+ 			sendkeymsg((char *)&msg, sizeof(msg));
+ 		}
+ 	;
+ 
+ ipaddropts
+ 	:	/* nothing */
+ 	|	ipaddropts ipaddropt
+ 	;
+ 
+ ipaddropt
+ 	:	F_AIFLAGS
+ 		{
+ 			char *p;
+ 
+ 			for (p = $1.buf + 1; *p; p++)
+ 				switch (*p) {
+ 				case '4':
+ 					p_aifamily = AF_INET;
+ 					break;
+ #ifdef INET6
+ 				case '6':
+ 					p_aifamily = AF_INET6;
+ 					break;
+ #endif
+ 				case 'n':
+ 					p_aiflags = AI_NUMERICHOST;
+ 					break;
+ 				default:
+ 					yyerror("invalid flag");
+ 					return -1;
+ 				}
+ 		}
+ 	;
+ 
+ ipaddr
+ 	:	STRING
+ 		{
+ 			$$ = parse_addr($1.buf, NULL);
+ 			if ($$ == NULL) {
+ 				/* yyerror already called by parse_addr */
+ 				return -1;
+ 			}
+ 		}
+ 	;
+ 
+ prefix
+ 	:	/*NOTHING*/ { $$ = -1; }
+ 	|	SLASH DECSTRING { $$ = $2; }
+ 	;
+ 
+ portstr
+ 	:	/*NOTHING*/
+ 		{
+ 			$$.buf = strdup("0");
+ 			$$.len = strlen($$.buf);
+ 		}
+ 	|	BLCL ANY ELCL
+ 		{
+ 			$$.buf = strdup("0");
+ 			$$.len = strlen($$.buf);
+ 		}
+ 	|	BLCL DECSTRING ELCL
+ 		{
+ 			char buf[20];
+ 			snprintf(buf, sizeof(buf), "%lu", $2);
+ 			$$.buf = strdup(buf);
+ 			$$.len = strlen($$.buf);
+ 		}
+ 	|	BLCL STRING ELCL
+ 		{
+ 			$$ = $2;
+ 		}
+ 	;
+ 
+ upper_spec
+ 	:	DECSTRING { $$ = $1; }
+ 	|	ANY { $$ = IPSEC_ULPROTO_ANY; }
+ 	|	STRING
+ 		{
+ 			struct protoent *ent;
+ 
+ 			ent = getprotobyname($1.buf);
+ 			if (ent)
+ 				$$ = ent->p_proto;
+ 			else {
+ 				if (strcmp("icmp6", $1.buf) == 0) {
+ 					$$ = IPPROTO_ICMPV6;
+ 				} else if(strcmp("ip4", $1.buf) == 0) {
+ 					$$ = IPPROTO_IPV4;
+ 				} else {
+ 					yyerror("invalid upper layer protocol");
+ 					return -1;
+ 				}
+ 			}
+ 			endprotoent();
+ 		}
+ 	;
+ 
+ upper_misc_spec
+ 	:	/*NOTHING*/
+ 		{
+ 			$$.buf = NULL;
+ 			$$.len = 0;
+ 		}
+ 	|	STRING
+ 		{
+ 			$$.buf = strdup($1.buf);
+ 			$$.len = strlen($$.buf);
+ 		}
+ 	;
+ 
+ policy_spec
+ 	:	F_POLICY policy_requests
+ 		{
+ 			char *policy;
+ 
+ 			policy = ipsec_set_policy($2.buf, $2.len);
+ 			if (policy == NULL) {
+ 				yyerror(ipsec_strerror());
+ 				return -1;
+ 			}
+ 
+ 			$$.buf = policy;
+ 			$$.len = ipsec_get_policylen(policy);
+ 		}
+ 	;
+ 
+ policy_requests
+ 	:	PL_REQUESTS { $$ = $1; }
+ 	;
+ 
+ %%
+ 
+ int
+ setkeymsg0(msg, type, satype, l)
+ 	struct sadb_msg *msg;
+ 	unsigned int type;
+ 	unsigned int satype;
+ 	size_t l;
+ {
+ 
+ 	msg->sadb_msg_version = PF_KEY_V2;
+ 	msg->sadb_msg_type = type;
+ 	msg->sadb_msg_errno = 0;
+ 	msg->sadb_msg_satype = satype;
+ 	msg->sadb_msg_reserved = 0;
+ 	msg->sadb_msg_seq = 0;
+ 	msg->sadb_msg_pid = getpid();
+ 	msg->sadb_msg_len = PFKEY_UNIT64(l);
+ 	return 0;
+ }
+ 
+ /* XXX NO BUFFER OVERRUN CHECK! BAD BAD! */
+ static int
+ setkeymsg_spdaddr(type, upper, policy, srcs, splen, dsts, dplen)
+ 	unsigned int type;
+ 	unsigned int upper;
+ 	vchar_t *policy;
+ 	struct addrinfo *srcs;
+ 	int splen;
+ 	struct addrinfo *dsts;
+ 	int dplen;
+ {
+ 	struct sadb_msg *msg;
+ 	char buf[BUFSIZ];
+ 	int l, l0;
+ 	struct sadb_address m_addr;
+ 	struct addrinfo *s, *d;
+ 	int n;
+ 	int plen;
+ 	struct sockaddr *sa;
+ 	int salen;
+ 
+ 	msg = (struct sadb_msg *)buf;
+ 
+ 	if (!srcs || !dsts)
+ 		return -1;
+ 
+ 	/* fix up length afterwards */
+ 	setkeymsg0(msg, type, SADB_SATYPE_UNSPEC, 0);
+ 	l = sizeof(struct sadb_msg);
+ 
+ 	memcpy(buf + l, policy->buf, policy->len);
+ 	l += policy->len;
+ 
+ 	l0 = l;
+ 	n = 0;
+ 
+ 	/* do it for all src/dst pairs */
+ 	for (s = srcs; s; s = s->ai_next) {
+ 		for (d = dsts; d; d = d->ai_next) {
+ 			/* rewind pointer */
+ 			l = l0;
+ 
+ 			if (s->ai_addr->sa_family != d->ai_addr->sa_family)
+ 				continue;
+ 			switch (s->ai_addr->sa_family) {
+ 			case AF_INET:
+ 				plen = sizeof(struct in_addr) << 3;
+ 				break;
+ #ifdef INET6
+ 			case AF_INET6:
+ 				plen = sizeof(struct in6_addr) << 3;
+ 				break;
+ #endif
+ 			default:
+ 				continue;
+ 			}
+ 
+ 			/* set src */
+ 			sa = s->ai_addr;
+ 			salen = sysdep_sa_len(s->ai_addr);
+ 			m_addr.sadb_address_len = PFKEY_UNIT64(sizeof(m_addr) +
+ 			    PFKEY_ALIGN8(salen));
+ 			m_addr.sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
+ 			m_addr.sadb_address_proto = upper;
+ 			m_addr.sadb_address_prefixlen =
+ 			    (splen >= 0 ? splen : plen);
+ 			m_addr.sadb_address_reserved = 0;
+ 
+ 			setvarbuf(buf, &l, (struct sadb_ext *)&m_addr,
+ 			    sizeof(m_addr), (caddr_t)sa, salen);
+ 
+ 			/* set dst */
+ 			sa = d->ai_addr;
+ 			salen = sysdep_sa_len(d->ai_addr);
+ 			m_addr.sadb_address_len = PFKEY_UNIT64(sizeof(m_addr) +
+ 			    PFKEY_ALIGN8(salen));
+ 			m_addr.sadb_address_exttype = SADB_EXT_ADDRESS_DST;
+ 			m_addr.sadb_address_proto = upper;
+ 			m_addr.sadb_address_prefixlen =
+ 			    (dplen >= 0 ? dplen : plen);
+ 			m_addr.sadb_address_reserved = 0;
+ 
+ 			setvarbuf(buf, &l, (struct sadb_ext *)&m_addr,
+ 			    sizeof(m_addr), (caddr_t)sa, salen);
+ 
+ 			msg->sadb_msg_len = PFKEY_UNIT64(l);
+ 
+ 			sendkeymsg(buf, l);
+ 
+ 			n++;
+ 		}
+ 	}
+ 
+ 	if (n == 0)
+ 		return -1;
+ 	else
+ 		return 0;
+ }
+ 
+ /* XXX NO BUFFER OVERRUN CHECK! BAD BAD! */
+ static int
+ setkeymsg_addr(type, satype, srcs, dsts, no_spi)
+ 	unsigned int type;
+ 	unsigned int satype;
+ 	struct addrinfo *srcs;
+ 	struct addrinfo *dsts;
+ 	int no_spi;
+ {
+ 	struct sadb_msg *msg;
+ 	char buf[BUFSIZ];
+ 	int l, l0, len;
+ 	struct sadb_sa m_sa;
+ 	struct sadb_x_sa2 m_sa2;
+ 	struct sadb_address m_addr;
+ 	struct addrinfo *s, *d;
+ 	int n;
+ 	int plen;
+ 	struct sockaddr *sa;
+ 	int salen;
+ 
+ 	msg = (struct sadb_msg *)buf;
+ 
+ 	if (!srcs || !dsts)
+ 		return -1;
+ 
+ 	/* fix up length afterwards */
+ 	setkeymsg0(msg, type, satype, 0);
+ 	l = sizeof(struct sadb_msg);
+ 
+ 	if (!no_spi) {
+ 		len = sizeof(struct sadb_sa);
+ 		m_sa.sadb_sa_len = PFKEY_UNIT64(len);
+ 		m_sa.sadb_sa_exttype = SADB_EXT_SA;
+ 		m_sa.sadb_sa_spi = htonl(p_spi);
+ 		m_sa.sadb_sa_replay = p_replay;
+ 		m_sa.sadb_sa_state = 0;
+ 		m_sa.sadb_sa_auth = p_alg_auth;
+ 		m_sa.sadb_sa_encrypt = p_alg_enc;
+ 		m_sa.sadb_sa_flags = p_ext;
+ 
+ 		memcpy(buf + l, &m_sa, len);
+ 		l += len;
+ 
+ 		len = sizeof(struct sadb_x_sa2);
+ 		m_sa2.sadb_x_sa2_len = PFKEY_UNIT64(len);
+ 		m_sa2.sadb_x_sa2_exttype = SADB_X_EXT_SA2;
+ 		m_sa2.sadb_x_sa2_mode = p_mode;
+ 		m_sa2.sadb_x_sa2_reqid = p_reqid;
+ 
+ 		memcpy(buf + l, &m_sa2, len);
+ 		l += len;
+ 	}
+ 
+ 	l0 = l;
+ 	n = 0;
+ 
+ 	/* do it for all src/dst pairs */
+ 	for (s = srcs; s; s = s->ai_next) {
+ 		for (d = dsts; d; d = d->ai_next) {
+ 			/* rewind pointer */
+ 			l = l0;
+ 
+ 			if (s->ai_addr->sa_family != d->ai_addr->sa_family)
+ 				continue;
+ 			switch (s->ai_addr->sa_family) {
+ 			case AF_INET:
+ 				plen = sizeof(struct in_addr) << 3;
+ 				break;
+ #ifdef INET6
+ 			case AF_INET6:
+ 				plen = sizeof(struct in6_addr) << 3;
+ 				break;
+ #endif
+ 			default:
+ 				continue;
+ 			}
+ 
+ 			/* set src */
+ 			sa = s->ai_addr;
+ 			salen = sysdep_sa_len(s->ai_addr);
+ 			m_addr.sadb_address_len = PFKEY_UNIT64(sizeof(m_addr) +
+ 			    PFKEY_ALIGN8(salen));
+ 			m_addr.sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
+ 			m_addr.sadb_address_proto = IPSEC_ULPROTO_ANY;
+ 			m_addr.sadb_address_prefixlen = plen;
+ 			m_addr.sadb_address_reserved = 0;
+ 
+ 			setvarbuf(buf, &l, (struct sadb_ext *)&m_addr,
+ 			    sizeof(m_addr), (caddr_t)sa, salen);
+ 
+ 			/* set dst */
+ 			sa = d->ai_addr;
+ 			salen = sysdep_sa_len(d->ai_addr);
+ 			m_addr.sadb_address_len = PFKEY_UNIT64(sizeof(m_addr) +
+ 			    PFKEY_ALIGN8(salen));
+ 			m_addr.sadb_address_exttype = SADB_EXT_ADDRESS_DST;
+ 			m_addr.sadb_address_proto = IPSEC_ULPROTO_ANY;
+ 			m_addr.sadb_address_prefixlen = plen;
+ 			m_addr.sadb_address_reserved = 0;
+ 
+ 			setvarbuf(buf, &l, (struct sadb_ext *)&m_addr,
+ 			    sizeof(m_addr), (caddr_t)sa, salen);
+ 
+ 			msg->sadb_msg_len = PFKEY_UNIT64(l);
+ 
+ 			sendkeymsg(buf, l);
+ 
+ 			n++;
+ 		}
+ 	}
+ 
+ 	if (n == 0)
+ 		return -1;
+ 	else
+ 		return 0;
+ }
+ 
+ /* XXX NO BUFFER OVERRUN CHECK! BAD BAD! */
+ static int
+ setkeymsg_add(type, satype, srcs, dsts)
+ 	unsigned int type;
+ 	unsigned int satype;
+ 	struct addrinfo *srcs;
+ 	struct addrinfo *dsts;
+ {
+ 	struct sadb_msg *msg;
+ 	char buf[BUFSIZ];
+ 	int l, l0, len;
+ 	struct sadb_sa m_sa;
+ 	struct sadb_x_sa2 m_sa2;
+ 	struct sadb_address m_addr;
+ 	struct addrinfo *s, *d;
+ 	int n;
+ 	int plen;
+ 	struct sockaddr *sa;
+ 	int salen;
+ 
+ 	msg = (struct sadb_msg *)buf;
+ 
+ 	if (!srcs || !dsts)
+ 		return -1;
+ 
+ 	/* fix up length afterwards */
+ 	setkeymsg0(msg, type, satype, 0);
+ 	l = sizeof(struct sadb_msg);
+ 
+ 	/* set encryption algorithm, if present. */
+ 	if (satype != SADB_X_SATYPE_IPCOMP && p_alg_enc != SADB_EALG_NONE) {
+ 		struct sadb_key m_key;
+ 
+ 		m_key.sadb_key_len =
+ 			PFKEY_UNIT64(sizeof(m_key)
+ 				   + PFKEY_ALIGN8(p_key_enc_len));
+ 		m_key.sadb_key_exttype = SADB_EXT_KEY_ENCRYPT;
+ 		m_key.sadb_key_bits = p_key_enc_len * 8;
+ 		m_key.sadb_key_reserved = 0;
+ 
+ 		setvarbuf(buf, &l,
+ 			(struct sadb_ext *)&m_key, sizeof(m_key),
+ 			(caddr_t)p_key_enc, p_key_enc_len);
+ 	}
+ 
+ 	/* set authentication algorithm, if present. */
+ 	if (p_alg_auth != SADB_AALG_NONE) {
+ 		struct sadb_key m_key;
+ 
+ 		m_key.sadb_key_len =
+ 			PFKEY_UNIT64(sizeof(m_key)
+ 				   + PFKEY_ALIGN8(p_key_auth_len));
+ 		m_key.sadb_key_exttype = SADB_EXT_KEY_AUTH;
+ 		m_key.sadb_key_bits = p_key_auth_len * 8;
+ 		m_key.sadb_key_reserved = 0;
+ 
+ 		setvarbuf(buf, &l,
+ 			(struct sadb_ext *)&m_key, sizeof(m_key),
+ 			(caddr_t)p_key_auth, p_key_auth_len);
+ 	}
+ 
+ 	/* set lifetime for HARD */
+ 	if (p_lt_hard != 0) {
+ 		struct sadb_lifetime m_lt;
+ 		u_int len = sizeof(struct sadb_lifetime);
+ 
+ 		m_lt.sadb_lifetime_len = PFKEY_UNIT64(len);
+ 		m_lt.sadb_lifetime_exttype = SADB_EXT_LIFETIME_HARD;
+ 		m_lt.sadb_lifetime_allocations = 0;
+ 		m_lt.sadb_lifetime_bytes = 0;
+ 		m_lt.sadb_lifetime_addtime = p_lt_hard;
+ 		m_lt.sadb_lifetime_usetime = 0;
+ 
+ 		memcpy(buf + l, &m_lt, len);
+ 		l += len;
+ 	}
+ 
+ 	/* set lifetime for SOFT */
+ 	if (p_lt_soft != 0) {
+ 		struct sadb_lifetime m_lt;
+ 		u_int len = sizeof(struct sadb_lifetime);
+ 
+ 		m_lt.sadb_lifetime_len = PFKEY_UNIT64(len);
+ 		m_lt.sadb_lifetime_exttype = SADB_EXT_LIFETIME_SOFT;
+ 		m_lt.sadb_lifetime_allocations = 0;
+ 		m_lt.sadb_lifetime_bytes = 0;
+ 		m_lt.sadb_lifetime_addtime = p_lt_soft;
+ 		m_lt.sadb_lifetime_usetime = 0;
+ 
+ 		memcpy(buf + l, &m_lt, len);
+ 		l += len;
+ 	}
+ 
+ 	len = sizeof(struct sadb_sa);
+ 	m_sa.sadb_sa_len = PFKEY_UNIT64(len);
+ 	m_sa.sadb_sa_exttype = SADB_EXT_SA;
+ 	m_sa.sadb_sa_spi = htonl(p_spi);
+ 	m_sa.sadb_sa_replay = p_replay;
+ 	m_sa.sadb_sa_state = 0;
+ 	m_sa.sadb_sa_auth = p_alg_auth;
+ 	m_sa.sadb_sa_encrypt = p_alg_enc;
+ 	m_sa.sadb_sa_flags = p_ext;
+ 
+ 	memcpy(buf + l, &m_sa, len);
+ 	l += len;
+ 
+ 	len = sizeof(struct sadb_x_sa2);
+ 	m_sa2.sadb_x_sa2_len = PFKEY_UNIT64(len);
+ 	m_sa2.sadb_x_sa2_exttype = SADB_X_EXT_SA2;
+ 	m_sa2.sadb_x_sa2_mode = p_mode;
+ 	m_sa2.sadb_x_sa2_reqid = p_reqid;
+ 
+ 	memcpy(buf + l, &m_sa2, len);
+ 	l += len;
+ 
+ 	l0 = l;
+ 	n = 0;
+ 
+ 	/* do it for all src/dst pairs */
+ 	for (s = srcs; s; s = s->ai_next) {
+ 		for (d = dsts; d; d = d->ai_next) {
+ 			/* rewind pointer */
+ 			l = l0;
+ 
+ 			if (s->ai_addr->sa_family != d->ai_addr->sa_family)
+ 				continue;
+ 			switch (s->ai_addr->sa_family) {
+ 			case AF_INET:
+ 				plen = sizeof(struct in_addr) << 3;
+ 				break;
+ #ifdef INET6
+ 			case AF_INET6:
+ 				plen = sizeof(struct in6_addr) << 3;
+ 				break;
+ #endif
+ 			default:
+ 				continue;
+ 			}
+ 
+ 			/* set src */
+ 			sa = s->ai_addr;
+ 			salen = sysdep_sa_len(s->ai_addr);
+ 			m_addr.sadb_address_len = PFKEY_UNIT64(sizeof(m_addr) +
+ 			    PFKEY_ALIGN8(salen));
+ 			m_addr.sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
+ 			m_addr.sadb_address_proto = IPSEC_ULPROTO_ANY;
+ 			m_addr.sadb_address_prefixlen = plen;
+ 			m_addr.sadb_address_reserved = 0;
+ 
+ 			setvarbuf(buf, &l, (struct sadb_ext *)&m_addr,
+ 			    sizeof(m_addr), (caddr_t)sa, salen);
+ 
+ 			/* set dst */
+ 			sa = d->ai_addr;
+ 			salen = sysdep_sa_len(d->ai_addr);
+ 			m_addr.sadb_address_len = PFKEY_UNIT64(sizeof(m_addr) +
+ 			    PFKEY_ALIGN8(salen));
+ 			m_addr.sadb_address_exttype = SADB_EXT_ADDRESS_DST;
+ 			m_addr.sadb_address_proto = IPSEC_ULPROTO_ANY;
+ 			m_addr.sadb_address_prefixlen = plen;
+ 			m_addr.sadb_address_reserved = 0;
+ 
+ 			setvarbuf(buf, &l, (struct sadb_ext *)&m_addr,
+ 			    sizeof(m_addr), (caddr_t)sa, salen);
+ 
+ 			msg->sadb_msg_len = PFKEY_UNIT64(l);
+ 
+ 			sendkeymsg(buf, l);
+ 
+ 			n++;
+ 		}
+ 	}
+ 
+ 	if (n == 0)
+ 		return -1;
+ 	else
+ 		return 0;
+ }
+ 
+ static struct addrinfo *
+ parse_addr(host, port)
+ 	char *host;
+ 	char *port;
+ {
+ 	struct addrinfo hints, *res = NULL;
+ 	int error;
+ 
+ 	memset(&hints, 0, sizeof(hints));
+ 	hints.ai_family = p_aifamily;
+ 	hints.ai_socktype = SOCK_DGRAM;
+ 	hints.ai_flags = p_aiflags;
+ 	error = getaddrinfo(host, port, &hints, &res);
+ 	if (error != 0) {
+ 		yyerror(gai_strerror(error));
+ 		return NULL;
+ 	}
+ 	return res;
+ }
+ 
+ static int
+ fix_portstr(spec, sport, dport)
+ 	vchar_t *spec, *sport, *dport;
+ {
+ 	char *p, *p2;
+ 	u_int l;
+ 
+ 	l = 0;
+ 	for (p = spec->buf; *p != ',' && *p != '\0' && l < spec->len; p++, l++)
+ 		;
+ 	if (*p == '\0') {
+ 		p2 = "0";
+ 	} else {
+ 		if (*p == ',') {
+ 			*p = '\0';
+ 			p2 = ++p;
+ 		}
+ 		for (p = p2; *p != '\0' && l < spec->len; p++, l++)
+ 			;
+ 		if (*p != '\0' || *p2 == '\0') {
+ 			yyerror("invalid an upper layer protocol spec");
+ 			return -1;
+ 		}
+ 	}
+ 
+ 	sport->buf = strdup(spec->buf);
+ 	sport->len = strlen(sport->buf);
+ 	dport->buf = strdup(p2);
+ 	dport->len = strlen(dport->buf);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ setvarbuf(buf, off, ebuf, elen, vbuf, vlen)
+ 	char *buf;
+ 	int *off;
+ 	struct sadb_ext *ebuf;
+ 	int elen;
+ 	caddr_t vbuf;
+ 	int vlen;
+ {
+ 	memset(buf + *off, 0, PFKEY_UNUNIT64(ebuf->sadb_ext_len));
+ 	memcpy(buf + *off, (caddr_t)ebuf, elen);
+ 	memcpy(buf + *off + elen, vbuf, vlen);
+ 	(*off) += PFKEY_ALIGN8(elen + vlen);
+ 
+ 	return 0;
+ }
+ 
+ void
+ parse_init()
+ {
+ 	p_spi = 0;
+ 
+ 	p_ext = SADB_X_EXT_CYCSEQ;
+ 	p_alg_enc = SADB_EALG_NONE;
+ 	p_alg_auth = SADB_AALG_NONE;
+ 	p_mode = IPSEC_MODE_ANY;
+ 	p_reqid = 0;
+ 	p_replay = 0;
+ 	p_key_enc_len = p_key_auth_len = 0;
+ 	p_key_enc = p_key_auth = 0;
+ 	p_lt_hard = p_lt_soft = 0;
+ 
+ 	p_aiflags = 0;
+ 	p_aifamily = PF_UNSPEC;
+ 
+ 	return;
+ }
+ 
+ void
+ free_buffer()
+ {
+ 	/* we got tons of memory leaks in the parser anyways, leave them */
+ 
+ 	return;
+ }
diff -Nr -c25 ac_am/src/setkey/sample.cf ac_am_fixed/src/setkey/sample.cf
*** ac_am/src/setkey/sample.cf	2003-02-26 22:30:53.000000000 +0100
--- ac_am_fixed/src/setkey/sample.cf	2003-12-11 18:19:59.269037856 +0100
***************
*** 164,217 ****
  	-E rc5-cbc "kamekame"
  	-A hmac-md5 "this is the test" ;
  
  # By "get" command, you can get a entry of either SP or SA.
  get fec0:0:0:1::1 fec0:0:0:2::2 ah 0x10004 ;
  
  # Also delete command, you can delete a entry of either SP or SA.
  spddelete fec0:0:0:1::/64 fec0:0:0:2::/64 any -P out;
  delete fec0:0:0:1::1 fec0:0:0:2::2 ah 0x10004 ;
  
  # By dump command, you can dump all entry of either SP or SA.
  dump ;
  spddump ;
  dump esp ;
  flush esp ;
  
  # By flush command, you can flush all entry of either SP or SA.
  flush ;
  spdflush ;
  
  # "flush" and "dump" commands can specify a security protocol.
  dump esp ;
  flush ah ;
  
  # XXX
! add ::1 ::1 esp 10001 -m transport -E simple ;
  add ::1 ::1 esp 10002 -m transport -E des-deriv "12341234" ;
  add ::1 ::1 esp-old 10003 -m transport -E des-32iv "12341234" ;
! add ::1 ::1 esp 10004 -m transport -E simple -A null ;
! add ::1 ::1 esp 10005 -m transport -E simple -A hmac-md5 "1234123412341234" ;
! add ::1 ::1 esp 10006 -m tunnel -E simple -A hmac-sha1 "12341234123412341234" ;
! add ::1 ::1 esp 10007 -m transport -E simple -A keyed-md5 "1234123412341234" ;
! add ::1 ::1 esp 10008 -m any -E simple -A keyed-sha1 "12341234123412341234" ;
  add ::1 ::1 esp 10009 -m transport -E des-cbc "testtest" ;
  add ::1 ::1 esp 10010 -m transport -E 3des-cbc "testtest12341234testtest" ;
  add ::1 ::1 esp 10011 -m tunnel -E cast128-cbc "testtest1234" ;
  add ::1 ::1 esp 10012 -m tunnel -E blowfish-cbc "testtest1234" ;
  add ::1 ::1 esp 10013 -m tunnel -E rc5-cbc "testtest1234" ;
  add ::1 ::1 esp 10014 -m any -E rc5-cbc "testtest1234" ;
! add ::1 ::1 esp 10015 -m transport -f zero-pad -E simple ;
! add ::1 ::1 esp 10016 -m tunnel -f random-pad -r 8 -lh 100 -ls 80 -E simple ;
! add ::1 ::1 esp 10017 -m transport -f seq-pad -f nocyclic-seq -E simple ;
! add ::1 ::1 esp 10018 -m transport -E simple ;
  #add ::1 ::1 ah 20000 -m transport -A null ;
  add ::1 ::1 ah 20001 -m any -A hmac-md5 "1234123412341234";
  add ::1 ::1 ah 20002 -m tunnel -A hmac-sha1 "12341234123412341234";
  add ::1 ::1 ah 20003 -m transport -A keyed-md5 "1234123412341234";
  add ::1 ::1 ah-old 20004 -m transport -A keyed-md5 "1234123412341234";
  add ::1 ::1 ah 20005 -m transport -A keyed-sha1 "12341234123412341234";
  #add ::1 ::1 ipcomp 30000 -C oui ;
  add ::1 ::1 ipcomp 30001 -C deflate ;
  #add ::1 ::1 ipcomp 30002 -C lzs ;
  
  # enjoy.
--- 164,217 ----
  	-E rc5-cbc "kamekame"
  	-A hmac-md5 "this is the test" ;
  
  # By "get" command, you can get a entry of either SP or SA.
  get fec0:0:0:1::1 fec0:0:0:2::2 ah 0x10004 ;
  
  # Also delete command, you can delete a entry of either SP or SA.
  spddelete fec0:0:0:1::/64 fec0:0:0:2::/64 any -P out;
  delete fec0:0:0:1::1 fec0:0:0:2::2 ah 0x10004 ;
  
  # By dump command, you can dump all entry of either SP or SA.
  dump ;
  spddump ;
  dump esp ;
  flush esp ;
  
  # By flush command, you can flush all entry of either SP or SA.
  flush ;
  spdflush ;
  
  # "flush" and "dump" commands can specify a security protocol.
  dump esp ;
  flush ah ;
  
  # XXX
! add ::1 ::1 esp 10001 -m transport -E null ;
  add ::1 ::1 esp 10002 -m transport -E des-deriv "12341234" ;
  add ::1 ::1 esp-old 10003 -m transport -E des-32iv "12341234" ;
! add ::1 ::1 esp 10004 -m transport -E null -A null ;
! add ::1 ::1 esp 10005 -m transport -E null -A hmac-md5 "1234123412341234" ;
! add ::1 ::1 esp 10006 -m tunnel -E null -A hmac-sha1 "12341234123412341234" ;
! add ::1 ::1 esp 10007 -m transport -E null -A keyed-md5 "1234123412341234" ;
! add ::1 ::1 esp 10008 -m any -E null -A keyed-sha1 "12341234123412341234" ;
  add ::1 ::1 esp 10009 -m transport -E des-cbc "testtest" ;
  add ::1 ::1 esp 10010 -m transport -E 3des-cbc "testtest12341234testtest" ;
  add ::1 ::1 esp 10011 -m tunnel -E cast128-cbc "testtest1234" ;
  add ::1 ::1 esp 10012 -m tunnel -E blowfish-cbc "testtest1234" ;
  add ::1 ::1 esp 10013 -m tunnel -E rc5-cbc "testtest1234" ;
  add ::1 ::1 esp 10014 -m any -E rc5-cbc "testtest1234" ;
! add ::1 ::1 esp 10015 -m transport -f zero-pad -E null ;
! add ::1 ::1 esp 10016 -m tunnel -f random-pad -r 8 -lh 100 -ls 80 -E null ;
! add ::1 ::1 esp 10017 -m transport -f seq-pad -f nocyclic-seq -E null ;
! add ::1 ::1 esp 10018 -m transport -E null ;
  #add ::1 ::1 ah 20000 -m transport -A null ;
  add ::1 ::1 ah 20001 -m any -A hmac-md5 "1234123412341234";
  add ::1 ::1 ah 20002 -m tunnel -A hmac-sha1 "12341234123412341234";
  add ::1 ::1 ah 20003 -m transport -A keyed-md5 "1234123412341234";
  add ::1 ::1 ah-old 20004 -m transport -A keyed-md5 "1234123412341234";
  add ::1 ::1 ah 20005 -m transport -A keyed-sha1 "12341234123412341234";
  #add ::1 ::1 ipcomp 30000 -C oui ;
  add ::1 ::1 ipcomp 30001 -C deflate ;
  #add ::1 ::1 ipcomp 30002 -C lzs ;
  
  # enjoy.
diff -Nr -c25 ac_am/src/setkey/setkey.8 ac_am_fixed/src/setkey/setkey.8
*** ac_am/src/setkey/setkey.8	2003-03-04 00:30:24.000000000 +0100
--- ac_am_fixed/src/setkey/setkey.8	2003-12-11 18:19:59.274037096 +0100
***************
*** 16,145 ****
  .\"    without specific prior written permission.
  .\"
  .\" THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
  .\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  .\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  .\" ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
  .\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  .\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  .\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  .\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  .\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  .\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  .\" SUCH DAMAGE.
  .\"
  .Dd November 20, 2000
  .Dt SETKEY 8
  .Os KAME
  .\"
  .Sh NAME
  .Nm setkey
  .Nd manually manipulate the IPsec SA/SP database
  .\"
  .Sh SYNOPSIS
  .Nm setkey
  .Op Fl v
  .Fl c
  .Nm setkey
  .Op Fl v
  .Fl f Ar filename
  .Nm setkey
  .Op Fl aPlv
  .Fl D
  .Nm setkey
  .Op Fl Pv
  .Fl F
  .Nm setkey
  .Op Fl h
  .Fl x
  .\"
  .Sh DESCRIPTION
  .Nm
  adds, updates, dumps, or flushes
  Security Association Database (SAD) entries
  as well as Security Policy Database (SPD) entries in the kernel.
  .Pp
  .Nm
  takes a series of operations from the standard input
  .Po
  if invoked with
  .Fl c
  .Pc
  or the file named
  .Ar filename
  .Po
  if invoked with
  .Fl f Ar filename
  .Pc .
  .Bl -tag -width Ds
  .It Fl D
  Dump the SAD entries.
  If with
  .Fl P ,
  the SPD entries are dumped.
  .It Fl F
  Flush the SAD entries.
  If with
  .Fl P ,
  the SPD entries are flushed.
  .It Fl a
  .Nm
  usually does not display dead SAD entries with
  .Fl D .
  If with
  .Fl a ,
  the dead SAD entries will be displayed as well.
  A dead SAD entry means that
  it has been expired but remains in the system
  because it is referenced by some SPD entries.
  .It Fl h
  Add hexadecimal dump on
  .Fl x
  mode.
  .It Fl l
  Loop forever with short output on
  .Fl D .
  .It Fl v
  Be verbose.
  The program will dump messages exchanged on
  .Dv PF_KEY
  socket, including messages sent from other processes to the kernel.
  .It Fl x
  Loop forever and dump all the messages transmitted to
  .Dv PF_KEY
  socket.
  .Fl xx
  makes each timestamps unformatted.
  .El
  .Ss Configuration syntax
  With
  .Fl c
  or
  .Fl f
  on the command line,
  .Nm
! accepts the following configuration sytnax.
  Lines starting with hash signs ('#') are treated as comment lines.
  .Bl -tag -width Ds
  .It Xo
  .Li add
  .Op Fl 46n
  .Ar src Ar dst Ar protocol Ar spi
  .Op Ar extensions
  .Ar algorithm ...
  .Li ;
  .Xc
  Add an SAD entry.
  .Li add
  can fail with multiple reasons,
  including when the key length does not match the specified algorithm.
  .\"
  .It Xo
  .Li get
  .Op Fl 46n
  .Ar src Ar dst Ar protocol Ar spi
  .Li ;
  .Xc
  Show an SAD entry.
  .\"
  .It Xo
  .Li delete
--- 16,151 ----
  .\"    without specific prior written permission.
  .\"
  .\" THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
  .\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  .\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  .\" ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
  .\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  .\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  .\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  .\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  .\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  .\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  .\" SUCH DAMAGE.
  .\"
  .Dd November 20, 2000
  .Dt SETKEY 8
  .Os KAME
  .\"
  .Sh NAME
  .Nm setkey
  .Nd manually manipulate the IPsec SA/SP database
  .\"
  .Sh SYNOPSIS
  .Nm setkey
  .Op Fl v
+ .Ar file ...
+ .Nm setkey
+ .Op Fl v
  .Fl c
  .Nm setkey
  .Op Fl v
  .Fl f Ar filename
  .Nm setkey
  .Op Fl aPlv
  .Fl D
  .Nm setkey
  .Op Fl Pv
  .Fl F
  .Nm setkey
  .Op Fl h
  .Fl x
  .\"
  .Sh DESCRIPTION
  .Nm
  adds, updates, dumps, or flushes
  Security Association Database (SAD) entries
  as well as Security Policy Database (SPD) entries in the kernel.
  .Pp
  .Nm
  takes a series of operations from the standard input
  .Po
  if invoked with
  .Fl c
  .Pc
  or the file named
  .Ar filename
  .Po
  if invoked with
  .Fl f Ar filename
  .Pc .
  .Bl -tag -width Ds
+ .It (no flag)
+ Dump the SAD entries or SPD entries contained in the specified
+ .Ar file .
  .It Fl D
  Dump the SAD entries.
  If with
  .Fl P ,
  the SPD entries are dumped.
  .It Fl F
  Flush the SAD entries.
  If with
  .Fl P ,
  the SPD entries are flushed.
  .It Fl a
  .Nm
  usually does not display dead SAD entries with
  .Fl D .
  If with
  .Fl a ,
  the dead SAD entries will be displayed as well.
  A dead SAD entry means that
  it has been expired but remains in the system
  because it is referenced by some SPD entries.
  .It Fl h
  Add hexadecimal dump on
  .Fl x
  mode.
  .It Fl l
  Loop forever with short output on
  .Fl D .
  .It Fl v
  Be verbose.
  The program will dump messages exchanged on
  .Dv PF_KEY
  socket, including messages sent from other processes to the kernel.
  .It Fl x
  Loop forever and dump all the messages transmitted to
  .Dv PF_KEY
  socket.
  .Fl xx
  makes each timestamps unformatted.
  .El
  .Ss Configuration syntax
  With
  .Fl c
  or
  .Fl f
  on the command line,
  .Nm
! accepts the following configuration syntax.
  Lines starting with hash signs ('#') are treated as comment lines.
  .Bl -tag -width Ds
  .It Xo
  .Li add
  .Op Fl 46n
  .Ar src Ar dst Ar protocol Ar spi
  .Op Ar extensions
  .Ar algorithm ...
  .Li ;
  .Xc
  Add an SAD entry.
  .Li add
  can fail with multiple reasons,
  including when the key length does not match the specified algorithm.
  .\"
  .It Xo
  .Li get
  .Op Fl 46n
  .Ar src Ar dst Ar protocol Ar spi
  .Li ;
  .Xc
  Show an SAD entry.
  .\"
  .It Xo
  .Li delete
***************
*** 218,268 ****
  IPv4/v6 address.
  .Nm
  can resolve a FQDN into numeric addresses.
  If the FQDN resolves into multiple addresses,
  .Nm
  will install multiple SAD/SPD entries into the kernel
  by trying all possible combinations.
  .Fl 4 ,
  .Fl 6
  and
  .Fl n
  restricts the address resolution of FQDN in certain ways.
  .Fl 4
  and
  .Fl 6
  restrict results into IPv4/v6 addresses only, respectively.
  .Fl n
  avoids FQDN resolution and requires addresses to be numeric addresses.
  .\"
  .Pp
  .It Ar protocol
  .Ar protocol
  is one of following:
  .Bl -tag -width Fl -compact
  .It Li esp
! ESP based on rfc2405
  .It Li esp-old
  ESP based on rfc1827
  .It Li ah
  AH based on rfc2402
  .It Li ah-old
  AH based on rfc1826
  .It Li ipcomp
  IPComp
  .El
  .\"
  .Pp
  .It Ar spi
  Security Parameter Index
  .Pq SPI
  for the SAD and the SPD.
  .Ar spi
  must be a decimal number, or a hexadecimal number with
  .Dq Li 0x
  prefix.
  SPI values between 0 and 255 are reserved for future use by IANA
  and they cannot be used.
  .\"
  .Pp
  .It Ar extensions
  take some of the following:
--- 224,274 ----
  IPv4/v6 address.
  .Nm
  can resolve a FQDN into numeric addresses.
  If the FQDN resolves into multiple addresses,
  .Nm
  will install multiple SAD/SPD entries into the kernel
  by trying all possible combinations.
  .Fl 4 ,
  .Fl 6
  and
  .Fl n
  restricts the address resolution of FQDN in certain ways.
  .Fl 4
  and
  .Fl 6
  restrict results into IPv4/v6 addresses only, respectively.
  .Fl n
  avoids FQDN resolution and requires addresses to be numeric addresses.
  .\"
  .Pp
  .It Ar protocol
  .Ar protocol
  is one of following:
  .Bl -tag -width Fl -compact
  .It Li esp
! ESP based on rfc2406
  .It Li esp-old
  ESP based on rfc1827
  .It Li ah
  AH based on rfc2402
  .It Li ah-old
  AH based on rfc1826
  .It Li ipcomp
  IPComp
  .El
  .\"
  .Pp
  .It Ar spi
  Security Parameter Index
  .Pq SPI
  for the SAD and the SPD.
  .Ar spi
  must be a decimal number, or a hexadecimal number with
  .Dq Li 0x
  prefix.
  SPI values between 0 and 255 are reserved for future use by IANA
  and they cannot be used.
  .\"
  .Pp
  .It Ar extensions
  take some of the following:
***************
*** 303,353 ****
  .It Li seq-pad
  A series of sequential increasing numbers started from 1 are set.
  .El
  .\"
  .It Fl f Li nocyclic-seq
  Don't allow cyclic sequence number.
  .\"
  .It Fl lh Ar time
  .It Fl ls Ar time
  Specify hard/soft life time duration of the SA.
  .El
  .\"
  .Pp
  .It Ar algorithm
  .Bl -tag -width Fl -compact
  .It Fl E Ar ealgo Ar key
  Specify a encryption algorithm
  .Ar ealgo
  for ESP.
  .It Xo
  .Fl E Ar ealgo Ar key
  .Fl A Ar aalgo Ar key
  .Xc
  Specify a encryption algorithm
  .Ar ealgo ,
! as well as a payload authentication algorith
  .Ar aalgo ,
  for ESP.
  .It Fl A Ar aalgo Ar key
  Specify an authentication algorithm for AH.
  .It Fl C Ar calgo Op Fl R
  Specify a compression algorithm for IPComp.
  If
  .Fl R
  is specified,
  .Ar spi
  field value will be used as the IPComp CPI
  .Pq compression parameter index
  on wire as is.
  If
  .Fl R
  is not specified,
  the kernel will use well-known CPI on wire, and
  .Ar spi
  field will be used only as an index for kernel internal usage.
  .El
  .Pp
  .Ar key
  must be double-quoted character string, or a series of hexadecimal digits
  preceded by
  .Dq Li 0x .
--- 309,359 ----
  .It Li seq-pad
  A series of sequential increasing numbers started from 1 are set.
  .El
  .\"
  .It Fl f Li nocyclic-seq
  Don't allow cyclic sequence number.
  .\"
  .It Fl lh Ar time
  .It Fl ls Ar time
  Specify hard/soft life time duration of the SA.
  .El
  .\"
  .Pp
  .It Ar algorithm
  .Bl -tag -width Fl -compact
  .It Fl E Ar ealgo Ar key
  Specify a encryption algorithm
  .Ar ealgo
  for ESP.
  .It Xo
  .Fl E Ar ealgo Ar key
  .Fl A Ar aalgo Ar key
  .Xc
  Specify a encryption algorithm
  .Ar ealgo ,
! as well as a payload authentication algorithm
  .Ar aalgo ,
  for ESP.
  .It Fl A Ar aalgo Ar key
  Specify an authentication algorithm for AH.
  .It Fl C Ar calgo Op Fl R
  Specify a compression algorithm for IPComp.
  If
  .Fl R
  is specified,
  .Ar spi
  field value will be used as the IPComp CPI
  .Pq compression parameter index
  on wire as is.
  If
  .Fl R
  is not specified,
  the kernel will use well-known CPI on wire, and
  .Ar spi
  field will be used only as an index for kernel internal usage.
  .El
  .Pp
  .Ar key
  must be double-quoted character string, or a series of hexadecimal digits
  preceded by
  .Dq Li 0x .
***************
*** 402,482 ****
  can be specified.
  .Li any
  stands for
  .Dq any protocol .
  Also you can use the protocol number.
  You can specify a type and/or a code of ICMPv6 when
  Upper-layer protocol is ICMPv6.
  the specification can be placed after
  .Li icmp6 .
  A type is separated with a code by single comma.
  A code must be specified anytime.
  When a zero is specified, the kernel deals with it as a wildcard.
  Note that the kernel can not distinguish a wildcard from that a type
  of ICMPv6 is zero.
  For example, the following means the policy doesn't require IPsec
  for any inbound Neighbor Solicitation.
  .Dl spdadd ::/0 ::/0 icmp6 135,0 -P in none ;
  .Pp
  NOTE:
  .Ar upperspec
  does not work against forwarding case at this moment,
  as it requires extra reassembly at forwarding node
  .Pq not implemented at this moment .
  We have many protocols in
  .Pa /etc/protocols ,
! but protocols except of TCP, UDP and ICMP may not be suitable to use with IPSec.
  You have to consider and be careful to use them.
  .\"
  .Pp
  .It Ar policy
  .Ar policy
  is the one of the following three formats:
  .Bd -literal -offset indent
  .It Fl P Ar direction Li discard
  .It Fl P Ar direction Li none
  .It Xo Fl P Ar direction Li ipsec
  .Ar protocol/mode/src-dst/level Op ...
  .Xc
  .Ed
  .Pp
  You must specify the direction of its policy as
  .Ar direction .
  Either
  .Li out
  or
  .Li in
  are used.
  .Li discard
  means the packet matching indexes will be discarded.
  .Li none
  means that IPsec operation will not take place onto the packet.
  .Li ipsec
  means that IPsec operation will take place onto the packet.
  The part of
  .Ar protocol/mode/src-dst/level
! specifies the rule how to process the packet .
  Either
  .Li ah ,
  .Li esp
  or
  .Li ipcomp
  is to be set as
  .Ar protocol .
  .Ar mode
  is either
  .Li transport
  or
  .Li tunnel .
  If
  .Ar mode
  is
  .Li tunnel ,
  you must specify the end-points addresses of the SA as
  .Ar src
  and
  .Ar dst
  with
  .Sq -
  between these addresses which is used to specify the SA to use.
  If
  .Ar mode
--- 408,488 ----
  can be specified.
  .Li any
  stands for
  .Dq any protocol .
  Also you can use the protocol number.
  You can specify a type and/or a code of ICMPv6 when
  Upper-layer protocol is ICMPv6.
  the specification can be placed after
  .Li icmp6 .
  A type is separated with a code by single comma.
  A code must be specified anytime.
  When a zero is specified, the kernel deals with it as a wildcard.
  Note that the kernel can not distinguish a wildcard from that a type
  of ICMPv6 is zero.
  For example, the following means the policy doesn't require IPsec
  for any inbound Neighbor Solicitation.
  .Dl spdadd ::/0 ::/0 icmp6 135,0 -P in none ;
  .Pp
  NOTE:
  .Ar upperspec
  does not work against forwarding case at this moment,
  as it requires extra reassembly at forwarding node
  .Pq not implemented at this moment .
  We have many protocols in
  .Pa /etc/protocols ,
! but protocols except of TCP, UDP and ICMP may not be suitable to use with IPsec.
  You have to consider and be careful to use them.
  .\"
  .Pp
  .It Ar policy
  .Ar policy
  is the one of the following three formats:
  .Bd -literal -offset indent
  .It Fl P Ar direction Li discard
  .It Fl P Ar direction Li none
  .It Xo Fl P Ar direction Li ipsec
  .Ar protocol/mode/src-dst/level Op ...
  .Xc
  .Ed
  .Pp
  You must specify the direction of its policy as
  .Ar direction .
  Either
  .Li out
  or
  .Li in
  are used.
  .Li discard
  means the packet matching indexes will be discarded.
  .Li none
  means that IPsec operation will not take place onto the packet.
  .Li ipsec
  means that IPsec operation will take place onto the packet.
  The part of
  .Ar protocol/mode/src-dst/level
! specifies the rule how to process the packet.
  Either
  .Li ah ,
  .Li esp
  or
  .Li ipcomp
  is to be set as
  .Ar protocol .
  .Ar mode
  is either
  .Li transport
  or
  .Li tunnel .
  If
  .Ar mode
  is
  .Li tunnel ,
  you must specify the end-points addresses of the SA as
  .Ar src
  and
  .Ar dst
  with
  .Sq -
  between these addresses which is used to specify the SA to use.
  If
  .Ar mode
***************
*** 494,547 ****
  .Li unique .
  If the SA is not available in every level, the kernel will request
  getting SA to the key exchange daemon.
  .Li default
  means the kernel consults to the system wide default against protocol you
  specified, e.g.
  .Li esp_trans_deflev
  sysctl variable, when the kernel processes the packet.
  .Li use
  means that the kernel use a SA if it's available,
  otherwise the kernel keeps normal operation.
  .Li require
  means SA is required whenever the kernel sends a packet matched
  with the policy.
  .Li unique
  is the same to require,
  in addition, it allows the policy to bind with the unique out-bound SA.
  You just specify the policy level
  .Li unique ,
  .Xr racoon 8
  will configure the SA for the policy.
  If you configure the SA by manual keying for that policy,
  you can put the decimal number as the policy identifier after
  .Li unique
  separated by colon
! .Sq \:
  like the following;
  .Li unique:number .
! in order to bind this policy to the SA .
  .Li number
  must be between 1 and 32767.
  It corresponds to
  .Ar extensions Fl u
  of the manual SA configuration.
  When you want to use SA bundle, you can define multiple rules.
  For example, if an IP header was followed by AH header followed by ESP header
  followed by an upper layer protocol header, the rule
  would be:
  .Dl esp/transport//require ah/transport//require ;
  The rule order is very important.
  .Pp
  Note that
  .Dq Li discard
  and
  .Dq Li none
  are not in the syntax described in
  .Xr ipsec_set_policy 3 .
  There are little differences in the syntax.
  See
  .Xr ipsec_set_policy 3
  for detail.
  .Pp
  .El
  .Pp
--- 500,553 ----
  .Li unique .
  If the SA is not available in every level, the kernel will request
  getting SA to the key exchange daemon.
  .Li default
  means the kernel consults to the system wide default against protocol you
  specified, e.g.
  .Li esp_trans_deflev
  sysctl variable, when the kernel processes the packet.
  .Li use
  means that the kernel use a SA if it's available,
  otherwise the kernel keeps normal operation.
  .Li require
  means SA is required whenever the kernel sends a packet matched
  with the policy.
  .Li unique
  is the same to require,
  in addition, it allows the policy to bind with the unique out-bound SA.
  You just specify the policy level
  .Li unique ,
  .Xr racoon 8
  will configure the SA for the policy.
  If you configure the SA by manual keying for that policy,
  you can put the decimal number as the policy identifier after
  .Li unique
  separated by colon
! .Sq \&:
  like the following;
  .Li unique:number .
! in order to bind this policy to the SA.
  .Li number
  must be between 1 and 32767.
  It corresponds to
  .Ar extensions Fl u
  of the manual SA configuration.
  When you want to use SA bundle, you can define multiple rules.
  For example, if an IP header was followed by AH header followed by ESP header
  followed by an upper layer protocol header, the rule
  would be:
  .Dl esp/transport//require ah/transport//require ;
  The rule order is very important.
  .Pp
  Note that
  .Dq Li discard
  and
  .Dq Li none
  are not in the syntax described in
  .Xr ipsec_set_policy 3 .
  There are little differences in the syntax.
  See
  .Xr ipsec_set_policy 3
  for detail.
  .Pp
  .El
  .Pp
***************
*** 549,627 ****
  .Ss Algorithms
  The following list shows the supported algorithms.
  .Sy protocol
  and
  .Sy algorithm
  are almost orthogonal.
  Followings are the list of authentication algorithms that can be used as
  .Ar aalgo
  in
  .Fl A Ar aalgo
  of
  .Ar protocol
  parameter:
  .Pp
  .Bd -literal -offset indent
  algorithm	keylen (bits)
  hmac-md5	128		ah: rfc2403
  		128		ah-old: rfc2085
  hmac-sha1	160		ah: rfc2404
  		160		ah-old: 128bit ICV (no document)
  keyed-md5	128		ah: 96bit ICV (no document)
  		128		ah-old: rfc1828
  keyed-sha1	160		ah: 96bit ICV (no document)
  		160		ah-old: 128bit ICV (no document)
  null		0 to 2048	for debugging
! hmac-sha2-256	256		ah: 96bit ICV (draft-ietf-ipsec-ciph-sha-256-00)
  		256		ah-old: 128bit ICV (no document)
  hmac-sha2-384	384		ah: 96bit ICV (no document)
  		384		ah-old: 128bit ICV (no document)
  hmac-sha2-512	512		ah: 96bit ICV (no document)
  		512		ah-old: 128bit ICV (no document)
  .Ed
  .Pp
  Followings are the list of encryption algorithms that can be used as
  .Ar ealgo
  in
  .Fl E Ar ealgo
  of
  .Ar protocol
  parameter:
  .Pp
  .Bd -literal -offset indent
  algorithm	keylen (bits)
  des-cbc		64		esp-old: rfc1829, esp: rfc2405
  3des-cbc	192		rfc2451
! simple		0 to 2048	rfc2410
  blowfish-cbc	40 to 448	rfc2451
  cast128-cbc	40 to 128	rfc2451
! des-deriv	64		ipsec-ciph-des-derived-01 (expired)
  3des-deriv	192		no document
! rijndael-cbc	128/192/256	draft-ietf-ipsec-ciph-aes-cbc-01
  twofish-cbc	0 to 256	draft-ietf-ipsec-ciph-aes-cbc-01
  .Ed
  .Pp
  Followings are the list of compression algorithms that can be used as
  .Ar calgo
  in
  .Fl C Ar calgo
  of
  .Ar protocol
  parameter:
  .Pp
  .Bd -literal -offset indent
  algorithm
  deflate		rfc2394
  .Ed
  .\"
  .Sh RETURN VALUES
  The command exits with 0 on success, and non-zero on errors.
  .\"
  .Sh EXAMPLES
  .Bd -literal -offset
  add 3ffe:501:4819::1 3ffe:501:481d::1 esp 123457
  	-E des-cbc 0x3ffe05014819ffff ;
  
  add -6 myhost.example.com yourhost.example.com ah 123456
  	-A hmac-sha1 "AH SA configuration!" ;
  
  add 10.0.11.41 10.0.11.33 esp 0x10001
--- 555,643 ----
  .Ss Algorithms
  The following list shows the supported algorithms.
  .Sy protocol
  and
  .Sy algorithm
  are almost orthogonal.
  Followings are the list of authentication algorithms that can be used as
  .Ar aalgo
  in
  .Fl A Ar aalgo
  of
  .Ar protocol
  parameter:
  .Pp
  .Bd -literal -offset indent
  algorithm	keylen (bits)
  hmac-md5	128		ah: rfc2403
  		128		ah-old: rfc2085
  hmac-sha1	160		ah: rfc2404
  		160		ah-old: 128bit ICV (no document)
  keyed-md5	128		ah: 96bit ICV (no document)
  		128		ah-old: rfc1828
  keyed-sha1	160		ah: 96bit ICV (no document)
  		160		ah-old: 128bit ICV (no document)
  null		0 to 2048	for debugging
! hmac-sha2-256	256		ah: 96bit ICV
! 				(draft-ietf-ipsec-ciph-sha-256-00)
  		256		ah-old: 128bit ICV (no document)
  hmac-sha2-384	384		ah: 96bit ICV (no document)
  		384		ah-old: 128bit ICV (no document)
  hmac-sha2-512	512		ah: 96bit ICV (no document)
  		512		ah-old: 128bit ICV (no document)
+ hmac-ripemd160	160		ah: 96bit ICV (RFC2857)
+ 				ah-old: 128bit ICV (no document)
+ aes-xcbc-mac	128		ah: 96bit ICV (RFC3566)
+ 		128		ah-old: 128bit ICV (no document)
  .Ed
  .Pp
  Followings are the list of encryption algorithms that can be used as
  .Ar ealgo
  in
  .Fl E Ar ealgo
  of
  .Ar protocol
  parameter:
  .Pp
  .Bd -literal -offset indent
  algorithm	keylen (bits)
  des-cbc		64		esp-old: rfc1829, esp: rfc2405
  3des-cbc	192		rfc2451
! null		0 to 2048	rfc2410
  blowfish-cbc	40 to 448	rfc2451
  cast128-cbc	40 to 128	rfc2451
! des-deriv	64		ipsec-ciph-des-derived-01
  3des-deriv	192		no document
! rijndael-cbc	128/192/256	rfc3602
  twofish-cbc	0 to 256	draft-ietf-ipsec-ciph-aes-cbc-01
+ aes-ctr		160/224/288	draft-ietf-ipsec-ciph-aes-ctr-03
  .Ed
  .Pp
+ Note that the first 128 bits of a key for
+ .Li aes-ctr
+ will be used as AES key, and remaining 32 bits will be used as nonce.
+ .Pp
  Followings are the list of compression algorithms that can be used as
  .Ar calgo
  in
  .Fl C Ar calgo
  of
  .Ar protocol
  parameter:
  .Pp
  .Bd -literal -offset indent
  algorithm
  deflate		rfc2394
  .Ed
  .\"
  .Sh RETURN VALUES
  The command exits with 0 on success, and non-zero on errors.
  .\"
  .Sh EXAMPLES
  .Bd -literal -offset
  add 3ffe:501:4819::1 3ffe:501:481d::1 esp 123457
  	-E des-cbc 0x3ffe05014819ffff ;
  
  add -6 myhost.example.com yourhost.example.com ah 123456
  	-A hmac-sha1 "AH SA configuration!" ;
  
  add 10.0.11.41 10.0.11.33 esp 0x10001
***************
*** 631,655 ****
--- 647,679 ----
  get 3ffe:501:4819::1 3ffe:501:481d::1 ah 123456 ;
  
  flush ;
  
  dump esp ;
  
  spdadd 10.0.11.41/32[21] 10.0.11.33/32[any] any
  	-P out ipsec esp/tunnel/192.168.0.1-192.168.1.2/require ;
  
  .Ed
  .\"
  .Sh SEE ALSO
  .Xr ipsec_set_policy 3 ,
  .Xr racoon 8 ,
  .Xr sysctl 8
  .\"
  .Sh HISTORY
  The
  .Nm
  command first appeared in WIDE Hydrangea IPv6 protocol stack kit.
  The command was completely re-designed in June 1998.
  .\"
  .Sh BUGS
  .Nm
  should report and handle syntax errors better.
+ .Pp
+ For IPsec gateway configuration,
+ .Ar src_range
+ and
+ .Ar dst_range
+ with TCP/UDP port number do not work, as the gateway does not reassemble
+ packets
+ .Pq cannot inspect upper-layer headers .
diff -Nr -c25 ac_am/src/setkey/setkey.c ac_am_fixed/src/setkey/setkey.c
*** ac_am/src/setkey/setkey.c	2003-03-04 00:56:57.000000000 +0100
--- ac_am_fixed/src/setkey/setkey.c	2003-12-11 18:19:59.279036336 +0100
***************
*** 11,227 ****
   *    notice, this list of conditions and the following disclaimer.
   * 2. Redistributions in binary form must reproduce the above copyright
   *    notice, this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   * 3. Neither the name of the project nor the names of its contributors
   *    may be used to endorse or promote products derived from this software
   *    without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
   * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
   * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
   * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
   * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
   * SUCH DAMAGE.
   */
  
  #include <sys/types.h>
  #include <sys/param.h>
  #include <sys/socket.h>
  #include <sys/time.h>
  #include <err.h>
  #include <netinet/in.h>
  #include <net/pfkeyv2.h>
  #include <netinet/ipsec.h>
  
  #include <stdio.h>
  #include <stdlib.h>
  #include <limits.h>
  #include <string.h>
  #include <ctype.h>
  #include <unistd.h>
  #include <errno.h>
  #include <netdb.h>
  #include <time.h>
  
  #include "libpfkey.h"
  
  #define strlcpy(d,s,l) (strncpy(d,s,l), (d)[(l)-1] = '\0')
  
  void usage __P((void));
  int main __P((int, char **));
  int get_supported __P((void));
  void sendkeyshort __P((u_int));
  void promisc __P((void));
  int sendkeymsg __P((char *, size_t));
  int postproc __P((struct sadb_msg *, int));
  const char *numstr __P((int));
  void shortdump_hdr __P((void));
  void shortdump __P((struct sadb_msg *));
  static void printdate __P((void));
  static int32_t gmt2local __P((time_t));
  
  #define MODE_SCRIPT	1
  #define MODE_CMDDUMP	2
  #define MODE_CMDFLUSH	3
  #define MODE_PROMISC	4
  
  int so;
  
  int f_forever = 0;
  int f_all = 0;
  int f_verbose = 0;
  int f_mode = 0;
  int f_cmddump = 0;
  int f_policy = 0;
  int f_hexdump = 0;
  int f_tflag = 0;
  static time_t thiszone;
  
  extern int lineno;
  
  extern int parse __P((FILE **));
  
  void
  usage()
  {
  
! 	printf("usage: setkey [-v] -c\n");
  	printf("       setkey [-v] -f filename\n");
  	printf("       setkey [-Palv] -D\n");
  	printf("       setkey [-Pv] -F\n");
  	printf("       setkey [-h] -x\n");
  	exit(1);
  }
  
  int
! main(ac, av)
! 	int ac;
! 	char **av;
  {
  	FILE *fp = stdin;
  	int c;
  
! 	if (ac == 1) {
  		usage();
  		/* NOTREACHED */
  	}
  
  	thiszone = gmt2local(0);
  
! 	while ((c = getopt(ac, av, "acdf:hlvxDFP")) != -1) {
  		switch (c) {
  		case 'c':
  			f_mode = MODE_SCRIPT;
  			fp = stdin;
  			break;
  		case 'f':
  			f_mode = MODE_SCRIPT;
  			if ((fp = fopen(optarg, "r")) == NULL) {
! 				err(-1, "fopen");
  				/*NOTREACHED*/
  			}
  			break;
  		case 'D':
  			f_mode = MODE_CMDDUMP;
  			break;
  		case 'F':
  			f_mode = MODE_CMDFLUSH;
  			break;
  		case 'a':
  			f_all = 1;
  			break;
  		case 'l':
  			f_forever = 1;
  			break;
  		case 'h':
  			f_hexdump = 1;
  			break;
  		case 'x':
  			f_mode = MODE_PROMISC;
  			f_tflag++;
  			break;
  		case 'P':
  			f_policy = 1;
  			break;
  		case 'v':
  			f_verbose = 1;
  			break;
  		default:
  			usage();
  			/*NOTREACHED*/
  		}
  	}
  
  	so = pfkey_open();
  	if (so < 0) {
  		perror("pfkey_open");
  		exit(1);
  	}
  
  	switch (f_mode) {
  	case MODE_CMDDUMP:
  		sendkeyshort(f_policy ? SADB_X_SPDDUMP: SADB_DUMP);
  		break;
  	case MODE_CMDFLUSH:
  		sendkeyshort(f_policy ? SADB_X_SPDFLUSH: SADB_FLUSH);
  		break;
  	case MODE_SCRIPT:
  		if (get_supported() < 0) {
! 			errx(-1, "%s", ipsec_strerror());
  			/*NOTREACHED*/
  		}
  		if (parse(&fp))
  			exit (1);
  		break;
  	case MODE_PROMISC:
  		promisc();
  		/*NOTREACHED*/
  	default:
  		usage();
  		/*NOTREACHED*/
  	}
  
  	exit(0);
  }
  
  int
  get_supported()
  {
  
  	if (pfkey_send_register(so, SADB_SATYPE_UNSPEC) < 0)
  		return -1;
  
  	if (pfkey_recv_register(so) < 0)
  		return -1;
  
! 	return 0;
  }
  
  void
  sendkeyshort(type)
          u_int type;
  {
  	struct sadb_msg msg;
  
  	msg.sadb_msg_version = PF_KEY_V2;
  	msg.sadb_msg_type = type;
  	msg.sadb_msg_errno = 0;
  	msg.sadb_msg_satype = SADB_SATYPE_UNSPEC;
  	msg.sadb_msg_len = PFKEY_UNIT64(sizeof(msg));
  	msg.sadb_msg_reserved = 0;
  	msg.sadb_msg_seq = 0;
  	msg.sadb_msg_pid = getpid();
  
  	sendkeymsg((char *)&msg, sizeof(msg));
  
  	return;
  }
  
  void
  promisc()
  {
--- 11,248 ----
   *    notice, this list of conditions and the following disclaimer.
   * 2. Redistributions in binary form must reproduce the above copyright
   *    notice, this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   * 3. Neither the name of the project nor the names of its contributors
   *    may be used to endorse or promote products derived from this software
   *    without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
   * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
   * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
   * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
   * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
   * SUCH DAMAGE.
   */
  
  #include <sys/types.h>
  #include <sys/param.h>
  #include <sys/socket.h>
  #include <sys/time.h>
+ #include <sys/stat.h>
+ #include <sys/sysctl.h>
  #include <err.h>
+ #include <net/route.h>
  #include <netinet/in.h>
  #include <net/pfkeyv2.h>
  #include <netinet/ipsec.h>
  
  #include <stdio.h>
  #include <stdlib.h>
  #include <limits.h>
  #include <string.h>
  #include <ctype.h>
  #include <unistd.h>
  #include <errno.h>
  #include <netdb.h>
+ #include <fcntl.h>
+ #include <dirent.h>
  #include <time.h>
  
  #include "libpfkey.h"
  
  #define strlcpy(d,s,l) (strncpy(d,s,l), (d)[(l)-1] = '\0')
  
  void usage __P((void));
  int main __P((int, char **));
  int get_supported __P((void));
  void sendkeyshort __P((u_int));
  void promisc __P((void));
  int sendkeymsg __P((char *, size_t));
  int postproc __P((struct sadb_msg *, int));
+ int fileproc __P((const char *));
  const char *numstr __P((int));
  void shortdump_hdr __P((void));
  void shortdump __P((struct sadb_msg *));
  static void printdate __P((void));
  static int32_t gmt2local __P((time_t));
  
  #define MODE_SCRIPT	1
  #define MODE_CMDDUMP	2
  #define MODE_CMDFLUSH	3
  #define MODE_PROMISC	4
  
  int so;
  
  int f_forever = 0;
  int f_all = 0;
  int f_verbose = 0;
  int f_mode = 0;
  int f_cmddump = 0;
  int f_policy = 0;
  int f_hexdump = 0;
  int f_tflag = 0;
  static time_t thiszone;
  
  extern int lineno;
  
  extern int parse __P((FILE **));
  
  void
  usage()
  {
  
! 	printf("usage: setkey [-v] file ...\n");
! 	printf("       setkey [-v] -c\n");
  	printf("       setkey [-v] -f filename\n");
  	printf("       setkey [-Palv] -D\n");
  	printf("       setkey [-Pv] -F\n");
  	printf("       setkey [-h] -x\n");
  	exit(1);
  }
  
  int
! main(argc, argv)
! 	int argc;
! 	char **argv;
  {
  	FILE *fp = stdin;
  	int c;
+ 	struct stat sb;
+ 	int error;
  
! 	if (argc == 1) {
  		usage();
  		/* NOTREACHED */
  	}
  
  	thiszone = gmt2local(0);
  
! 	while ((c = getopt(argc, argv, "acdf:hlvxDFP")) != -1) {
  		switch (c) {
  		case 'c':
  			f_mode = MODE_SCRIPT;
  			fp = stdin;
  			break;
  		case 'f':
  			f_mode = MODE_SCRIPT;
  			if ((fp = fopen(optarg, "r")) == NULL) {
! 				err(1, "fopen");
  				/*NOTREACHED*/
  			}
  			break;
  		case 'D':
  			f_mode = MODE_CMDDUMP;
  			break;
  		case 'F':
  			f_mode = MODE_CMDFLUSH;
  			break;
  		case 'a':
  			f_all = 1;
  			break;
  		case 'l':
  			f_forever = 1;
  			break;
  		case 'h':
  			f_hexdump = 1;
  			break;
  		case 'x':
  			f_mode = MODE_PROMISC;
  			f_tflag++;
  			break;
  		case 'P':
  			f_policy = 1;
  			break;
  		case 'v':
  			f_verbose = 1;
  			break;
  		default:
  			usage();
  			/*NOTREACHED*/
  		}
  	}
  
+ 	argc -= optind;
+ 	argv += optind;
+ 
+ 	if (argc > 0) {
+ 		while (argc--)
+ 			if (fileproc(*argv++) < 0) {
+ 				err(1, "%s", argv[-1]);
+ 				/*NOTREACHED*/
+ 			}
+ 		exit(0);
+ 	}
+ 
  	so = pfkey_open();
  	if (so < 0) {
  		perror("pfkey_open");
  		exit(1);
  	}
  
  	switch (f_mode) {
  	case MODE_CMDDUMP:
  		sendkeyshort(f_policy ? SADB_X_SPDDUMP: SADB_DUMP);
  		break;
  	case MODE_CMDFLUSH:
  		sendkeyshort(f_policy ? SADB_X_SPDFLUSH: SADB_FLUSH);
  		break;
  	case MODE_SCRIPT:
  		if (get_supported() < 0) {
! 			errx(1, "%s", ipsec_strerror());
  			/*NOTREACHED*/
  		}
  		if (parse(&fp))
  			exit (1);
  		break;
  	case MODE_PROMISC:
  		promisc();
  		/*NOTREACHED*/
  	default:
  		usage();
  		/*NOTREACHED*/
  	}
  
  	exit(0);
  }
  
  int
  get_supported()
  {
  
  	if (pfkey_send_register(so, SADB_SATYPE_UNSPEC) < 0)
  		return -1;
  
  	if (pfkey_recv_register(so) < 0)
  		return -1;
  
! 	return (0);
  }
  
  void
  sendkeyshort(type)
          u_int type;
  {
  	struct sadb_msg msg;
  
  	msg.sadb_msg_version = PF_KEY_V2;
  	msg.sadb_msg_type = type;
  	msg.sadb_msg_errno = 0;
  	msg.sadb_msg_satype = SADB_SATYPE_UNSPEC;
  	msg.sadb_msg_len = PFKEY_UNIT64(sizeof(msg));
  	msg.sadb_msg_reserved = 0;
  	msg.sadb_msg_seq = 0;
  	msg.sadb_msg_pid = getpid();
  
  	sendkeymsg((char *)&msg, sizeof(msg));
  
  	return;
  }
  
  void
  promisc()
  {
***************
*** 292,507 ****
  sendkeymsg(buf, len)
  	char *buf;
  	size_t len;
  {
  	u_char rbuf[1024 * 32];	/* XXX: Enough ? Should I do MSG_PEEK ? */
  	ssize_t l;
  	struct sadb_msg *msg;
  
      {
  	struct timeval tv;
  	tv.tv_sec = 1;
  	tv.tv_usec = 0;
  	if (setsockopt(so, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
  		perror("setsockopt");
  		goto end;
  	}
      }
  
  	if (f_forever)
  		shortdump_hdr();
  again:
  	if (f_verbose) {
  		kdebug_sadb((struct sadb_msg *)buf);
  		printf("\n");
  	}
  
  	if ((l = send(so, buf, len, 0)) < 0) {
  		perror("send");
  		goto end;
  	}
  
  	msg = (struct sadb_msg *)rbuf;
  	do {
  		if ((l = recv(so, rbuf, sizeof(rbuf), 0)) < 0) {
  			perror("recv");
  			goto end;
  		}
  
  		if (PFKEY_UNUNIT64(msg->sadb_msg_len) != l) {
  			warnx("invalid keymsg length");
  			break;
  		}
  
  		if (f_verbose) {
  			kdebug_sadb((struct sadb_msg *)rbuf);
  			printf("\n");
  		}
  		if (postproc(msg, l) < 0)
  			break;
  	} while (msg->sadb_msg_errno || msg->sadb_msg_seq);
  
  	if (f_forever) {
  		fflush(stdout);
  		sleep(1);
  		goto again;
  	}
  
  end:
! 	return(0);
  }
  
  int
  postproc(msg, len)
  	struct sadb_msg *msg;
  	int len;
  {
  
  	if (msg->sadb_msg_errno != 0) {
  		char inf[80];
  		const char *errmsg = NULL;
  
  		if (f_mode == MODE_SCRIPT)
  			snprintf(inf, sizeof(inf), "The result of line %d: ", lineno);
  		else
  			inf[0] = '\0';
  
  		switch (msg->sadb_msg_errno) {
  		case ENOENT:
  			switch (msg->sadb_msg_type) {
  			case SADB_DELETE:
  			case SADB_GET:
  			case SADB_X_SPDDELETE:
  				errmsg = "No entry";
  				break;
  			case SADB_DUMP:
  				errmsg = "No SAD entries";
  				break;
  			case SADB_X_SPDDUMP:
  				errmsg = "No SPD entries";
  				break;
  			}
  			break;
  		default:
  			errmsg = strerror(msg->sadb_msg_errno);
  		}
  		printf("%s%s.\n", inf, errmsg);
! 		return(-1);
  	}
  
  	switch (msg->sadb_msg_type) {
  	case SADB_GET:
  		pfkey_sadump(msg);
  		break;
  
  	case SADB_DUMP:
  		/* filter out DEAD SAs */
  		if (!f_all) {
  			caddr_t mhp[SADB_EXT_MAX + 1];
  			struct sadb_sa *sa;
  			pfkey_align(msg, mhp);
  			pfkey_check(mhp);
  			if ((sa = (struct sadb_sa *)mhp[SADB_EXT_SA]) != NULL) {
  				if (sa->sadb_sa_state == SADB_SASTATE_DEAD)
  					break;
  			}
  		}
  		if (f_forever)
  			shortdump(msg);
  		else
  			pfkey_sadump(msg);
  		msg = (struct sadb_msg *)((caddr_t)msg +
  				     PFKEY_UNUNIT64(msg->sadb_msg_len));
  		if (f_verbose) {
  			kdebug_sadb((struct sadb_msg *)msg);
  			printf("\n");
  		}
  		break;
  
  	case SADB_X_SPDDUMP:
  		pfkey_spdump(msg);
  		if (msg->sadb_msg_seq == 0) break;
  		msg = (struct sadb_msg *)((caddr_t)msg +
  				     PFKEY_UNUNIT64(msg->sadb_msg_len));
  		if (f_verbose) {
  			kdebug_sadb((struct sadb_msg *)msg);
  			printf("\n");
  		}
  		break;
  	}
  
! 	return(0);
  }
  
  /*------------------------------------------------------------*/
  static const char *satype[] = {
  	NULL, NULL, "ah", "esp"
  };
  static const char *sastate[] = {
  	"L", "M", "D", "d"
  };
  static const char *ipproto[] = {
  /*0*/	"ip", "icmp", "igmp", "ggp", "ip4",
  	NULL, "tcp", NULL, "egp", NULL,
  /*10*/	NULL, NULL, NULL, NULL, NULL,
  	NULL, NULL, "udp", NULL, NULL,
  /*20*/	NULL, NULL, "idp", NULL, NULL,
  	NULL, NULL, NULL, NULL, "tp",
  /*30*/	NULL, NULL, NULL, NULL, NULL,
  	NULL, NULL, NULL, NULL, NULL,
  /*40*/	NULL, "ip6", NULL, "rt6", "frag6",
  	NULL, "rsvp", "gre", NULL, NULL,
  /*50*/	"esp", "ah", NULL, NULL, NULL,
  	NULL, NULL, NULL, "icmp6", "none",
  /*60*/	"dst6",
  };
  
  #define STR_OR_ID(x, tab) \
  	(((x) < sizeof(tab)/sizeof(tab[0]) && tab[(x)])	? tab[(x)] : numstr(x))
  
  const char *
  numstr(x)
  	int x;
  {
  	static char buf[20];
  	snprintf(buf, sizeof(buf), "#%d", x);
  	return buf;
  }
  
  void
  shortdump_hdr()
  {
  	printf("%-4s %-3s %-1s %-8s %-7s %s -> %s\n",
  		"time", "p", "s", "spi", "ltime", "src", "dst");
  }
  
  void
  shortdump(msg)
  	struct sadb_msg *msg;
  {
  	caddr_t mhp[SADB_EXT_MAX + 1];
! 	char buf[1024], pbuf[10];
  	struct sadb_sa *sa;
  	struct sadb_address *saddr;
  	struct sadb_lifetime *lts, *lth, *ltc;
  	struct sockaddr *s;
  	u_int t;
  	time_t cur = time(0);
  
  	pfkey_align(msg, mhp);
  	pfkey_check(mhp);
  
  	printf("%02lu%02lu", (u_long)(cur % 3600) / 60, (u_long)(cur % 60));
  
  	printf(" %-3s", STR_OR_ID(msg->sadb_msg_satype, satype));
  
  	if ((sa = (struct sadb_sa *)mhp[SADB_EXT_SA]) != NULL) {
  		printf(" %-1s", STR_OR_ID(sa->sadb_sa_state, sastate));
  		printf(" %08x", (u_int32_t)ntohl(sa->sadb_sa_spi));
  	} else
  		printf("%-1s %-8s", "?", "?");
  
  	lts = (struct sadb_lifetime *)mhp[SADB_EXT_LIFETIME_SOFT];
  	lth = (struct sadb_lifetime *)mhp[SADB_EXT_LIFETIME_HARD];
  	ltc = (struct sadb_lifetime *)mhp[SADB_EXT_LIFETIME_CURRENT];
  	if (lts && lth && ltc) {
  		if (ltc->sadb_lifetime_addtime == 0)
--- 313,590 ----
  sendkeymsg(buf, len)
  	char *buf;
  	size_t len;
  {
  	u_char rbuf[1024 * 32];	/* XXX: Enough ? Should I do MSG_PEEK ? */
  	ssize_t l;
  	struct sadb_msg *msg;
  
      {
  	struct timeval tv;
  	tv.tv_sec = 1;
  	tv.tv_usec = 0;
  	if (setsockopt(so, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
  		perror("setsockopt");
  		goto end;
  	}
      }
  
  	if (f_forever)
  		shortdump_hdr();
  again:
  	if (f_verbose) {
  		kdebug_sadb((struct sadb_msg *)buf);
  		printf("\n");
  	}
+ 	if (f_hexdump) {
+ 		int i;
+ 		for (i = 0; i < len; i++) {
+ 			if (i % 16 == 0)
+ 				printf("%08x: ", i);
+ 			printf("%02x ", buf[i] & 0xff);
+ 			if (i % 16 == 15)
+ 				printf("\n");
+ 		}
+ 		if (len % 16)
+ 			printf("\n");
+ 	}
  
  	if ((l = send(so, buf, len, 0)) < 0) {
  		perror("send");
  		goto end;
  	}
  
  	msg = (struct sadb_msg *)rbuf;
  	do {
  		if ((l = recv(so, rbuf, sizeof(rbuf), 0)) < 0) {
  			perror("recv");
  			goto end;
  		}
  
  		if (PFKEY_UNUNIT64(msg->sadb_msg_len) != l) {
  			warnx("invalid keymsg length");
  			break;
  		}
  
  		if (f_verbose) {
  			kdebug_sadb((struct sadb_msg *)rbuf);
  			printf("\n");
  		}
  		if (postproc(msg, l) < 0)
  			break;
  	} while (msg->sadb_msg_errno || msg->sadb_msg_seq);
  
  	if (f_forever) {
  		fflush(stdout);
  		sleep(1);
  		goto again;
  	}
  
  end:
! 	return (0);
  }
  
  int
  postproc(msg, len)
  	struct sadb_msg *msg;
  	int len;
  {
  
  	if (msg->sadb_msg_errno != 0) {
  		char inf[80];
  		const char *errmsg = NULL;
  
  		if (f_mode == MODE_SCRIPT)
  			snprintf(inf, sizeof(inf), "The result of line %d: ", lineno);
  		else
  			inf[0] = '\0';
  
  		switch (msg->sadb_msg_errno) {
  		case ENOENT:
  			switch (msg->sadb_msg_type) {
  			case SADB_DELETE:
  			case SADB_GET:
  			case SADB_X_SPDDELETE:
  				errmsg = "No entry";
  				break;
  			case SADB_DUMP:
  				errmsg = "No SAD entries";
  				break;
  			case SADB_X_SPDDUMP:
  				errmsg = "No SPD entries";
  				break;
  			}
  			break;
  		default:
  			errmsg = strerror(msg->sadb_msg_errno);
  		}
  		printf("%s%s.\n", inf, errmsg);
! 		return (-1);
  	}
  
  	switch (msg->sadb_msg_type) {
  	case SADB_GET:
  		pfkey_sadump(msg);
  		break;
  
  	case SADB_DUMP:
  		/* filter out DEAD SAs */
  		if (!f_all) {
  			caddr_t mhp[SADB_EXT_MAX + 1];
  			struct sadb_sa *sa;
  			pfkey_align(msg, mhp);
  			pfkey_check(mhp);
  			if ((sa = (struct sadb_sa *)mhp[SADB_EXT_SA]) != NULL) {
  				if (sa->sadb_sa_state == SADB_SASTATE_DEAD)
  					break;
  			}
  		}
  		if (f_forever)
  			shortdump(msg);
  		else
  			pfkey_sadump(msg);
  		msg = (struct sadb_msg *)((caddr_t)msg +
  				     PFKEY_UNUNIT64(msg->sadb_msg_len));
  		if (f_verbose) {
  			kdebug_sadb((struct sadb_msg *)msg);
  			printf("\n");
  		}
  		break;
  
+ 	case SADB_X_SPDGET:
+ 		pfkey_spdump(msg);
+ 		break;
+ 
  	case SADB_X_SPDDUMP:
  		pfkey_spdump(msg);
  		if (msg->sadb_msg_seq == 0) break;
  		msg = (struct sadb_msg *)((caddr_t)msg +
  				     PFKEY_UNUNIT64(msg->sadb_msg_len));
  		if (f_verbose) {
  			kdebug_sadb((struct sadb_msg *)msg);
  			printf("\n");
  		}
  		break;
  	}
  
! 	return (0);
  }
  
+ int
+ fileproc(filename)
+ 	const char *filename;
+ {
+ 	int fd;
+ 	ssize_t len, l;
+ 	u_char *p, *ep;
+ 	struct sadb_msg *msg;
+ 	u_char rbuf[1024 * 32];	/* XXX: Enough ? Should I do MSG_PEEK ? */
+ 
+ 	fd = open(filename, O_RDONLY);
+ 	if (fd < 0)
+ 		return -1;
+ 
+ 	l = 0;
+ 	while (1) {
+ 		len = read(fd, rbuf + l, sizeof(rbuf) - l);
+ 		if (len < 0) {
+ 			close(fd);
+ 			return -1;
+ 		} else if (len == 0)
+ 			break;
+ 		l += len;
+ 	}
+ 
+ 	if (l < sizeof(struct sadb_msg)) {
+ 		close(fd);
+ 		errno = EINVAL;
+ 		return -1;
+ 	}
+ 	close(fd);
+ 
+ 	p = rbuf;
+ 	ep = rbuf + l;
+ 
+ 	while (p < ep) {
+ 		msg = (struct sadb_msg *)p;
+ 		len = PFKEY_UNUNIT64(msg->sadb_msg_len);
+ 		postproc(msg, len);
+ 		p += len;
+ 	}
+ 
+ 	return (0);
+ }
+ 
+ 
  /*------------------------------------------------------------*/
  static const char *satype[] = {
  	NULL, NULL, "ah", "esp"
  };
  static const char *sastate[] = {
  	"L", "M", "D", "d"
  };
  static const char *ipproto[] = {
  /*0*/	"ip", "icmp", "igmp", "ggp", "ip4",
  	NULL, "tcp", NULL, "egp", NULL,
  /*10*/	NULL, NULL, NULL, NULL, NULL,
  	NULL, NULL, "udp", NULL, NULL,
  /*20*/	NULL, NULL, "idp", NULL, NULL,
  	NULL, NULL, NULL, NULL, "tp",
  /*30*/	NULL, NULL, NULL, NULL, NULL,
  	NULL, NULL, NULL, NULL, NULL,
  /*40*/	NULL, "ip6", NULL, "rt6", "frag6",
  	NULL, "rsvp", "gre", NULL, NULL,
  /*50*/	"esp", "ah", NULL, NULL, NULL,
  	NULL, NULL, NULL, "icmp6", "none",
  /*60*/	"dst6",
  };
  
  #define STR_OR_ID(x, tab) \
  	(((x) < sizeof(tab)/sizeof(tab[0]) && tab[(x)])	? tab[(x)] : numstr(x))
  
  const char *
  numstr(x)
  	int x;
  {
  	static char buf[20];
  	snprintf(buf, sizeof(buf), "#%d", x);
  	return buf;
  }
  
  void
  shortdump_hdr()
  {
  	printf("%-4s %-3s %-1s %-8s %-7s %s -> %s\n",
  		"time", "p", "s", "spi", "ltime", "src", "dst");
  }
  
  void
  shortdump(msg)
  	struct sadb_msg *msg;
  {
  	caddr_t mhp[SADB_EXT_MAX + 1];
! 	char buf[NI_MAXHOST], pbuf[NI_MAXSERV];
  	struct sadb_sa *sa;
  	struct sadb_address *saddr;
  	struct sadb_lifetime *lts, *lth, *ltc;
  	struct sockaddr *s;
  	u_int t;
  	time_t cur = time(0);
  
  	pfkey_align(msg, mhp);
  	pfkey_check(mhp);
  
  	printf("%02lu%02lu", (u_long)(cur % 3600) / 60, (u_long)(cur % 60));
  
  	printf(" %-3s", STR_OR_ID(msg->sadb_msg_satype, satype));
  
  	if ((sa = (struct sadb_sa *)mhp[SADB_EXT_SA]) != NULL) {
  		printf(" %-1s", STR_OR_ID(sa->sadb_sa_state, sastate));
  		printf(" %08x", (u_int32_t)ntohl(sa->sadb_sa_spi));
  	} else
  		printf("%-1s %-8s", "?", "?");
  
  	lts = (struct sadb_lifetime *)mhp[SADB_EXT_LIFETIME_SOFT];
  	lth = (struct sadb_lifetime *)mhp[SADB_EXT_LIFETIME_HARD];
  	ltc = (struct sadb_lifetime *)mhp[SADB_EXT_LIFETIME_CURRENT];
  	if (lts && lth && ltc) {
  		if (ltc->sadb_lifetime_addtime == 0)
diff -Nr -c25 ac_am/src/setkey/test-pfkey.c ac_am_fixed/src/setkey/test-pfkey.c
*** ac_am/src/setkey/test-pfkey.c	2003-02-26 22:30:54.000000000 +0100
--- ac_am_fixed/src/setkey/test-pfkey.c	2003-12-11 18:19:59.281036032 +0100
***************
*** 14,65 ****
   *    documentation and/or other materials provided with the distribution.
   * 3. Neither the name of the project nor the names of its contributors
   *    may be used to endorse or promote products derived from this software
   *    without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
   * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
   * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
   * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
   * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
   * SUCH DAMAGE.
   */
  
  #include <sys/types.h>
  #include <sys/param.h>
  #include <sys/socket.h>
  #include <net/route.h>
  #include <net/pfkeyv2.h>
  #include <netinet/in.h>
  #include <netkey/keydb.h>
- #include <netkey/key_var.h>
- #include <netkey/key_debug.h>
  
  #include <stdio.h>
  #include <stdlib.h>
  #include <limits.h>
  #include <string.h>
  #include <ctype.h>
  #include <unistd.h>
  #include <errno.h>
  #include <netdb.h>
  
  u_char m_buf[BUFSIZ];
  u_int m_len;
  char *pname;
  
  void Usage __P((void));
  int sendkeymsg __P((void));
  void key_setsadbmsg __P((u_int));
  void key_setsadbsens __P((void));
  void key_setsadbprop __P((void));
  void key_setsadbid __P((u_int, caddr_t));
  void key_setsadblft __P((u_int, u_int));
  void key_setspirange __P((void));
  void key_setsadbkey __P((u_int, caddr_t));
  void key_setsadbsa __P((void));
  void key_setsadbaddr __P((u_int, u_int, caddr_t));
--- 14,63 ----
diff -Nr -c25 ac_am/src/setkey/token.l ac_am_fixed/src/setkey/token.l
*** ac_am/src/setkey/token.l	2003-02-28 00:45:58.000000000 +0100
--- ac_am_fixed/src/setkey/token.l	2003-12-11 18:19:59.288034968 +0100
***************
*** 11,267 ****
   *    notice, this list of conditions and the following disclaimer.
   * 2. Redistributions in binary form must reproduce the above copyright
   *    notice, this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   * 3. Neither the name of the project nor the names of its contributors
   *    may be used to endorse or promote products derived from this software
   *    without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
   * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
   * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
   * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
   * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
   * SUCH DAMAGE.
   */
  
  %{
  #include <sys/types.h>
  #include <sys/param.h>
  #include <sys/socket.h>
  #include <net/pfkeyv2.h>
  #include <netinet/in.h>
  #include <netinet/ipsec.h>
  
  #include <stdlib.h>
  #include <limits.h>
  #include <string.h>
  #include <unistd.h>
  #include <errno.h>
  #include <netdb.h>
  
  #include "vchar.h"
  #if defined(__NetBSD__) || defined(__linux__)
  #include "parse.h"
  #else
  #include "y.tab.h"
  #endif
  
  int lineno = 1;
  
  extern u_char m_buf[BUFSIZ];
  extern u_int m_len;
  extern int f_debug;
  
  int yylex __P((void));
  void yyfatal __P((const char *s));
  void yyerror __P((const char *s));
  extern void parse_init __P((void));
  int parse __P((FILE **));
  int yyparse __P((void));
  
  /* make the code compile on *BSD-current */
  #ifndef SADB_X_AALG_SHA2_256
  #define SADB_X_AALG_SHA2_256	(-1)
  #endif
  #ifndef SADB_X_AALG_SHA2_384
  #define SADB_X_AALG_SHA2_384	(-1)
  #endif
  #ifndef SADB_X_AALG_SHA2_512
  #define SADB_X_AALG_SHA2_512	(-1)
  #endif
  #ifndef SADB_X_EALG_TWOFISHCBC
  #define SADB_X_EALG_TWOFISHCBC	(-1)
  #endif
  %}
  
  /* common section */
  nl		\n
  ws		[ \t]+
  digit		[0-9]
  letter		[0-9A-Za-z]
  hexdigit	[0-9A-Fa-f]
  dot		\.
  hyphen		\-
  slash		\/
  blcl		\[
  elcl		\]
  semi		\;
  comment		\#.*
  quotedstring	\"[^"]*\"
  decstring	{digit}+
  hexstring	0[xX]{hexdigit}+
  ipaddress	[a-fA-F0-9:]([a-fA-F0-9:\.]*|[a-fA-F0-9:\.]*%[a-zA-Z0-9]*)
  ipaddrmask	{slash}{digit}{1,3}
  name		{letter}(({letter}|{digit}|{hyphen})*({letter}|{digit}))*
  hostname	{name}(({dot}{name})+{dot}?)?
  
! %s S_PL
  
  %%
  
  add		{ return(ADD); }
  delete		{ return(DELETE); }
  deleteall	{ return(DELETEALL); }
  get		{ return(GET); }
  flush		{ return(FLUSH); }
  dump		{ return(DUMP); }
  
  	/* for management SPD */
  spdadd		{ return(SPDADD); }
  spddelete	{ return(SPDDELETE); }
  spddump		{ return(SPDDUMP); }
  spdflush	{ return(SPDFLUSH); }
  {hyphen}P	{ BEGIN S_PL; return(F_POLICY); }
! <S_PL>[a-zA-Z0-9:\.\-_/ \n\t][a-zA-Z0-9:\.\-_/ \n\t]* {
  			yymore();
  
  			/* count up for nl */
  			    {
  				char *p;
  				for (p = yytext; *p != '\0'; p++)
  					if (*p == '\n')
  						lineno++;
  			    }
  
  			yylval.val.len = strlen(yytext);
  			yylval.val.buf = strdup(yytext);
  
  			return(PL_REQUESTS);
  		}
  <S_PL>{semi}	{ BEGIN INITIAL; return(EOT); }
  
  	/* address resolution flags */
  {hyphen}[n46][n46]*	{
  			yylval.val.len = strlen(yytext);
  			yylval.val.buf = strdup(yytext);
  			return(F_AIFLAGS);
  		}
  
  	/* security protocols */
  ah		{ yylval.num = 0; return(PR_AH); }
  esp		{ yylval.num = 0; return(PR_ESP); }
  ah-old		{ yylval.num = 1; return(PR_AH); }
  esp-old		{ yylval.num = 1; return(PR_ESP); }
  ipcomp		{ yylval.num = 0; return(PR_IPCOMP); }
  
  	/* authentication alogorithm */
! {hyphen}A	{ return(F_AUTH); }
! hmac-md5	{ yylval.num = SADB_AALG_MD5HMAC; return(ALG_AUTH); }
! hmac-sha1	{ yylval.num = SADB_AALG_SHA1HMAC; return(ALG_AUTH); }
! keyed-md5	{ yylval.num = SADB_X_AALG_MD5; return(ALG_AUTH); }
! keyed-sha1	{ yylval.num = SADB_X_AALG_SHA; return(ALG_AUTH); }
! hmac-sha2-256	{ yylval.num = SADB_X_AALG_SHA2_256; return(ALG_AUTH); }
! hmac-sha2-384	{ yylval.num = SADB_X_AALG_SHA2_384; return(ALG_AUTH); }
! hmac-sha2-512	{ yylval.num = SADB_X_AALG_SHA2_512; return(ALG_AUTH); }
! null		{ yylval.num = SADB_X_AALG_NULL; return(ALG_AUTH); }
  
  	/* encryption alogorithm */
! {hyphen}E	{ return(F_ENC); }
! des-cbc		{ yylval.num = SADB_EALG_DESCBC; return(ALG_ENC); }
! 3des-cbc	{ yylval.num = SADB_EALG_3DESCBC; return(ALG_ENC); }
! simple		{ yylval.num = SADB_EALG_NULL; return(ALG_ENC); }
! blowfish-cbc	{ yylval.num = SADB_X_EALG_BLOWFISHCBC; return(ALG_ENC); }
! cast128-cbc	{ yylval.num = SADB_X_EALG_CAST128CBC; return(ALG_ENC); }
! des-deriv	{ yylval.num = SADB_EALG_DESCBC; return(ALG_ENC_DESDERIV); }
! des-32iv	{ yylval.num = SADB_EALG_DESCBC; return(ALG_ENC_DES32IV); }
! twofish-cbc	{ yylval.num = SADB_X_EALG_TWOFISHCBC; return(ALG_ENC); }
! rijndael-cbc	{ yylval.num = SADB_X_EALG_RIJNDAELCBC; return(ALG_ENC); }
  
  	/* compression algorithms */
  {hyphen}C	{ return(F_COMP); }
  oui		{ yylval.num = SADB_X_CALG_OUI; return(ALG_COMP); }
  deflate		{ yylval.num = SADB_X_CALG_DEFLATE; return(ALG_COMP); }
  lzs		{ yylval.num = SADB_X_CALG_LZS; return(ALG_COMP); }
  {hyphen}R	{ return(F_RAWCPI); }
  
  	/* extension */
  {hyphen}m	{ return(F_MODE); }
  transport	{ yylval.num = IPSEC_MODE_TRANSPORT; return(MODE); }
  tunnel		{ yylval.num = IPSEC_MODE_TUNNEL; return(MODE); }
  {hyphen}u	{ return(F_REQID); }
  {hyphen}f	{ return(F_EXT); }
  random-pad	{ yylval.num = SADB_X_EXT_PRAND; return(EXTENSION); }
  seq-pad		{ yylval.num = SADB_X_EXT_PSEQ; return(EXTENSION); }
  zero-pad	{ yylval.num = SADB_X_EXT_PZERO; return(EXTENSION); }
  nocyclic-seq	{ return(NOCYCLICSEQ); }
  {hyphen}r	{ return(F_REPLAY); }
  {hyphen}lh	{ return(F_LIFETIME_HARD); }
  {hyphen}ls	{ return(F_LIFETIME_SOFT); }
  
  	/* ... */
  any		{ return(ANY); }
  {ws}		{ }
  {nl}		{ lineno++; }
  {comment}
  {semi}		{ return(EOT); }
  
  	/* for address parameters: /prefix, [port] */
  {slash}		{ return SLASH; }
  {blcl}		{ return BLCL; }
  {elcl}		{ return ELCL; }
  
  	/* parameter */
  {decstring}	{
  			char *bp;
  
  			yylval.ulnum = strtoul(yytext, &bp, 10);
  			return(DECSTRING);
  		}
  
  {hexstring}	{
  			yylval.val.buf = strdup(yytext + 2);
  			yylval.val.len = strlen(yylval.val.buf);
  
  			return(HEXSTRING);
  		}
  
  {quotedstring}	{
  			char *p = yytext;
  			while (*++p != '"') ;
  			*p = '\0';
  			yytext++;
  			yylval.val.len = yyleng - 2;
  			yylval.val.buf = strdup(yytext);
  
  			return(QUOTEDSTRING);
  		}
  
  [A-Za-z0-9:][A-Za-z0-9:%\.-]* {
  			yylval.val.len = yyleng;
  			yylval.val.buf = strdup(yytext);
  			return(STRING);
  		}
  
  [0-9,]+ {
  			yylval.val.len = yyleng;
  			yylval.val.buf = strdup(yytext);
  			return(STRING);
  		}
  
  .		{
  			yyfatal("Syntax error");
  			/*NOTREACHED*/
  		}
  
  %%
  
  void
  yyfatal(s)
  	const char *s;
  {
  	yyerror(s);
  	exit(1);
  }
  
  void
  yyerror(s)
  	const char *s;
  {
  	printf("line %d: %s at [%s]\n", lineno, s, yytext);
  }
  
--- 11,294 ----
   *    notice, this list of conditions and the following disclaimer.
   * 2. Redistributions in binary form must reproduce the above copyright
   *    notice, this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   * 3. Neither the name of the project nor the names of its contributors
   *    may be used to endorse or promote products derived from this software
   *    without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
   * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
   * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
   * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
   * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
   * SUCH DAMAGE.
   */
  
  %{
  #include <sys/types.h>
  #include <sys/param.h>
  #include <sys/socket.h>
+ #include <net/route.h>
  #include <net/pfkeyv2.h>
  #include <netinet/in.h>
  #include <netinet/ipsec.h>
  
  #include <stdlib.h>
  #include <limits.h>
  #include <string.h>
  #include <unistd.h>
  #include <errno.h>
  #include <netdb.h>
  
  #include "vchar.h"
  #if defined(__NetBSD__) || defined(__linux__)
  #include "parse.h"
  #else
  #include "y.tab.h"
  #endif
  
  int lineno = 1;
  
  extern u_char m_buf[BUFSIZ];
  extern u_int m_len;
  extern int f_debug;
  
  int yylex __P((void));
  void yyfatal __P((const char *s));
  void yyerror __P((const char *s));
  extern void parse_init __P((void));
  int parse __P((FILE **));
  int yyparse __P((void));
  
  /* make the code compile on *BSD-current */
  #ifndef SADB_X_AALG_SHA2_256
  #define SADB_X_AALG_SHA2_256	(-1)
  #endif
  #ifndef SADB_X_AALG_SHA2_384
  #define SADB_X_AALG_SHA2_384	(-1)
  #endif
  #ifndef SADB_X_AALG_SHA2_512
  #define SADB_X_AALG_SHA2_512	(-1)
  #endif
+ #ifndef SADB_X_AALG_RIPEMD160HMAC
+ #define SADB_X_AALG_RIPEMD160HMAC	(-1)
+ #endif
+ #ifndef SADB_X_AALG_AES_XCBC_MAC
+ #define SADB_X_AALG_AES_XCBC_MAC	(-1)
+ #endif
  #ifndef SADB_X_EALG_TWOFISHCBC
  #define SADB_X_EALG_TWOFISHCBC	(-1)
  #endif
+ #ifndef SADB_X_EALG_AESCTR
+ #define SADB_X_EALG_AESCTR	(-1)
+ #endif
  %}
  
  /* common section */
  nl		\n
  ws		[ \t]+
  digit		[0-9]
  letter		[0-9A-Za-z]
  hexdigit	[0-9A-Fa-f]
  dot		\.
  hyphen		\-
  slash		\/
  blcl		\[
  elcl		\]
  semi		\;
  comment		\#.*
  quotedstring	\"[^"]*\"
  decstring	{digit}+
  hexstring	0[xX]{hexdigit}+
  ipaddress	[a-fA-F0-9:]([a-fA-F0-9:\.]*|[a-fA-F0-9:\.]*%[a-zA-Z0-9]*)
  ipaddrmask	{slash}{digit}{1,3}
  name		{letter}(({letter}|{digit}|{hyphen})*({letter}|{digit}))*
  hostname	{name}(({dot}{name})+{dot}?)?
  
! %s S_PL S_AUTHALG S_ENCALG
  
  %%
  
  add		{ return(ADD); }
  delete		{ return(DELETE); }
  deleteall	{ return(DELETEALL); }
  get		{ return(GET); }
  flush		{ return(FLUSH); }
  dump		{ return(DUMP); }
  
  	/* for management SPD */
  spdadd		{ return(SPDADD); }
  spddelete	{ return(SPDDELETE); }
  spddump		{ return(SPDDUMP); }
  spdflush	{ return(SPDFLUSH); }
+ tagged		{ return(TAGGED); }
  {hyphen}P	{ BEGIN S_PL; return(F_POLICY); }
! <S_PL>[a-zA-Z0-9:\.\-_/ \n\t][a-zA-Z0-9:\.%\-_/ \n\t]* {
  			yymore();
  
  			/* count up for nl */
  			    {
  				char *p;
  				for (p = yytext; *p != '\0'; p++)
  					if (*p == '\n')
  						lineno++;
  			    }
  
  			yylval.val.len = strlen(yytext);
  			yylval.val.buf = strdup(yytext);
+ 			if (!yylval.val.buf)
+ 				yyfatal("insufficient memory");
  
  			return(PL_REQUESTS);
  		}
  <S_PL>{semi}	{ BEGIN INITIAL; return(EOT); }
  
  	/* address resolution flags */
  {hyphen}[n46][n46]*	{
  			yylval.val.len = strlen(yytext);
  			yylval.val.buf = strdup(yytext);
+ 			if (!yylval.val.buf)
+ 				yyfatal("insufficient memory");
  			return(F_AIFLAGS);
  		}
  
  	/* security protocols */
  ah		{ yylval.num = 0; return(PR_AH); }
  esp		{ yylval.num = 0; return(PR_ESP); }
  ah-old		{ yylval.num = 1; return(PR_AH); }
  esp-old		{ yylval.num = 1; return(PR_ESP); }
  ipcomp		{ yylval.num = 0; return(PR_IPCOMP); }
  
  	/* authentication alogorithm */
! {hyphen}A	{ BEGIN S_AUTHALG; return(F_AUTH); }
! <S_AUTHALG>hmac-md5	{ yylval.num = SADB_AALG_MD5HMAC; BEGIN INITIAL; return(ALG_AUTH); }
! <S_AUTHALG>hmac-sha1	{ yylval.num = SADB_AALG_SHA1HMAC; BEGIN INITIAL; return(ALG_AUTH); }
! <S_AUTHALG>keyed-md5	{ yylval.num = SADB_X_AALG_MD5; BEGIN INITIAL; return(ALG_AUTH); }
! <S_AUTHALG>keyed-sha1	{ yylval.num = SADB_X_AALG_SHA; BEGIN INITIAL; return(ALG_AUTH); }
! <S_AUTHALG>hmac-sha2-256 { yylval.num = SADB_X_AALG_SHA2_256; BEGIN INITIAL; return(ALG_AUTH); }
! <S_AUTHALG>hmac-sha2-384 { yylval.num = SADB_X_AALG_SHA2_384; BEGIN INITIAL; return(ALG_AUTH); }
! <S_AUTHALG>hmac-sha2-512 { yylval.num = SADB_X_AALG_SHA2_512; BEGIN INITIAL; return(ALG_AUTH); }
! <S_AUTHALG>hmac-ripemd160 { yylval.num = SADB_X_AALG_RIPEMD160HMAC; BEGIN INITIAL; return(ALG_AUTH); }
! <S_AUTHALG>aes-xcbc-mac { yylval.num = SADB_X_AALG_AES_XCBC_MAC; BEGIN INITIAL; return(ALG_AUTH); }
! <S_AUTHALG>null { yylval.num = SADB_X_AALG_NULL; BEGIN INITIAL; return(ALG_AUTH_NOKEY); }
  
  	/* encryption alogorithm */
! {hyphen}E	{ BEGIN S_ENCALG; return(F_ENC); }
! <S_ENCALG>des-cbc	{ yylval.num = SADB_EALG_DESCBC; BEGIN INITIAL; return(ALG_ENC); }
! <S_ENCALG>3des-cbc	{ yylval.num = SADB_EALG_3DESCBC; BEGIN INITIAL; return(ALG_ENC); }
! <S_ENCALG>null		{ yylval.num = SADB_EALG_NULL; BEGIN INITIAL; return(ALG_ENC_NOKEY); }
! <S_ENCALG>simple	{ yylval.num = SADB_EALG_NULL; BEGIN INITIAL; return(ALG_ENC_OLD); }
! <S_ENCALG>blowfish-cbc	{ yylval.num = SADB_X_EALG_BLOWFISHCBC; BEGIN INITIAL; return(ALG_ENC); }
! <S_ENCALG>cast128-cbc	{ yylval.num = SADB_X_EALG_CAST128CBC; BEGIN INITIAL; return(ALG_ENC); }
! <S_ENCALG>des-deriv	{ yylval.num = SADB_EALG_DESCBC; BEGIN INITIAL; return(ALG_ENC_DESDERIV); }
! <S_ENCALG>des-32iv	{ yylval.num = SADB_EALG_DESCBC; BEGIN INITIAL; return(ALG_ENC_DES32IV); }
! <S_ENCALG>twofish-cbc	{ yylval.num = SADB_X_EALG_TWOFISHCBC; BEGIN INITIAL; return(ALG_ENC); }
! <S_ENCALG>rijndael-cbc	{ yylval.num = SADB_X_EALG_RIJNDAELCBC; BEGIN INITIAL; return(ALG_ENC); }
! <S_ENCALG>aes-ctr	{ yylval.num = SADB_X_EALG_AESCTR; BEGIN INITIAL; return(ALG_ENC); }
  
  	/* compression algorithms */
  {hyphen}C	{ return(F_COMP); }
  oui		{ yylval.num = SADB_X_CALG_OUI; return(ALG_COMP); }
  deflate		{ yylval.num = SADB_X_CALG_DEFLATE; return(ALG_COMP); }
  lzs		{ yylval.num = SADB_X_CALG_LZS; return(ALG_COMP); }
  {hyphen}R	{ return(F_RAWCPI); }
  
  	/* extension */
  {hyphen}m	{ return(F_MODE); }
  transport	{ yylval.num = IPSEC_MODE_TRANSPORT; return(MODE); }
  tunnel		{ yylval.num = IPSEC_MODE_TUNNEL; return(MODE); }
  {hyphen}u	{ return(F_REQID); }
  {hyphen}f	{ return(F_EXT); }
  random-pad	{ yylval.num = SADB_X_EXT_PRAND; return(EXTENSION); }
  seq-pad		{ yylval.num = SADB_X_EXT_PSEQ; return(EXTENSION); }
  zero-pad	{ yylval.num = SADB_X_EXT_PZERO; return(EXTENSION); }
  nocyclic-seq	{ return(NOCYCLICSEQ); }
  {hyphen}r	{ return(F_REPLAY); }
  {hyphen}lh	{ return(F_LIFETIME_HARD); }
  {hyphen}ls	{ return(F_LIFETIME_SOFT); }
  
  	/* ... */
  any		{ return(ANY); }
  {ws}		{ }
  {nl}		{ lineno++; }
  {comment}
  {semi}		{ return(EOT); }
  
  	/* for address parameters: /prefix, [port] */
  {slash}		{ return SLASH; }
  {blcl}		{ return BLCL; }
  {elcl}		{ return ELCL; }
  
  	/* parameter */
  {decstring}	{
  			char *bp;
  
  			yylval.ulnum = strtoul(yytext, &bp, 10);
  			return(DECSTRING);
  		}
  
  {hexstring}	{
  			yylval.val.buf = strdup(yytext + 2);
+ 			if (!yylval.val.buf)
+ 				yyfatal("insufficient memory");
  			yylval.val.len = strlen(yylval.val.buf);
  
  			return(HEXSTRING);
  		}
  
  {quotedstring}	{
  			char *p = yytext;
  			while (*++p != '"') ;
  			*p = '\0';
  			yytext++;
  			yylval.val.len = yyleng - 2;
  			yylval.val.buf = strdup(yytext);
+ 			if (!yylval.val.buf)
+ 				yyfatal("insufficient memory");
  
  			return(QUOTEDSTRING);
  		}
  
  [A-Za-z0-9:][A-Za-z0-9:%\.-]* {
  			yylval.val.len = yyleng;
  			yylval.val.buf = strdup(yytext);
+ 			if (!yylval.val.buf)
+ 				yyfatal("insufficient memory");
  			return(STRING);
  		}
  
  [0-9,]+ {
  			yylval.val.len = yyleng;
  			yylval.val.buf = strdup(yytext);
+ 			if (!yylval.val.buf)
+ 				yyfatal("insufficient memory");
  			return(STRING);
  		}
  
  .		{
  			yyfatal("Syntax error");
  			/*NOTREACHED*/
  		}
  
  %%
  
  void
  yyfatal(s)
  	const char *s;
  {
  	yyerror(s);
  	exit(1);
  }
  
  void
  yyerror(s)
  	const char *s;
  {
  	printf("line %d: %s at [%s]\n", lineno, s, yytext);
  }
  
diff -Nr -c25 ac_am/src/setkey/token.l.orig ac_am_fixed/src/setkey/token.l.orig
*** ac_am/src/setkey/token.l.orig	1970-01-01 01:00:00.000000000 +0100
--- ac_am_fixed/src/setkey/token.l.orig	2003-12-11 18:19:59.291034512 +0100
***************
*** 0 ****
--- 1,282 ----
+ /*	$KAME: token.l,v 1.34 2001/09/25 14:15:24 sakane Exp $	*/
+ 
+ /*
+  * Copyright (C) 1995, 1996, 1997, 1998, and 1999 WIDE Project.
+  * All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions
+  * are met:
+  * 1. Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  * 2. Redistributions in binary form must reproduce the above copyright
+  *    notice, this list of conditions and the following disclaimer in the
+  *    documentation and/or other materials provided with the distribution.
+  * 3. Neither the name of the project nor the names of its contributors
+  *    may be used to endorse or promote products derived from this software
+  *    without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+  * SUCH DAMAGE.
+  */
+ 
+ %{
+ #include <sys/types.h>
+ #include <sys/param.h>
+ #include <sys/socket.h>
+ #include <net/pfkeyv2.h>
+ #include <netinet/in.h>
+ #include <netinet/ipsec.h>
+ 
+ #include <stdlib.h>
+ #include <limits.h>
+ #include <string.h>
+ #include <unistd.h>
+ #include <errno.h>
+ #include <netdb.h>
+ 
+ #include "vchar.h"
+ #if defined(__NetBSD__) || defined(__linux__)
+ #include "parse.h"
+ #else
+ #include "y.tab.h"
+ #endif
+ 
+ int lineno = 1;
+ 
+ extern u_char m_buf[BUFSIZ];
+ extern u_int m_len;
+ extern int f_debug;
+ 
+ int yylex __P((void));
+ void yyfatal __P((const char *s));
+ void yyerror __P((const char *s));
+ extern void parse_init __P((void));
+ int parse __P((FILE **));
+ int yyparse __P((void));
+ 
+ /* make the code compile on *BSD-current */
+ #ifndef SADB_X_AALG_SHA2_256
+ #define SADB_X_AALG_SHA2_256	(-1)
+ #endif
+ #ifndef SADB_X_AALG_SHA2_384
+ #define SADB_X_AALG_SHA2_384	(-1)
+ #endif
+ #ifndef SADB_X_AALG_SHA2_512
+ #define SADB_X_AALG_SHA2_512	(-1)
+ #endif
+ #ifndef SADB_X_EALG_TWOFISHCBC
+ #define SADB_X_EALG_TWOFISHCBC	(-1)
+ #endif
+ %}
+ 
+ /* common section */
+ nl		\n
+ ws		[ \t]+
+ digit		[0-9]
+ letter		[0-9A-Za-z]
+ hexdigit	[0-9A-Fa-f]
+ dot		\.
+ hyphen		\-
+ slash		\/
+ blcl		\[
+ elcl		\]
+ semi		\;
+ comment		\#.*
+ quotedstring	\"[^"]*\"
+ decstring	{digit}+
+ hexstring	0[xX]{hexdigit}+
+ ipaddress	[a-fA-F0-9:]([a-fA-F0-9:\.]*|[a-fA-F0-9:\.]*%[a-zA-Z0-9]*)
+ ipaddrmask	{slash}{digit}{1,3}
+ name		{letter}(({letter}|{digit}|{hyphen})*({letter}|{digit}))*
+ hostname	{name}(({dot}{name})+{dot}?)?
+ 
+ %s S_PL
+ 
+ %%
+ 
+ add		{ return(ADD); }
+ delete		{ return(DELETE); }
+ deleteall	{ return(DELETEALL); }
+ get		{ return(GET); }
+ flush		{ return(FLUSH); }
+ dump		{ return(DUMP); }
+ 
+ 	/* for management SPD */
+ spdadd		{ return(SPDADD); }
+ spddelete	{ return(SPDDELETE); }
+ spddump		{ return(SPDDUMP); }
+ spdflush	{ return(SPDFLUSH); }
+ {hyphen}P	{ BEGIN S_PL; return(F_POLICY); }
+ <S_PL>[a-zA-Z0-9:\.\-_/ \n\t][a-zA-Z0-9:\.\-_/ \n\t]* {
+ 			yymore();
+ 
+ 			/* count up for nl */
+ 			    {
+ 				char *p;
+ 				for (p = yytext; *p != '\0'; p++)
+ 					if (*p == '\n')
+ 						lineno++;
+ 			    }
+ 
+ 			yylval.val.len = strlen(yytext);
+ 			yylval.val.buf = strdup(yytext);
+ 
+ 			return(PL_REQUESTS);
+ 		}
+ <S_PL>{semi}	{ BEGIN INITIAL; return(EOT); }
+ 
+ 	/* address resolution flags */
+ {hyphen}[n46][n46]*	{
+ 			yylval.val.len = strlen(yytext);
+ 			yylval.val.buf = strdup(yytext);
+ 			return(F_AIFLAGS);
+ 		}
+ 
+ 	/* security protocols */
+ ah		{ yylval.num = 0; return(PR_AH); }
+ esp		{ yylval.num = 0; return(PR_ESP); }
+ ah-old		{ yylval.num = 1; return(PR_AH); }
+ esp-old		{ yylval.num = 1; return(PR_ESP); }
+ ipcomp		{ yylval.num = 0; return(PR_IPCOMP); }
+ 
+ 	/* authentication alogorithm */
+ {hyphen}A	{ return(F_AUTH); }
+ hmac-md5	{ yylval.num = SADB_AALG_MD5HMAC; return(ALG_AUTH); }
+ hmac-sha1	{ yylval.num = SADB_AALG_SHA1HMAC; return(ALG_AUTH); }
+ keyed-md5	{ yylval.num = SADB_X_AALG_MD5; return(ALG_AUTH); }
+ keyed-sha1	{ yylval.num = SADB_X_AALG_SHA; return(ALG_AUTH); }
+ hmac-sha2-256	{ yylval.num = SADB_X_AALG_SHA2_256; return(ALG_AUTH); }
+ hmac-sha2-384	{ yylval.num = SADB_X_AALG_SHA2_384; return(ALG_AUTH); }
+ hmac-sha2-512	{ yylval.num = SADB_X_AALG_SHA2_512; return(ALG_AUTH); }
+ null		{ yylval.num = SADB_X_AALG_NULL; return(ALG_AUTH); }
+ 
+ 	/* encryption alogorithm */
+ {hyphen}E	{ return(F_ENC); }
+ des-cbc		{ yylval.num = SADB_EALG_DESCBC; return(ALG_ENC); }
+ 3des-cbc	{ yylval.num = SADB_EALG_3DESCBC; return(ALG_ENC); }
+ simple		{ yylval.num = SADB_EALG_NULL; return(ALG_ENC); }
+ blowfish-cbc	{ yylval.num = SADB_X_EALG_BLOWFISHCBC; return(ALG_ENC); }
+ cast128-cbc	{ yylval.num = SADB_X_EALG_CAST128CBC; return(ALG_ENC); }
+ des-deriv	{ yylval.num = SADB_EALG_DESCBC; return(ALG_ENC_DESDERIV); }
+ des-32iv	{ yylval.num = SADB_EALG_DESCBC; return(ALG_ENC_DES32IV); }
+ twofish-cbc	{ yylval.num = SADB_X_EALG_TWOFISHCBC; return(ALG_ENC); }
+ rijndael-cbc	{ yylval.num = SADB_X_EALG_RIJNDAELCBC; return(ALG_ENC); }
+ 
+ 	/* compression algorithms */
+ {hyphen}C	{ return(F_COMP); }
+ oui		{ yylval.num = SADB_X_CALG_OUI; return(ALG_COMP); }
+ deflate		{ yylval.num = SADB_X_CALG_DEFLATE; return(ALG_COMP); }
+ lzs		{ yylval.num = SADB_X_CALG_LZS; return(ALG_COMP); }
+ {hyphen}R	{ return(F_RAWCPI); }
+ 
+ 	/* extension */
+ {hyphen}m	{ return(F_MODE); }
+ transport	{ yylval.num = IPSEC_MODE_TRANSPORT; return(MODE); }
+ tunnel		{ yylval.num = IPSEC_MODE_TUNNEL; return(MODE); }
+ {hyphen}u	{ return(F_REQID); }
+ {hyphen}f	{ return(F_EXT); }
+ random-pad	{ yylval.num = SADB_X_EXT_PRAND; return(EXTENSION); }
+ seq-pad		{ yylval.num = SADB_X_EXT_PSEQ; return(EXTENSION); }
+ zero-pad	{ yylval.num = SADB_X_EXT_PZERO; return(EXTENSION); }
+ nocyclic-seq	{ return(NOCYCLICSEQ); }
+ {hyphen}r	{ return(F_REPLAY); }
+ {hyphen}lh	{ return(F_LIFETIME_HARD); }
+ {hyphen}ls	{ return(F_LIFETIME_SOFT); }
+ 
+ 	/* ... */
+ any		{ return(ANY); }
+ {ws}		{ }
+ {nl}		{ lineno++; }
+ {comment}
+ {semi}		{ return(EOT); }
+ 
+ 	/* for address parameters: /prefix, [port] */
+ {slash}		{ return SLASH; }
+ {blcl}		{ return BLCL; }
+ {elcl}		{ return ELCL; }
+ 
+ 	/* parameter */
+ {decstring}	{
+ 			char *bp;
+ 
+ 			yylval.ulnum = strtoul(yytext, &bp, 10);
+ 			return(DECSTRING);
+ 		}
+ 
+ {hexstring}	{
+ 			yylval.val.buf = strdup(yytext + 2);
+ 			yylval.val.len = strlen(yylval.val.buf);
+ 
+ 			return(HEXSTRING);
+ 		}
+ 
+ {quotedstring}	{
+ 			char *p = yytext;
+ 			while (*++p != '"') ;
+ 			*p = '\0';
+ 			yytext++;
+ 			yylval.val.len = yyleng - 2;
+ 			yylval.val.buf = strdup(yytext);
+ 
+ 			return(QUOTEDSTRING);
+ 		}
+ 
+ [A-Za-z0-9:][A-Za-z0-9:%\.-]* {
+ 			yylval.val.len = yyleng;
+ 			yylval.val.buf = strdup(yytext);
+ 			return(STRING);
+ 		}
+ 
+ [0-9,]+ {
+ 			yylval.val.len = yyleng;
+ 			yylval.val.buf = strdup(yytext);
+ 			return(STRING);
+ 		}
+ 
+ .		{
+ 			yyfatal("Syntax error");
+ 			/*NOTREACHED*/
+ 		}
+ 
+ %%
+ 
+ void
+ yyfatal(s)
+ 	const char *s;
+ {
+ 	yyerror(s);
+ 	exit(1);
+ }
+ 
+ void
+ yyerror(s)
+ 	const char *s;
+ {
+ 	printf("line %d: %s at [%s]\n", lineno, s, yytext);
+ }
+ 
+ int
+ parse(fp)
+ 	FILE **fp;
+ {
+ 	yyin = *fp;
+ 
+ 	parse_init();
+ 
+ 	if (yyparse()) {
+ 		printf("parse failed, line %d.\n", lineno);
+ 		return(-1);
+ 	}
+ 
+ 	return(0);
+ }
